function Tx(n,e){return e.forEach(function(t){t&&typeof t!="string"&&!Array.isArray(t)&&Object.keys(t).forEach(function(s){if(s!=="default"&&!(s in n)){var r=Object.getOwnPropertyDescriptor(t,s);Object.defineProperty(n,s,r.get?r:{enumerable:!0,get:function(){return t[s]}})}})}),Object.freeze(n)}function Xn(){}function Ex(n,e){for(const t in e)n[t]=e[t];return n}function _p(n){return n()}function Ap(){return Object.create(null)}function fr(n){n.forEach(_p)}function Rx(n){return typeof n=="function"}function Dp(n,e){return n!=n?e==e:n!==e||n&&typeof n=="object"||typeof n=="function"}let lo;function UW(n,e){return lo||(lo=document.createElement("a")),lo.href=e,n===lo.href}function _x(n){return Object.keys(n).length===0}function GW(n,e,t,s){if(n){const r=Fp(n,e,t,s);return n[0](r)}}function Fp(n,e,t,s){return n[1]&&s?Ex(t.ctx.slice(),n[1](s(e))):t.ctx}function HW(n,e,t,s){if(n[2]&&s){const r=n[2](s(t));if(e.dirty===void 0)return r;if(typeof r=="object"){const a=[],o=Math.max(e.dirty.length,r.length);for(let i=0;i<o;i+=1)a[i]=e.dirty[i]|r[i];return a}return e.dirty|r}return e.dirty}function qW(n,e,t,s,r,a){if(r){const o=Fp(e,t,s,a);n.p(o,r)}}function jW(n){if(n.ctx.length>32){const e=[],t=n.ctx.length/32;for(let s=0;s<t;s++)e[s]=-1;return e}return-1}function Op(n){return n==null?"":n}let uo=!1;function Ax(){uo=!0}function Dx(){uo=!1}function Fx(n,e,t,s){for(;n<e;){const r=n+(e-n>>1);t(r)<=s?n=r+1:e=r}return n}function Ox(n){if(n.hydrate_init)return;n.hydrate_init=!0;let e=n.childNodes;if(n.nodeName==="HEAD"){const c=[];for(let l=0;l<e.length;l++){const u=e[l];u.claim_order!==void 0&&c.push(u)}e=c}const t=new Int32Array(e.length+1),s=new Int32Array(e.length);t[0]=-1;let r=0;for(let c=0;c<e.length;c++){const l=e[c].claim_order,u=(r>0&&e[t[r]].claim_order<=l?r+1:Fx(1,r,p=>e[t[p]].claim_order,l))-1;s[c]=t[u]+1;const d=u+1;t[d]=c,r=Math.max(d,r)}const a=[],o=[];let i=e.length-1;for(let c=t[r]+1;c!=0;c=s[c-1]){for(a.push(e[c-1]);i>=c;i--)o.push(e[i]);i--}for(;i>=0;i--)o.push(e[i]);a.reverse(),o.sort((c,l)=>c.claim_order-l.claim_order);for(let c=0,l=0;c<o.length;c++){for(;l<a.length&&o[c].claim_order>=a[l].claim_order;)l++;const u=l<a.length?a[l]:null;n.insertBefore(o[c],u)}}function Px(n,e){n.appendChild(e)}function bl(n,e){if(uo){for(Ox(n),(n.actual_end_child===void 0||n.actual_end_child!==null&&n.actual_end_child.parentElement!==n)&&(n.actual_end_child=n.firstChild);n.actual_end_child!==null&&n.actual_end_child.claim_order===void 0;)n.actual_end_child=n.actual_end_child.nextSibling;e!==n.actual_end_child?(e.claim_order!==void 0||e.parentNode!==n)&&n.insertBefore(e,n.actual_end_child):n.actual_end_child=e.nextSibling}else(e.parentNode!==n||e.nextSibling!==null)&&n.appendChild(e)}function mr(n,e,t){uo&&!t?bl(n,e):(e.parentNode!==n||e.nextSibling!=t)&&n.insertBefore(e,t||null)}function It(n){n.parentNode.removeChild(n)}function KW(n,e){for(let t=0;t<n.length;t+=1)n[t]&&n[t].d(e)}function Pp(n){return document.createElement(n)}function Yn(n){return document.createElementNS("http://www.w3.org/2000/svg",n)}function wl(n){return document.createTextNode(n)}function XW(){return wl(" ")}function Lp(){return wl("")}function Bp(n,e,t,s){return n.addEventListener(e,t,s),()=>n.removeEventListener(e,t,s)}function he(n,e,t){t==null?n.removeAttribute(e):n.getAttribute(e)!==t&&n.setAttribute(e,t)}function Qn(n){return Array.from(n.childNodes)}function Lx(n){n.claim_info===void 0&&(n.claim_info={last_index:0,total_claimed:0})}function Vp(n,e,t,s,r=!1){Lx(n);const a=(()=>{for(let o=n.claim_info.last_index;o<n.length;o++){const i=n[o];if(e(i)){const c=t(i);return c===void 0?n.splice(o,1):n[o]=c,r||(n.claim_info.last_index=o),i}}for(let o=n.claim_info.last_index-1;o>=0;o--){const i=n[o];if(e(i)){const c=t(i);return c===void 0?n.splice(o,1):n[o]=c,r?c===void 0&&n.claim_info.last_index--:n.claim_info.last_index=o,i}}return s()})();return a.claim_order=n.claim_info.total_claimed,n.claim_info.total_claimed+=1,a}function Mp(n,e,t,s){return Vp(n,r=>r.nodeName===e,r=>{const a=[];for(let o=0;o<r.attributes.length;o++){const i=r.attributes[o];t[i.name]||a.push(i.name)}a.forEach(o=>r.removeAttribute(o))},()=>s(e))}function YW(n,e,t){return Mp(n,e,t,Pp)}function Is(n,e,t){return Mp(n,e,t,Yn)}function Bx(n,e){return Vp(n,t=>t.nodeType===3,t=>{const s=""+e;if(t.data.startsWith(s)){if(t.data.length!==s.length)return t.splitText(s.length)}else t.data=s},()=>wl(e),!0)}function QW(n){return Bx(n," ")}function ZW(n,e){e=""+e,n.wholeText!==e&&(n.data=e)}function JW(n,e,t,s){n.style.setProperty(e,t,s?"important":"")}let po;function Vx(){if(po===void 0){po=!1;try{typeof window!="undefined"&&window.parent&&window.parent.document}catch{po=!0}}return po}function ez(n,e){getComputedStyle(n).position==="static"&&(n.style.position="relative");const s=Pp("iframe");s.setAttribute("style","display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;"),s.setAttribute("aria-hidden","true"),s.tabIndex=-1;const r=Vx();let a;return r?(s.src="data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}<\/script>",a=Bp(window,"message",o=>{o.source===s.contentWindow&&e()})):(s.src="about:blank",s.onload=()=>{a=Bp(s.contentWindow,"resize",e)}),Px(n,s),()=>{(r||a&&s.contentWindow)&&a(),It(s)}}function tz(n,e=document.body){return Array.from(e.querySelectorAll(n))}let ho;function fo(n){ho=n}function $l(){if(!ho)throw new Error("Function called outside component initialization");return ho}function nz(n){$l().$$.on_mount.push(n)}function sz(n){$l().$$.after_update.push(n)}function rz(n,e){$l().$$.context.set(n,e)}const gr=[],Wp=[],mo=[],zp=[],Mx=Promise.resolve();let vl=!1;function Wx(){vl||(vl=!0,Mx.then(Up))}function Cl(n){mo.push(n)}let Nl=!1;const kl=new Set;function Up(){if(!Nl){Nl=!0;do{for(let n=0;n<gr.length;n+=1){const e=gr[n];fo(e),zx(e.$$)}for(fo(null),gr.length=0;Wp.length;)Wp.pop()();for(let n=0;n<mo.length;n+=1){const e=mo[n];kl.has(e)||(kl.add(e),e())}mo.length=0}while(gr.length);for(;zp.length;)zp.pop()();vl=!1,Nl=!1,kl.clear()}}function zx(n){if(n.fragment!==null){n.update(),fr(n.before_update);const e=n.dirty;n.dirty=[-1],n.fragment&&n.fragment.p(n.ctx,e),n.after_update.forEach(Cl)}}const go=new Set;let Zn;function az(){Zn={r:0,c:[],p:Zn}}function oz(){Zn.r||fr(Zn.c),Zn=Zn.p}function Ux(n,e){n&&n.i&&(go.delete(n),n.i(e))}function iz(n,e,t,s){if(n&&n.o){if(go.has(n))return;go.add(n),Zn.c.push(()=>{go.delete(n),s&&(t&&n.d(1),s())}),n.o(e)}}function cz(n,e){const t={},s={},r={$$scope:1};let a=n.length;for(;a--;){const o=n[a],i=e[a];if(i){for(const c in o)c in i||(s[c]=1);for(const c in i)r[c]||(t[c]=i[c],r[c]=1);n[a]=i}else for(const c in o)r[c]=1}for(const o in s)o in t||(t[o]=void 0);return t}function lz(n){return typeof n=="object"&&n!==null?n:{}}function uz(n){n&&n.c()}function dz(n,e){n&&n.l(e)}function Gx(n,e,t,s){const{fragment:r,on_mount:a,on_destroy:o,after_update:i}=n.$$;r&&r.m(e,t),s||Cl(()=>{const c=a.map(_p).filter(Rx);o?o.push(...c):fr(c),n.$$.on_mount=[]}),i.forEach(Cl)}function Hx(n,e){const t=n.$$;t.fragment!==null&&(fr(t.on_destroy),t.fragment&&t.fragment.d(e),t.on_destroy=t.fragment=null,t.ctx=[])}function qx(n,e){n.$$.dirty[0]===-1&&(gr.push(n),Wx(),n.$$.dirty.fill(0)),n.$$.dirty[e/31|0]|=1<<e%31}function jx(n,e,t,s,r,a,o,i=[-1]){const c=ho;fo(n);const l=n.$$={fragment:null,ctx:null,props:a,update:Xn,not_equal:r,bound:Ap(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(e.context||(c?c.$$.context:[])),callbacks:Ap(),dirty:i,skip_bound:!1,root:e.target||c.$$.root};o&&o(l.root);let u=!1;if(l.ctx=t?t(n,e.props||{},(d,p,...h)=>{const f=h.length?h[0]:p;return l.ctx&&r(l.ctx[d],l.ctx[d]=f)&&(!l.skip_bound&&l.bound[d]&&l.bound[d](f),u&&qx(n,d)),p}):[],l.update(),u=!0,fr(l.before_update),l.fragment=s?s(l.ctx):!1,e.target){if(e.hydrate){Ax();const d=Qn(e.target);l.fragment&&l.fragment.l(d),d.forEach(It)}else l.fragment&&l.fragment.c();e.intro&&Ux(n.$$.fragment),Gx(n,e.target,e.anchor,e.customElement),Dx(),Up()}fo(c)}class Kx{$destroy(){Hx(this,1),this.$destroy=Xn}$on(e,t){const s=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return s.push(t),()=>{const r=s.indexOf(t);r!==-1&&s.splice(r,1)}}$set(e){this.$$set&&!_x(e)&&(this.$$.skip_bound=!0,this.$$set(e),this.$$.skip_bound=!1)}}const Ss=[];function pz(n,e=Xn){let t;const s=new Set;function r(i){if(Dp(n,i)&&(n=i,t)){const c=!Ss.length;for(const l of s)l[1](),Ss.push(l,n);if(c){for(let l=0;l<Ss.length;l+=2)Ss[l][0](Ss[l+1]);Ss.length=0}}}function a(i){r(i(n))}function o(i,c=Xn){const l=[i,c];return s.add(l),s.size===1&&(t=e(r)||Xn),i(n),()=>{s.delete(l),s.size===0&&(t(),t=null)}}return{set:r,update:a,subscribe:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xx=1e-7,Yx=1e-4;class Il{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class yo{refCount(e){return At("refCount")}incRef(e){return At("incRef")}timerAvailable(){return!0}time(e){return At("time")}read(e){return At("read")}readSync(e){return At("readSync")}numDataIds(){return At("numDataIds")}disposeData(e,t){return At("disposeData")}write(e,t,s){return At("write")}move(e,t,s,r,a){return At("move")}memory(){return At("memory")}floatPrecision(){return At("floatPrecision")}epsilon(){return this.floatPrecision()===32?Xx:Yx}dispose(){return At("dispose")}}function At(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gp(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,cn(n,e,t)}function Qx(n,e){if(n.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${e.length}`);let t=n.length,s=0;for(;t>0;)s=Math.random()*t|0,t--,cn(n,t,s),cn(e,t,s)}function kn(n,e,t){return Math.max(n,Math.min(e,t))}function Sl(n){return n%2==0?n:n+1}function cn(n,e,t){const s=n[e];n[e]=n[t],n[t]=s}function Hp(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function Zx(n,e){const t=Math.random();return e*t+(1-t)*n}function Jx(n,e){let t=0;for(let s=0;s<n.length;s++){const r=Number(n[s])-Number(e[s]);t+=r*r}return t}function C(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function Ye(n,e,t=""){C($e(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function Jn(n){C(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function ln(n,e=[],t=!1){if(e==null&&(e=[]),Array.isArray(n)||nt(n)&&!t)for(let s=0;s<n.length;++s)ln(n[s],e,t);else e.push(n);return e}function B(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function eb(n){return n.length===0}function $e(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function at(n){return n%1==0}function tb(n){if(Math.tanh!=null)return Math.tanh(n);if(n===1/0)return 1;if(n===-1/0)return-1;{const e=Math.exp(2*n);return(e-1)/(e+1)}}function xo(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function nb(n){const e=new Uint32Array(n);for(let t=0;t<n;++t)e[t]=t;return Gp(e),e}function es(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function Tl(n,e=s=>0,t){return new Promise((s,r)=>{let a=0;const o=()=>{if(n()){s();return}a++;const i=e(a);if(t!=null&&a>=t){r();return}setTimeout(o,i)};o()})}function El(n,e){let t=1,s=-1;for(let a=0;a<n.length;++a)if(n[a]>=0)t*=n[a];else if(n[a]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${a}`);s=a}else if(n[a]<0)throw Error(`Shapes can not be < 0. Found ${n[a]} at dim ${a}`);if(s===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const r=n.slice();return r[s]=e/t,r}function ge(n,e){const t=e.length;return n=n==null?e.map((s,r)=>r):[].concat(n),C(n.every(s=>s>=-t&&s<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),C(n.every(s=>at(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?t+s:s)}function un(n,e){const t=[],s=[],r=e!=null&&Array.isArray(e)&&e.length===0,a=e==null||r?null:ge(e,n).sort();let o=0;for(let i=0;i<n.length;++i){if(a!=null){if(a[o]===i&&n[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${n[i]}' is not 1`);(a[o]==null||a[o]>i)&&n[i]===1&&(t.push(n[i]),s.push(i)),a[o]<=i&&o++}n[i]!==1&&(t.push(n[i]),s.push(i))}return{newShape:t,keptDims:s}}function Ue(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else throw new Error(`Unknown data type ${n}`);return t}function ot(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function qp(n,e){for(let t=0;t<n.length;t++){const s=n[t];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function jp(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function Rl(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function nt(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}function bo(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function Kp(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function jt(n){return typeof n=="string"||n instanceof String}function Xp(n){return typeof n=="boolean"}function Yp(n){return typeof n=="number"}function Ts(n){return Array.isArray(n)?Ts(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":Yp(n)?"float32":jt(n)?"string":Xp(n)?"bool":"float32"}function In(n){return!!(n&&n.constructor&&n.call&&n.apply)}function wo(n,e){for(let t=e;t<n;++t)if(n%t==0)return t;return n}function se(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let s=e-3;s>=0;--s)t[s]=t[s+1]*n[s+1];return t}function Qp(n,e,t,s=!1){const r=new Array;if(e.length===1){const a=e[0]*(s?2:1);for(let o=0;o<a;o++)r[o]=t[n+o]}else{const a=e[0],o=e.slice(1),i=o.reduce((c,l)=>c*l)*(s?2:1);for(let c=0;c<a;c++)r[c]=Qp(n+c*i,o,t,s)}return r}function St(n,e,t=!1){if(n.length===0)return e[0];const s=n.reduce((r,a)=>r*a)*(t?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return Qp(0,n,e,t)}function _l(n,e){const t=Qe(n,e);for(let s=0;s<t.length;s++)t[s]=1;return t}function Qe(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function Al(n,e){const t=n.reduce((s,r)=>s*r,1);if(e==null||e==="float32")return St(n,new Float32Array(t));if(e==="int32")return St(n,new Int32Array(t));if(e==="bool")return St(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function Dl(n){n.forEach(e=>{C(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function Wt(n,e,t){if(e===0)return 0;if(e===1)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=t[r]*n[r];return s}function Es(n,e,t){if(e===0)return[];if(e===1)return[n];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/t[r]),n-=s[r]*t[r];return s[s.length-1]=n,s}function Rs(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ht(...n){M().getBool("IS_TEST")||M().getBool("PROD")||console.warn(...n)}function sb(...n){M().getBool("IS_TEST")||M().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zp="tfjsflags";class Jp{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=rb,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&ht(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`),this.platformName=e,this.platform=t}registerFlag(e,t,s){if(this.flagRegistry[e]={evaluationFn:t,setHook:s},this.urlFlags[e]!=null){const r=this.urlFlags[e];ht(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Rs(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;const e=this.getQueryParams(this.global.location.search);Zp in e&&e[Zp].split(",").forEach(s=>{const[r,a]=s.split(":");this.urlFlags[r]=ob(r,a)})}}function rb(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...s)=>(ab(e,s[0],s[1]),s.join("="))),e}function ab(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function ob(n,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${n}.`)}function M(){return Fl}let Fl=null;function ib(n){Fl=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ol;function eh(){if(Ol==null){let n;if(typeof window!="undefined")n=window;else if(typeof global!="undefined")n=global;else if(typeof process!="undefined")n=process;else if(typeof self!="undefined")n=self;else throw new Error("Could not find a global object");Ol=n}return Ol}function cb(){const n=eh();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function Pl(n,e){const t=cb();if(t.has(n))return t.get(n);{const s=e();return t.set(n,s),t.get(n)}}const $o="Abs",yr="Acos",xr="Acosh",_s="Add",vo="AddN",Co="All",No="Any",ko="ArgMax",Io="ArgMin",br="Asin",wr="Asinh",$r="Atan",vr="Atanh",Cr="Atan2",So="AvgPool",Ll="AvgPoolGrad",To="AvgPool3D",Bl="AvgPool3DGrad",Eo="BatchMatMul",Ro="BatchToSpaceND",_o="Bincount",lb="BroadcastTo",Ao="BroadcastArgs",Nr="Cast",kr="Ceil",Ir="ClipByValue",Do="Complex",Fo="ComplexAbs",Oo="Concat",Po="Conv2D",Lo="Conv2DBackpropFilter",Bo="Conv2DBackpropInput",Vo="Conv3D",Vl="Conv3DBackpropFilterV2",Mo="Conv3DBackpropInputV2",Sr="Cos",Tr="Cosh",Wo="Cumsum",zo="CropAndResize",Uo="DenseBincount",Go="DepthToSpace",Ho="DepthwiseConv2dNative",qo="DepthwiseConv2dNativeBackpropFilter",jo="DepthwiseConv2dNativeBackpropInput",Ko="Diag",Xo="Dilation2D",Ml="Dilation2DBackpropInput",Wl="Dilation2DBackpropFilter",Er="RealDiv",Yo="Einsum",Rr="Elu",zl="EluGrad",_r="Erf",Ar="Equal",Dr="Exp",Qo="ExpandDims",Fr="Expm1",Zo="FFT",Jo="Fill",ei="FlipLeftRight",Or="Floor",Pr="FloorDiv",ti="FusedBatchNorm",ni="GatherV2",si="GatherNd",Lr="Greater",Br="GreaterEqual",Vr="Identity",ri="IFFT",ai="Imag",Mr="IsFinite",Wr="IsInf",zr="IsNan",oi="LeakyRelu",Ur="Less",Gr="LessEqual",ii="LinSpace",Hr="Log",qr="Log1p",jr="LogicalAnd",Kr="LogicalNot",Xr="LogicalOr",ub="LogSoftmax",ci="LRN",Ul="LRNGrad",li="Max",Yr="Maximum",ui="MaxPool",Gl="MaxPoolGrad",di="MaxPool3D",Hl="MaxPool3DGrad",pi="MaxPoolWithArgmax",hi="Mean",fi="Min",Qr="Minimum",mi="MirrorPad",Zr="Mod",gi="Multinomial",Jr="Multiply",yi="Neg",ea="NotEqual",xi="NonMaxSuppressionV3",bi="NonMaxSuppressionV4",wi="NonMaxSuppressionV5",$i="OnesLike",vi="OneHot",Ci="Pack",Ni="PadV2",db="Pool",ta="Pow",ki="Prelu",Ii="Prod",Si="Range",Ti="Real",na="Reciprocal",sa="Relu",Ei="Reshape",Ri="ResizeNearestNeighbor",ql="ResizeNearestNeighborGrad",_i="ResizeBilinear",jl="ResizeBilinearGrad",ra="Relu6",Ai="Reverse",aa="Round",oa="Rsqrt",Di="ScatterNd",Fi="Select",ia="Selu",Oi="Slice",ca="Sin",la="Sinh",ua="Sign",da="Sigmoid",pa="Softplus",ha="Sqrt",Pi="Sum",Li="SpaceToBatchND",Bi="SplitV",Vi="Softmax",Mi="SparseFillEmptyRows",Wi="SparseReshape",zi="SparseSegmentMean",Ui="SparseSegmentSum",Gi="SparseToDense",fa="SquaredDifference",Kl="Square",Hi="StridedSlice",qi="StringNGrams",ji="StringSplit",Ki="StringToHashBucketFast",ma="Sub",ga="Tan",ya="Tanh",xa="Tile",Xi="TopK",Yi="Transform",Qi="Transpose",Zi="Unique",Ji="Unpack",ec="UnsortedSegmentSum",tc="ZerosLike",ba="Step",nc="FromPixels",sc="RotateWithOffset",wa="_FusedMatMul",$a="FusedConv2D",va="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const As=Pl("kernelRegistry",()=>new Map),Ca=Pl("gradRegistry",()=>new Map);function rc(n,e){const t=Yl(n,e);return As.get(t)}function Xl(n){return Ca.get(n)}function ac(n){const e=As.entries(),t=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[a,o]=r,[i]=a.split("_");i===n&&t.push(o)}return t}function oc(n){const{kernelName:e,backendName:t}=n,s=Yl(e,t);As.has(s)&&ht(`The kernel '${e}' for backend '${t}' is already registered`),As.set(s,n)}function pb(n){const{kernelName:e}=n;Ca.has(e)&&M().getBool("DEBUG")&&ht(`Overriding the gradient for '${e}'`),Ca.set(e,n)}function hb(n,e){const t=Yl(n,e);if(!As.has(t))throw new Error(`The kernel '${n}' for backend '${e}' is not registered`);As.delete(t)}function fb(n){if(!Ca.has(n))throw new Error(`The gradient '${n}' for backend is not registered`);Ca.delete(n)}function mb(n,e){ac(n).forEach(s=>{const r=Object.assign({},s,{backendName:e});oc(r)})}function Yl(n,e){return`${e}_${n}`}var ts=typeof globalThis!="undefined"?globalThis:typeof window!="undefined"?window:typeof global!="undefined"?global:typeof self!="undefined"?self:{};function th(n){if(n.__esModule)return n;var e=Object.defineProperty({},"__esModule",{value:!0});return Object.keys(n).forEach(function(t){var s=Object.getOwnPropertyDescriptor(n,t);Object.defineProperty(e,t,s.get?s:{enumerable:!0,get:function(){return n[t]}})}),e}var Ql=Ae,Dt=null;try{Dt=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Ae(n,e,t){this.low=n|0,this.high=e|0,this.unsigned=!!t}Ae.prototype.__isLong__;Object.defineProperty(Ae.prototype,"__isLong__",{value:!0});function mt(n){return(n&&n.__isLong__)===!0}Ae.isLong=mt;var nh={},sh={};function ns(n,e){var t,s,r;return e?(n>>>=0,(r=0<=n&&n<256)&&(s=sh[n],s)?s:(t=De(n,(n|0)<0?-1:0,!0),r&&(sh[n]=t),t)):(n|=0,(r=-128<=n&&n<128)&&(s=nh[n],s)?s:(t=De(n,n<0?-1:0,!1),r&&(nh[n]=t),t))}Ae.fromInt=ns;function Ft(n,e){if(isNaN(n))return e?ss:Ot;if(e){if(n<0)return ss;if(n>=ah)return uh}else{if(n<=-oh)return gt;if(n+1>=oh)return lh}return n<0?Ft(-n,e).neg():De(n%Ds|0,n/Ds|0,e)}Ae.fromNumber=Ft;function De(n,e,t){return new Ae(n,e,t)}Ae.fromBits=De;var ic=Math.pow;function Zl(n,e,t){if(n.length===0)throw Error("empty string");if(n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return Ot;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var s;if((s=n.indexOf("-"))>0)throw Error("interior hyphen");if(s===0)return Zl(n.substring(1),e,t).neg();for(var r=Ft(ic(t,8)),a=Ot,o=0;o<n.length;o+=8){var i=Math.min(8,n.length-o),c=parseInt(n.substring(o,o+i),t);if(i<8){var l=Ft(ic(t,i));a=a.mul(l).add(Ft(c))}else a=a.mul(r),a=a.add(Ft(c))}return a.unsigned=e,a}Ae.fromString=Zl;function zt(n,e){return typeof n=="number"?Ft(n,e):typeof n=="string"?Zl(n,e):De(n.low,n.high,typeof e=="boolean"?e:n.unsigned)}Ae.fromValue=zt;var rh=1<<16,gb=1<<24,Ds=rh*rh,ah=Ds*Ds,oh=ah/2,ih=ns(gb),Ot=ns(0);Ae.ZERO=Ot;var ss=ns(0,!0);Ae.UZERO=ss;var Fs=ns(1);Ae.ONE=Fs;var ch=ns(1,!0);Ae.UONE=ch;var Jl=ns(-1);Ae.NEG_ONE=Jl;var lh=De(4294967295|0,2147483647|0,!1);Ae.MAX_VALUE=lh;var uh=De(4294967295|0,4294967295|0,!0);Ae.MAX_UNSIGNED_VALUE=uh;var gt=De(0,2147483648|0,!1);Ae.MIN_VALUE=gt;var K=Ae.prototype;K.toInt=function(){return this.unsigned?this.low>>>0:this.low};K.toNumber=function(){return this.unsigned?(this.high>>>0)*Ds+(this.low>>>0):this.high*Ds+(this.low>>>0)};K.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(gt)){var t=Ft(e),s=this.div(t),r=s.mul(t).sub(this);return s.toString(e)+r.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var a=Ft(ic(e,6),this.unsigned),o=this,i="";;){var c=o.div(a),l=o.sub(c.mul(a)).toInt()>>>0,u=l.toString(e);if(o=c,o.isZero())return u+i;for(;u.length<6;)u="0"+u;i=""+u+i}};K.getHighBits=function(){return this.high};K.getHighBitsUnsigned=function(){return this.high>>>0};K.getLowBits=function(){return this.low};K.getLowBitsUnsigned=function(){return this.low>>>0};K.getNumBitsAbs=function(){if(this.isNegative())return this.eq(gt)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&(e&1<<t)==0;t--);return this.high!=0?t+33:t+1};K.isZero=function(){return this.high===0&&this.low===0};K.eqz=K.isZero;K.isNegative=function(){return!this.unsigned&&this.high<0};K.isPositive=function(){return this.unsigned||this.high>=0};K.isOdd=function(){return(this.low&1)==1};K.isEven=function(){return(this.low&1)==0};K.equals=function(e){return mt(e)||(e=zt(e)),this.unsigned!==e.unsigned&&this.high>>>31==1&&e.high>>>31==1?!1:this.high===e.high&&this.low===e.low};K.eq=K.equals;K.notEquals=function(e){return!this.eq(e)};K.neq=K.notEquals;K.ne=K.notEquals;K.lessThan=function(e){return this.comp(e)<0};K.lt=K.lessThan;K.lessThanOrEqual=function(e){return this.comp(e)<=0};K.lte=K.lessThanOrEqual;K.le=K.lessThanOrEqual;K.greaterThan=function(e){return this.comp(e)>0};K.gt=K.greaterThan;K.greaterThanOrEqual=function(e){return this.comp(e)>=0};K.gte=K.greaterThanOrEqual;K.ge=K.greaterThanOrEqual;K.compare=function(e){if(mt(e)||(e=zt(e)),this.eq(e))return 0;var t=this.isNegative(),s=e.isNegative();return t&&!s?-1:!t&&s?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};K.comp=K.compare;K.negate=function(){return!this.unsigned&&this.eq(gt)?gt:this.not().add(Fs)};K.neg=K.negate;K.add=function(e){mt(e)||(e=zt(e));var t=this.high>>>16,s=this.high&65535,r=this.low>>>16,a=this.low&65535,o=e.high>>>16,i=e.high&65535,c=e.low>>>16,l=e.low&65535,u=0,d=0,p=0,h=0;return h+=a+l,p+=h>>>16,h&=65535,p+=r+c,d+=p>>>16,p&=65535,d+=s+i,u+=d>>>16,d&=65535,u+=t+o,u&=65535,De(p<<16|h,u<<16|d,this.unsigned)};K.subtract=function(e){return mt(e)||(e=zt(e)),this.add(e.neg())};K.sub=K.subtract;K.multiply=function(e){if(this.isZero())return Ot;if(mt(e)||(e=zt(e)),Dt){var t=Dt.mul(this.low,this.high,e.low,e.high);return De(t,Dt.get_high(),this.unsigned)}if(e.isZero())return Ot;if(this.eq(gt))return e.isOdd()?gt:Ot;if(e.eq(gt))return this.isOdd()?gt:Ot;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(ih)&&e.lt(ih))return Ft(this.toNumber()*e.toNumber(),this.unsigned);var s=this.high>>>16,r=this.high&65535,a=this.low>>>16,o=this.low&65535,i=e.high>>>16,c=e.high&65535,l=e.low>>>16,u=e.low&65535,d=0,p=0,h=0,f=0;return f+=o*u,h+=f>>>16,f&=65535,h+=a*u,p+=h>>>16,h&=65535,h+=o*l,p+=h>>>16,h&=65535,p+=r*u,d+=p>>>16,p&=65535,p+=a*l,d+=p>>>16,p&=65535,p+=o*c,d+=p>>>16,p&=65535,d+=s*u+r*l+a*c+o*i,d&=65535,De(h<<16|f,d<<16|p,this.unsigned)};K.mul=K.multiply;K.divide=function(e){if(mt(e)||(e=zt(e)),e.isZero())throw Error("division by zero");if(Dt){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?Dt.div_u:Dt.div_s)(this.low,this.high,e.low,e.high);return De(t,Dt.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?ss:Ot;var s,r,a;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return ss;if(e.gt(this.shru(1)))return ch;a=ss}else{if(this.eq(gt)){if(e.eq(Fs)||e.eq(Jl))return gt;if(e.eq(gt))return Fs;var o=this.shr(1);return s=o.div(e).shl(1),s.eq(Ot)?e.isNegative()?Fs:Jl:(r=this.sub(e.mul(s)),a=s.add(r.div(e)),a)}else if(e.eq(gt))return this.unsigned?ss:Ot;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();a=Ot}for(r=this;r.gte(e);){s=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(s)/Math.LN2),c=i<=48?1:ic(2,i-48),l=Ft(s),u=l.mul(e);u.isNegative()||u.gt(r);)s-=c,l=Ft(s,this.unsigned),u=l.mul(e);l.isZero()&&(l=Fs),a=a.add(l),r=r.sub(u)}return a};K.div=K.divide;K.modulo=function(e){if(mt(e)||(e=zt(e)),Dt){var t=(this.unsigned?Dt.rem_u:Dt.rem_s)(this.low,this.high,e.low,e.high);return De(t,Dt.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};K.mod=K.modulo;K.rem=K.modulo;K.not=function(){return De(~this.low,~this.high,this.unsigned)};K.and=function(e){return mt(e)||(e=zt(e)),De(this.low&e.low,this.high&e.high,this.unsigned)};K.or=function(e){return mt(e)||(e=zt(e)),De(this.low|e.low,this.high|e.high,this.unsigned)};K.xor=function(e){return mt(e)||(e=zt(e)),De(this.low^e.low,this.high^e.high,this.unsigned)};K.shiftLeft=function(e){return mt(e)&&(e=e.toInt()),(e&=63)==0?this:e<32?De(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):De(0,this.low<<e-32,this.unsigned)};K.shl=K.shiftLeft;K.shiftRight=function(e){return mt(e)&&(e=e.toInt()),(e&=63)==0?this:e<32?De(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):De(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};K.shr=K.shiftRight;K.shiftRightUnsigned=function(e){if(mt(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var s=this.low;return De(s>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?De(t,0,this.unsigned):De(t>>>e-32,0,this.unsigned)};K.shru=K.shiftRightUnsigned;K.shr_u=K.shiftRightUnsigned;K.toSigned=function(){return this.unsigned?De(this.low,this.high,!1):this};K.toUnsigned=function(){return this.unsigned?this:De(this.low,this.high,!0)};K.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};K.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};K.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};Ae.fromBytes=function(e,t,s){return s?Ae.fromBytesLE(e,t):Ae.fromBytesBE(e,t)};Ae.fromBytesLE=function(e,t){return new Ae(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};Ae.fromBytesBE=function(e,t){return new Ae(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)};var yb=Object.freeze(Tx({__proto__:null,[Symbol.toStringTag]:"Module",default:Ql},[Ql]));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rs=Ql||yb;function Na(n){return rs.fromString(n,!0,16)}const dh=Na("c3a5c85c97cb3127"),as=Na("b492b66fbe98f273"),it=Na("9ae16a3b2f90404f");function eu(n){return n.xor(n.shru(47))}function ph(n,e,t){const s=n.slice(e,e+t);return rs.fromBytes(Array.from(s),!0,!0)}function Se(n,e){return ph(n,e,8)}function hh(n,e){return ph(n,e,4)}function qe(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function Sn(n,e,t=Na("9ddfea08eb382d69")){let s=n.xor(e).mul(t);s=s.xor(s.shru(47));let r=e.xor(s).mul(t);return r=r.xor(r.shru(47)),r=r.mul(t),r}function xb(n,e,t,s,r,a){r=r.add(n),a=qe(a.add(r).add(s),21);const o=r;return r=r.add(e),r=r.add(t),a=a.add(qe(r,44)),[r.add(s),a.add(o)]}function cc(n,e,t,s){return xb(Se(n,e),Se(n,e+8),Se(n,e+16),Se(n,e+24),t,s)}function bb(n,e=n.length){if(e>=8){const t=it.add(e*2),s=Se(n,0).add(it),r=Se(n,e-8),a=qe(r,37).mul(t).add(s),o=qe(s,25).add(r).mul(t);return Sn(a,o,t)}if(e>=4){const t=it.add(e*2),s=hh(n,0);return Sn(s.shl(3).add(e),hh(n,e-4),t)}if(e>0){const t=n[0],s=n[e>>1],r=n[e-1],a=t+(s<<8),o=e+(r<<2);return eu(it.mul(a).xor(dh.mul(o))).mul(it)}return it}function wb(n,e=n.length){const t=it.add(e*2),s=Se(n,0).mul(as),r=Se(n,8),a=Se(n,e-8).mul(t),o=Se(n,e-16).mul(it);return Sn(qe(s.add(r),43).add(qe(a,30)).add(o),s.add(qe(r.add(it),18)).add(a),t)}function $b(n,e=n.length){const t=it.add(e*2),s=Se(n,0).mul(it),r=Se(n,8),a=Se(n,e-8).mul(t),o=Se(n,e-16).mul(it),i=qe(s.add(r),43).add(qe(a,30)).add(o),c=Sn(i,s.add(qe(r.add(it),18)).add(a),t),l=Se(n,16).mul(t),u=Se(n,24),d=i.add(Se(n,e-32)).mul(t),p=c.add(Se(n,e-24)).mul(t);return Sn(qe(l.add(u),43).add(qe(d,30)).add(p),l.add(qe(u.add(s),18)).add(d),t)}function fh(n,e=n.length){const t=rs.fromNumber(81,!0);if(e<=32)return e<=16?bb(n,e):wb(n,e);if(e<=64)return $b(n,e);let s=t,r=t.mul(as).add(113),a=eu(r.mul(it).add(113)).mul(it),o=[rs.UZERO,rs.UZERO],i=[rs.UZERO,rs.UZERO];s=s.mul(it).add(Se(n,0));let c=0;const l=(e-1>>6)*64,u=l+(e-1&63)-63;do s=qe(s.add(r).add(o[0]).add(Se(n,c+8)),37).mul(as),r=qe(r.add(o[1]).add(Se(n,c+48)),42).mul(as),s=s.xor(i[1]),r=r.add(o[0]).add(Se(n,c+40)),a=qe(a.add(i[0]),33).mul(as),o=cc(n,c,o[1].mul(as),s.add(i[0])),i=cc(n,c+32,a.add(i[1]),r.add(Se(n,c+16))),[a,s]=[s,a],c+=64;while(c!==l);const d=as.add(a.and(255).shl(1));return c=u,i[0]=i[0].add(e-1&63),o[0]=o[0].add(i[0]),i[0]=i[0].add(o[0]),s=qe(s.add(r).add(o[0]).add(Se(n,c+8)),37).mul(d),r=qe(r.add(o[1]).add(Se(n,c+48)),42).mul(d),s=s.xor(i[1].mul(9)),r=r.add(o[0].mul(9).add(Se(n,c+40))),a=qe(a.add(i[0]),33).mul(d),o=cc(n,c,o[1].mul(d),s.add(i[0])),i=cc(n,c+32,a.add(i[1]),r.add(Se(n,c+16))),[a,s]=[s,a],Sn(Sn(o[0],i[0],d).add(eu(r).mul(dh)).add(a),Sn(o[1],i[1],d).add(s),d)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dn(n,e){return e==="string"?Kt(n):Tn([n],e)}function vb(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function Tn(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=ln(n)),M().getBool("DEBUG")&&qp(n,e),vb(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let s=0;s<t.length;++s)Math.round(n[s])!==0&&(t[s]=1);return t}else throw new Error(`Unknown data type ${e}`)}function yt(){return M().platform.now()}function Cb(n,e){return M().platform.fetch(n,e)}function Kt(n,e="utf-8"){return e=e||"utf-8",M().platform.encode(n,e)}function os(n,e="utf-8"){return e=e||"utf-8",M().platform.decode(n,e)}var Nb=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",createScalarValue:dn,toTypedArray:Tn,now:yt,fetch:Cb,encodeString:Kt,decodeString:os,shuffle:Gp,shuffleCombo:Qx,clamp:kn,nearestLargerEven:Sl,swap:cn,sum:Hp,randUniform:Zx,distSquared:Jx,assert:C,assertShapesMatch:Ye,assertNonNull:Jn,flatten:ln,sizeFromShape:B,isScalarShape:eb,arraysEqual:$e,isInt:at,tanh:tb,sizeToSquarishShape:xo,createShuffledIndices:nb,rightPad:es,repeatedTry:Tl,inferFromImplicitShape:El,parseAxisParam:ge,squeezeShape:un,getTypedArrayFromDType:Ue,getArrayFromDType:ot,checkConversionForErrors:qp,isValidDtype:jp,hasEncodingLoss:Rl,isTypedArray:nt,bytesPerElement:bo,bytesFromStringArray:Kp,isString:jt,isBoolean:Xp,isNumber:Yp,inferDtype:Ts,isFunction:In,nearestDivisor:wo,computeStrides:se,toNestedArray:St,makeOnesTypedArray:_l,makeZerosTypedArray:Qe,makeZerosNestedTypedArray:Al,assertNonNegativeIntegerDimensions:Dl,locToIndex:Wt,indexToLoc:Es,isPromise:Rs,hexToLong:Na,fingerPrint64:fh});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kb{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new Sb)}profileKernel(e,t,s){let r;const a=()=>{r=s()};let o;const i=yt();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(a);else{a();for(const l of r)l.dataSync();o=Promise.resolve({kernelMs:yt()-i})}if(M().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<r.length;l++){const u=r[l];u.data().then(d=>{Ib(d,u.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:o.then(l=>l.kernelMs),extraInfo:o.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:s,timeMs:r,inputs:a,extraInfo:o}=e;s.forEach(i=>{Promise.all([i.data(),r,o]).then(c=>{this.logger.logKernelProfile(t,i,c[0],c[1],a,c[2])})})}}function Ib(n,e,t){if(e!=="float32")return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${t}'`),!0}return!1}class Sb{logKernelProfile(e,t,s,r,a,o){const i=typeof r=="number"?es(`${r}ms`,9):r.error,c=es(e,25),l=t.rank,u=t.size,d=es(t.shape.toString(),14);let p="";for(const h in a){const f=a[h];if(f!=null){const m=f.shape||t.shape,g=m.length;p+=`${h}: ${g}D ${g>0?m:""} `}}console.log(`%c${c}	%c${i}	%c${l}D ${d}	%c${u}	%c${p}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tb(n,e,t){const s={},r={};for(let c=0;c<e.length;c++)s[e[c].id]=!0;for(let c=0;c<n.length;c++){const l=n[c],u=l.inputs;for(const d in u){const p=u[d];let h=!1;for(let f=0;f<e.length;f++)if(s[p.id]){l.outputs.forEach(m=>s[m.id]=!0),h=!0,r[l.id]=!0;break}if(h)break}}const a={};a[t.id]=!0;const o={};for(let c=n.length-1;c>=0;c--){const l=n[c],u=l.inputs;for(let d=0;d<l.outputs.length;d++)if(a[l.outputs[d].id]){for(const p in u)a[u[p].id]=!0,o[l.id]=!0;break}}const i=[];for(let c=0;c<n.length;c++){const l=n[c];if(r[l.id]&&o[l.id]){const u={};for(const p in l.inputs){const h=l.inputs[p];s[h.id]&&(u[p]=h)}const d=Object.assign({},l);d.inputs=u,d.outputs=l.outputs,i.push(d)}}return i}function Eb(n,e,t,s){for(let r=e.length-1;r>=0;r--){const a=e[r],o=[];if(a.outputs.forEach(c=>{const l=n[c.id];l!=null?o.push(l):o.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const i=a.gradient(o);for(const c in a.inputs){if(!(c in i))throw new Error(`Cannot backprop through input ${c}. Available gradients found: ${Object.keys(i)}.`);const l=t(()=>i[c]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${c} must have 'float32' dtype, but has '${l.dtype}'`);const u=a.inputs[c];if(!$e(l.shape,u.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${c}' has shape '${l.shape}', which does not match the shape of the input '${u.shape}'`);if(n[u.id]==null)n[u.id]=l;else{const d=n[u.id];n[u.id]=s(d,l),d.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mh=20,ka=3,tu=7;function Rb(n,e,t,s){const r=se(e),a=_b(n,e,t,r),o=e.length,i=lc(n,e,t,r,a),c=["Tensor"];return s&&(c.push(`  dtype: ${t}`),c.push(`  rank: ${o}`),c.push(`  shape: [${e}]`),c.push("  values:")),c.push(i.map(l=>"    "+l).join(`
`)),c.join(`
`)}function _b(n,e,t,s){const r=B(e),a=s[s.length-1],o=new Array(a).fill(0),i=e.length,c=t==="complex64"?Sa(n):n;if(i>1)for(let l=0;l<r/a;l++){const u=l*a;for(let d=0;d<a;d++)o[d]=Math.max(o[d],Ia(c[u+d],0,t).length)}return o}function Ia(n,e,t){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(tu))} + ${parseFloat(n[1].toFixed(tu))}j`:jt(n)?s=`'${n}'`:t==="bool"?s=gh(n):s=parseFloat(n.toFixed(tu)).toString(),es(s,e)}function gh(n){return n===0?"false":"true"}function lc(n,e,t,s,r,a=!0){const o=t==="complex64"?2:1,i=e[0],c=e.length;if(c===0){if(t==="complex64"){const m=Sa(n);return[Ia(m[0],0,t)]}return t==="bool"?[gh(n[0])]:[n[0].toString()]}if(c===1){if(i>mh){const g=ka*o;let y=Array.from(n.slice(0,g)),x=Array.from(n.slice((i-ka)*o,i*o));return t==="complex64"&&(y=Sa(y),x=Sa(x)),["["+y.map((w,$)=>Ia(w,r[$],t)).join(", ")+", ..., "+x.map((w,$)=>Ia(w,r[i-ka+$],t)).join(", ")+"]"]}const m=t==="complex64"?Sa(n):Array.from(n);return["["+m.map((g,y)=>Ia(g,r[y],t)).join(", ")+"]"]}const l=e.slice(1),u=s.slice(1),d=s[0]*o,p=[];if(i>mh){for(let m=0;m<ka;m++){const g=m*d,y=g+d;p.push(...lc(n.slice(g,y),l,t,u,r,!1))}p.push("...");for(let m=i-ka;m<i;m++){const g=m*d,y=g+d;p.push(...lc(n.slice(g,y),l,t,u,r,m===i-1))}}else for(let m=0;m<i;m++){const g=m*d,y=g+d;p.push(...lc(n.slice(g,y),l,t,u,r,m===i-1))}const h=c===2?",":"";p[0]="["+p[0]+h;for(let m=1;m<p.length-1;m++)p[m]=" "+p[m]+h;let f=`,
`;for(let m=2;m<c;m++)f+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(a?"":f),p}function Sa(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ge{constructor(e,t,s){if(this.dtype=t,this.shape=e.slice(),this.size=B(e),s!=null){const r=s.length;C(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||ot(t,this.size),this.strides=se(e)}set(e,...t){t.length===0&&(t=[0]),C(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const s=this.locToIndex(t);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t]){const a=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(a)}t++}let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=this.strides[r]*e[r];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let s=0;s<e.length-1;++s)t+=this.strides[s]*e[s];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let s=0;s<t.length-1;++s)t[s]=Math.floor(e/this.strides[s]),e-=t[s]*this.strides[s];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Xt().makeTensor(this.values,this.shape,this.dtype)}}let Xt=null,Os=null;function Ab(n){Xt=n}function Db(n){Os=n}class Ve{constructor(e,t,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=B(e),this.strides=se(e),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Os.buffer(this.shape,this.dtype,e)}bufferSync(){return Os.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return St(this.shape,e,this.dtype==="complex64")}arraySync(){return St(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Xt().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(s=>os(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataSync(){this.throwIfDisposed();const e=Xt().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>os(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Xt().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(Xt().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Os.print(this,e)}clone(){return this.throwIfDisposed(),Os.clone(this)}toString(e=!1){const t=this.dataSync();return Rb(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Os.cast(this,e)}variable(e=!0,t,s){return this.throwIfDisposed(),Xt().makeVariable(this,e,t,s)}}Object.defineProperty(Ve,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function Fb(){return Pl("Tensor",()=>Ve)}Fb();class Ta extends Ve{constructor(e,t,s,r){super(e.shape,e.dtype,e.dataId,r);this.trainable=t,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!$e(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Xt().disposeTensor(this),this.dataId=e.dataId,Xt().incRef(this,null)}dispose(){Xt().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Ta,Symbol.hasInstance,{value:n=>n instanceof Ve&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var nu;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(nu||(nu={}));var su;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(su||(su={}));var ru;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(ru||(ru={}));var au;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(au||(au={}));var ou;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(ou||(ou={}));const Ob={float32:au,int32:su,bool:ru,complex64:ou};function xt(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return Ob[n][e]}function uc(n){return xt(n,"int32")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pe(n,e){if(n.dtype===e.dtype)return[n,e];const t=xt(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function yh(n,e){C(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function Pb(n,e){return e.some(t=>t.id===n.id)}function iu(n){const e=[],t=new Set;return xh(n,e,t),e}function xh(n,e,t){if(n==null)return;if(n instanceof Ve){e.push(n);return}if(!Lb(n))return;const s=n;for(const r in s){const a=s[r];t.has(a)||(t.add(a),xh(a,e,t))}}function Lb(n){return Array.isArray(n)||typeof n=="object"}var Bb=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",makeTypesMatch:Pe,assertTypesMatch:yh,isTensorInList:Pb,getTensorsInContainer:iu});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cu(n){return n.kernelName!=null}class bh{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Ps{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new bh}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,s=1){return e in this.registryFactory?(ht(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:s}=this.initializeBackend(e);if(!(s?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new kb(this.backendInstance),!0}setupRegisteredKernels(){ac(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){ac(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=t.factory();if(s&&!(s instanceof yo)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,a=s.then(o=>r<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,ht(`Initialization of backend ${e} failed`),ht(o.stack||o.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return ht(`Initialization of backend ${e} failed`),ht(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t],{success:r,asyncInit:a}=this.initializeBackend(s);if(a||r)return{name:s,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const s=this.state.tensorInfo.get(t),r=s.backend,a=this.readSync(t),o=r.refCount(t);r.disposeData(t,!0),s.backend=e,e.move(t,a,s.shape,s.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,s){e();try{const r=s();return t(),r}catch(r){throw t(),r}}nextTensorId(){return Ps.nextTensorId++}nextVariableId(){return Ps.nextVariableId++}clone(e){const t=E.runKernel(Vr,{x:e}),s={x:e},r=o=>({x:()=>{const i="float32",c={x:o},l={dtype:i};return E.runKernel(Nr,c,l)}}),a=[];return this.addTapeNode(this.state.activeScope.name,s,[t],r,a,{}),t}runKernel(e,t,s){if(this.backendName==null&&this.backend,!(rc(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,s){const r=this.backend.numDataIds();let a=0;s.forEach(c=>{a+=c.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-t-a-o;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,s=[];const r=this.isTapeOn(),a=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let c;const l=cu(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(cu(e)){const{kernelName:f,inputs:m,attrs:g}=e;this.backendName==null&&this.backend;const y=rc(f,this.backendName);C(y!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),i=()=>{const x=this.backend.numDataIds();c=y.kernelFunc({inputs:m,attrs:g,backend:this.backend});const w=Array.isArray(c)?c:[c];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,x,w);const $=w.map(v=>{if(v.rank!=null)return v;const{dataId:k,shape:I,dtype:S}=v;return this.makeTensorFromDataId(k,I,S)});if(r){const v=this.getTensorsForGradient(f,m,$);s=this.saveTensorsForBackwardMode(v)}return $}}else{const{forwardFunc:f}=e,m=g=>{!r||(s=g.map(y=>this.keep(this.clone(y))))};i=()=>{const g=this.backend.numDataIds();c=this.tidy(()=>f(this.backend,m));const y=Array.isArray(c)?c:[c];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,g,y),y}}const{inputs:u,attrs:d}=e,p=cu(e)?null:e.backwardsFunc;let h;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=i():(h=this.profiler.profileKernel(l,u,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),t=h.outputs)}),r&&this.addTapeNode(l,u,t,p,s,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(f=>u[f]!=null?u[f].shape:null),outputShapes:t.map(f=>f.shape),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(c)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,t,s){const r=Xl(e);if(r!=null){const a=r.inputsToSave||[],o=r.outputsToSave||[];let i;r.saveAllInputs?(C(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(t).map(l=>t[l])):i=a.map(l=>t[l]);const c=s.filter((l,u)=>o[u]);return i.concat(c)}return[]}makeTensor(e,t,s,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let a=e;s==="string"&&jt(e[0])&&(a=e.map(c=>Kt(c)));const o=r.write(a,t,s),i=new Ve(t,s,o,this.nextTensorId());if(this.trackTensor(i,r),s==="string"){const c=this.state.tensorInfo.get(o),l=Kp(a);this.state.numBytes+=l-c.bytes,c.bytes=l}return i}makeTensorFromDataId(e,t,s,r){s=s||"float32";const a=new Ve(t,s,e,this.nextTensorId());return this.trackTensor(a,r),a}makeVariable(e,t=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const a=new Ta(e,t,s,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*bo(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof Ta||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*bo(e.dtype);this.state.numBytes-=s}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,s,r,a,o){const i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:s,saved:a},c=Xl(e);c!=null&&(r=c.gradFunc),r!=null&&(i.gradient=l=>(l=l.map((u,d)=>{if(u==null){const p=s[d],h=Qe(p.size,p.dtype);return this.makeTensor(h,p.shape,p.dtype)}return u}),r(l.length>1?l:l[0],a,o))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=iu(e),s=new Set(t.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){const o=this.state.activeScope.track[a];!o.kept&&!s.has(o.id)&&o.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(a=>{!a.kept&&a.scopeId===r.id&&this.track(a)})}gradients(e,t,s,r=!1){if(C(t.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));C(a instanceof Ve,()=>"The result y returned by f() must be a tensor.");const o=Tb(this.state.activeTape,t,a);if(!r&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const i={};i[a.id]=s==null?Vb(a.shape):s,Eb(i,o,l=>this.tidy(l),Mb);const c=t.map(l=>i[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(const u of l.saved)u.dispose()}),this.state.activeTape=null),{value:a,grads:c}})}customGrad(e){return C(In(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{C(t.every(i=>i instanceof Ve),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};t.forEach((i,c)=>{r[c]=i});const a=(i,c)=>(s=e(...t,c),C(s.value instanceof Ve,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),C(In(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),o=(i,c)=>{const l=s.gradFunc(i,c),u=Array.isArray(l)?l:[l];C(u.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),C(u.every(p=>p instanceof Ve),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const d={};return u.forEach((p,h)=>{d[h]=()=>p}),d};return this.runKernelFunc({forwardFunc:a,backwardsFunc:o,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}async time(e){const t=yt(),s=await this.backend.time(e);return s.wallMs=yt()-t,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new bh;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Ps.nextTensorId=0;Ps.nextVariableId=0;function Vb(n){const e=_l(B(n),"float32");return E.makeTensor(e,n,"float32")}function wh(){const n=eh();if(n._tfengine==null){const e=new Jp(n);n._tfengine=new Ps(e)}return ib(n._tfengine.ENV),Ab(()=>n._tfengine),n._tfengine}const E=wh();function Mb(n,e){const t={a:n,b:e};return E.runKernel(_s,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wb(){return typeof navigator!="undefined"&&navigator!=null}let lu;function zb(n){lu=n}function uu(n){if(lu!==void 0)return lu;if(n||Wb()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window!="undefined"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function du(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}var Ub=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",mockIsMobile:zb,isMobile:uu,isBrowser:du});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ut=M();Ut.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Ut.registerFlag("IS_BROWSER",()=>du());Ut.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");Ut.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Ut.registerFlag("PROD",()=>!1);Ut.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Ut.getBool("DEBUG"));Ut.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Ut.registerFlag("IS_TEST",()=>!1);Ut.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);Ut.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yt(n,e){let t=n;if(nt(n))return e==="string"?[]:[n.length];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(t)||nt(t)&&e!=="string";)s.push(t.length),t=t[0];return Array.isArray(n)&&M().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&$h(n,s,[]),s}function $h(n,e,t){if(t=t||[],!Array.isArray(n)&&!nt(n)){C(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}C(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),C(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const s=e.slice(1);for(let r=0;r<n.length;++r)$h(n[r],s,t.concat(r))}function vh(n,e,t,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${s}' must be ${n} tensor, but got ${e} tensor`)}}function N(n,e,t,s="numeric"){if(n instanceof Ve)return vh(s,n.dtype,e,t),n;let r=Ts(n);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),vh(s,r,e,t),n==null||!nt(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const c=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${c}'`)}const a=Yt(n,r);!nt(n)&&!Array.isArray(n)&&(n=[n]);const i=r!=="string"?Tn(n,r):ln(n,[],!0);return E.makeTensor(i,a,r)}function Ea(n,e,t,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((a,o)=>N(a,`${e}[${o}]`,t,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ch="__op";function T(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const s=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+Ch;const r=(...a)=>{E.startScope(t);try{const o=s(...a);return Rs(o)&&console.error("Cannot return a Promise inside of tidy."),E.endScope(o),o}catch(o){throw E.endScope(null),o}};return Object.defineProperty(r,"name",{value:t,configurable:!0}),r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gb(n,e){const t=N(n,"real","complex"),s=N(e,"imag","complex");Ye(t.shape,s.shape,`real and imag shapes, ${t.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:t,imag:s};return E.runKernel(Do,r)}const En=T({complex_:Gb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rn(n,e,t,s){if(s==null&&(s=Ts(n)),s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!nt(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Dl(e);const r=B(e),a=B(t);C(r===a,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${a}`);for(let o=0;o<t.length;++o){const i=t[o],c=o===t.length-1?i!==B(e.slice(o)):!0;C(t[o]===e[o]||!c,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!nt(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=s!=="string"?Tn(n,s):ln(n,[],!0),E.makeTensor(n,e,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qt(n,e,t){const s=Yt(n,t);return Rn(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pu={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dc=4;async function Hb(n,e){const t=[],s=[],r=Array.isArray(n)?n.map(o=>o.name):Object.keys(n);for(let o=0;o<r.length;++o){const i=r[o],c=Array.isArray(n)?n[o].tensor:n[i];if(c.dtype!=="float32"&&c.dtype!=="int32"&&c.dtype!=="bool"&&c.dtype!=="string"&&c.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${c.dtype}`);const l={name:i,shape:c.shape,dtype:c.dtype};if(c.dtype==="string"){const u=new Promise(async d=>{const p=await c.bytes(),h=p.reduce((g,y)=>g+y.length,0)+dc*p.length,f=new Uint8Array(h);let m=0;for(let g=0;g<p.length;g++){const y=p[g],x=new Uint8Array(new Uint32Array([y.length]).buffer);f.set(x,m),m+=dc,f.set(y,m),m+=y.length}d(f)});s.push(u)}else s.push(c.data());e!=null&&(l.group=e),t.push(l)}const a=await Promise.all(s);return{data:qb(a),specs:t}}function hu(n,e){const t={};let s,r=0;for(const a of e){const o=a.name,i=a.dtype,c=a.shape,l=B(c);let u;if("quantization"in a){const d=a.quantization;if(d.dtype==="uint8"||d.dtype==="uint16"){if(!("min"in d&&"scale"in d))throw new Error(`Weight ${a.name} with quantization ${d.dtype} doesn't have corresponding metadata min and scale.`)}else if(d.dtype==="float16"){if(i!=="float32")throw new Error(`Weight ${a.name} is quantized with ${d.dtype} which only supports weights of type float32 not ${i}.`)}else throw new Error(`Weight ${a.name} has unknown quantization dtype ${d.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const p=pu[d.dtype],h=n.slice(r,r+l*p),f=d.dtype==="uint8"?new Uint8Array(h):new Uint16Array(h);if(i==="float32")if(d.dtype==="uint8"||d.dtype==="uint16"){u=new Float32Array(f.length);for(let m=0;m<f.length;m++){const g=f[m];u[m]=g*d.scale+d.min}}else if(d.dtype==="float16")s===void 0&&(s=Zb()),u=s(f);else throw new Error(`Unsupported quantization type ${d.dtype} for weight type float32.`);else if(i==="int32"){if(d.dtype!=="uint8"&&d.dtype!=="uint16")throw new Error(`Unsupported quantization type ${d.dtype} for weight type int32.`);u=new Int32Array(f.length);for(let m=0;m<f.length;m++){const g=f[m];u[m]=Math.round(g*d.scale+d.min)}}else throw new Error(`Unsupported dtype in weight '${o}': ${i}`);r+=l*p}else if(i==="string"){const d=B(a.shape);u=[];for(let p=0;p<d;p++){const h=new Uint32Array(n.slice(r,r+dc))[0];r+=dc;const f=new Uint8Array(n.slice(r,r+h));u.push(f),r+=h}}else{const d=pu[i],p=n.slice(r,r+l*d);if(i==="float32")u=new Float32Array(p);else if(i==="int32")u=new Int32Array(p);else if(i==="bool")u=new Uint8Array(p);else if(i==="complex64"){u=new Float32Array(p);const h=new Float32Array(u.length/2),f=new Float32Array(u.length/2);for(let y=0;y<h.length;y++)h[y]=u[y*2],f[y]=u[y*2+1];const m=Qt(h,c,"float32"),g=Qt(f,c,"float32");t[o]=En(m,g),m.dispose(),g.dispose()}else throw new Error(`Unsupported dtype in weight '${o}': ${i}`);r+=l*d}i!=="complex64"&&(t[o]=Qt(u,c,i))}return t}function qb(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(a=>{if(e+=a.byteLength,t.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});const s=new Uint8Array(e);let r=0;return t.forEach(a=>{s.set(new Uint8Array(a.buffer),r),r+=a.byteLength}),s.buffer}const fu=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function Nh(n){return fu?Buffer.byteLength(n):new Blob([n]).size}function jb(n){if(fu)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let s=0,r=e.length;s<r;s++)t+=String.fromCharCode(e[s]);return btoa(t)}function Kb(n){if(fu){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let s=0;s<e.length;++s)t.set([e.charCodeAt(s)],s);return t.buffer}function mu(n){if(n.length===1)return n[0];let e=0;n.forEach(r=>{e+=r.byteLength});const t=new Uint8Array(e);let s=0;return n.forEach(r=>{t.set(new Uint8Array(r),s),s+=r.byteLength}),t.buffer}function kh(n){const e="/";for(n=n.trim();n.endsWith(e);)n=n.slice(0,n.length-1);const t=n.split(e);return t[t.length-1]}function Ih(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}async function gu(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),n.weightsManifest!=null){const[s,r]=await e(n.weightsManifest);t.weightSpecs=s,t.weightData=r}return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),t}function Ra(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:Nh(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:Nh(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:n.weightData.byteLength}}function Xb(){const n=t=>{let s=t<<13,r=0;for(;(s&8388608)==0;)r-=8388608,s<<=1;return s&=~8388608,r+=947912704,s|r},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function Yb(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function Qb(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function Zb(){const n=Xb(),e=Yb(),t=Qb();return s=>{const r=new ArrayBuffer(4*s.length),a=new Uint32Array(r);for(let o=0;o<s.length;o++){const i=s[o],c=n[t[i>>10]+(i&1023)]+e[i>>10];a[o]=c}return new Float32Array(r)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Le{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Le.instance==null&&(Le.instance=new Le),Le.instance}static registerSaveRouter(e){Le.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Le.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Le.getHandlers(e,"save")}static getLoadHandlers(e,t){return Le.getHandlers(e,"load",t)}static getHandlers(e,t,s){const r=[];return(t==="load"?Le.getInstance().loadRouters:Le.getInstance().saveRouters).forEach(o=>{const i=o(e,s);i!==null&&r.push(i)}),r}}const Jb=n=>Le.registerSaveRouter(n),e0=n=>Le.registerLoadRouter(n),Sh=n=>Le.getSaveHandlers(n),Th=(n,e)=>Le.getLoadHandlers(n,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yu="tensorflowjs",xu=1,is="models_store",_n="model_info_store";function Eh(){if(!M().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window=="undefined"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function bu(n){const e=n.result;e.createObjectStore(is,{keyPath:"modelPath"}),e.createObjectStore(_n,{keyPath:"modelPath"})}class cs{constructor(e){if(this.indexedDB=Eh(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((s,r)=>{const a=this.indexedDB.open(yu,xu);a.onupgradeneeded=()=>bu(a),a.onsuccess=()=>{const o=a.result;if(t==null){const i=o.transaction(is,"readonly"),l=i.objectStore(is).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return o.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(l.result.modelArtifacts)},l.onerror=u=>(o.close(),r(l.error)),i.oncomplete=()=>o.close()}else{const i=Ra(t),c=o.transaction(_n,"readwrite");let l=c.objectStore(_n);const u=l.put({modelPath:this.modelPath,modelArtifactsInfo:i});let d;u.onsuccess=()=>{d=o.transaction(is,"readwrite");const h=d.objectStore(is).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i});h.onsuccess=()=>s({modelArtifactsInfo:i}),h.onerror=f=>{l=c.objectStore(_n);const m=l.delete(this.modelPath);m.onsuccess=()=>(o.close(),r(h.error)),m.onerror=g=>(o.close(),r(h.error))}},u.onerror=p=>(o.close(),r(u.error)),c.oncomplete=()=>{d==null?o.close():d.oncomplete=()=>o.close()}}},a.onerror=o=>r(a.error)})}}cs.URL_SCHEME="indexeddb://";const Rh=n=>M().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(cs.URL_SCHEME)?t0(n.slice(cs.URL_SCHEME.length)):null;Le.registerSaveRouter(Rh);Le.registerLoadRouter(Rh);function t0(n){return new cs(n)}function n0(n){return n.startsWith(cs.URL_SCHEME)?n.slice(cs.URL_SCHEME.length):n}class s0{constructor(){this.indexedDB=Eh()}async listModels(){return new Promise((e,t)=>{const s=this.indexedDB.open(yu,xu);s.onupgradeneeded=()=>bu(s),s.onsuccess=()=>{const r=s.result,a=r.transaction(_n,"readonly"),i=a.objectStore(_n).getAll();i.onsuccess=()=>{const c={};for(const l of i.result)c[l.modelPath]=l.modelArtifactsInfo;e(c)},i.onerror=c=>(r.close(),t(i.error)),a.oncomplete=()=>r.close()},s.onerror=r=>t(s.error)})}async removeModel(e){return e=n0(e),new Promise((t,s)=>{const r=this.indexedDB.open(yu,xu);r.onupgradeneeded=()=>bu(r),r.onsuccess=()=>{const a=r.result,o=a.transaction(_n,"readwrite"),i=o.objectStore(_n),c=i.get(e);let l;c.onsuccess=()=>{if(c.result==null)return a.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const u=i.delete(e),d=()=>{l=a.transaction(is,"readwrite");const h=l.objectStore(is).delete(e);h.onsuccess=()=>t(c.result.modelArtifactsInfo),h.onerror=f=>s(c.error)};u.onsuccess=d,u.onerror=p=>(d(),a.close(),s(c.error))}},c.onerror=u=>(a.close(),s(c.error)),o.oncomplete=()=>{l==null?a.close():l.oncomplete=()=>a.close()}},r.onerror=a=>s(r.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pn="/",Ls="tensorflowjs_models",_h="info",r0="model_topology",a0="weight_specs",o0="weight_data",i0="model_metadata";function Ah(n){return{info:[Ls,n,_h].join(pn),topology:[Ls,n,r0].join(pn),weightSpecs:[Ls,n,a0].join(pn),weightData:[Ls,n,o0].join(pn),modelMetadata:[Ls,n,i0].join(pn)}}function Dh(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function c0(n){const e=n.split(pn);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(pn)}function l0(n){return n.startsWith(ls.URL_SCHEME)?n.slice(ls.URL_SCHEME.length):n}class ls{constructor(e){if(!M().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Ah(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=Ra(e);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,jb(e.weightData));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch{throw Dh(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){const i=JSON.parse(a);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=Kb(o),t}}ls.URL_SCHEME="localstorage://";const Fh=n=>M().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(ls.URL_SCHEME)?u0(n.slice(ls.URL_SCHEME.length)):null;Le.registerSaveRouter(Fh);Le.registerLoadRouter(Fh);function u0(n){return new ls(n)}class d0{constructor(){C(M().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),C(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=Ls+pn,s=pn+_h;for(let r=0;r<this.LS.length;++r){const a=this.LS.key(r);if(a.startsWith(t)&&a.endsWith(s)){const o=c0(a);e[o]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){e=l0(e);const t=Ah(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(t.info));return Dh(t),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bs="://";class bt{constructor(){this.managers={}}static getInstance(){return bt.instance==null&&(bt.instance=new bt),bt.instance}static registerManager(e,t){C(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Bs)&&(e=e.slice(0,e.indexOf(Bs))),C(e.length>0,()=>"scheme must not be an empty string.");const s=bt.getInstance();C(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=t}static getManager(e){const t=this.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}}function pc(n){if(n.indexOf(Bs)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${bt.getSchemes().join(",")}`);return{scheme:n.split(Bs)[0],path:n.split(Bs)[1]}}async function Oh(n,e,t=!1){C(n!==e,()=>`Old path and new path are the same: '${n}'`);const s=Le.getLoadHandlers(n);C(s.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),C(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${n}.`);const r=s[0],a=Le.getSaveHandlers(e);C(a.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),C(a.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const o=a[0],i=pc(n).scheme,c=pc(n).path,l=i===pc(n).scheme,u=await r.load();t&&l&&await bt.getManager(i).removeModel(c);const d=await o.save(u);return t&&!l&&await bt.getManager(i).removeModel(c),d.modelArtifactsInfo}async function p0(){const n=bt.getSchemes(),e={};for(const t of n){const s=await bt.getManager(t).listModels();for(const r in s){const a=t+Bs+r;e[a]=s[r]}}return e}async function h0(n){const e=pc(n);return bt.getManager(e.scheme).removeModel(e.path)}async function f0(n,e){return Oh(n,e,!1)}async function m0(n,e){return Oh(n,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class g0{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}}if(M().get("IS_BROWSER")){M().setPlatform("browser",new g0);try{bt.registerManager(ls.URL_SCHEME,new d0)}catch{}try{bt.registerManager(cs.URL_SCHEME,new s0)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y0={importFetch:()=>require("node-fetch")};let wu;class x0{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return M().global.fetch!=null?M().global.fetch(e,t):(wu==null&&(wu=y0.importFetch()),wu(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}}M().get("IS_NODE")&&M().setPlatform("node",new x0);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ue(n,e="float32",t){return e=e||"float32",Dl(n),new Ge(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b0(n,e){const t=N(n,"x","cast");if(!jp(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:t},r={dtype:e};return E.runKernel(Nr,s,r)}const ve=T({cast_:b0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w0(n){const t={x:N(n,"x","clone","string_or_numeric")};return E.runKernel(Vr,t)}const An=T({clone_:w0});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ph(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */wh();const $0={buffer:ue,cast:ve,clone:An,print:Ph};Db($0);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v0="model",C0=".json",N0=".weights.bin";function Lh(n){return new Promise(e=>setTimeout(e)).then(n)}class us{constructor(e){if(!M().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(us.URL_SCHEME)&&(e=e.slice(us.URL_SCHEME.length)),(e==null||e.length===0)&&(e=v0),this.modelJsonFileName=e+C0,this.weightDataFileName=e+N0}async save(e){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=Ih(e,s),a=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=a,await Lh(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const i=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;i.download=this.weightDataFileName,i.href=t,await Lh(()=>i.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Ra(e)}}}}us.URL_SCHEME="downloads://";class k0{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const s=new FileReader;s.onload=r=>{const a=JSON.parse(r.target.result),o=a.modelTopology;if(o==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(a.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:o});return}const c=gu(a,l=>this.loadWeights(l));e(c)},s.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(e){const t=[],s=[];for(const o of e)t.push(...o.weights),s.push(...o.paths);const r=this.checkManifestAndWeightFiles(e),a=s.map(o=>this.loadWeightsFile(o,r[o]));return Promise.all(a).then(o=>[t,mu(o)])}loadWeightsFile(e,t){return new Promise((s,r)=>{const a=new FileReader;a.onload=o=>{const i=o.target.result;s(i)},a.onerror=o=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],s=this.weightsFiles.map(a=>kh(a.name)),r={};for(const a of e)a.paths.forEach(o=>{const i=kh(o);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),s.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);r[o]=this.weightsFiles[s.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const I0=n=>M().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(us.URL_SCHEME)?S0(n.slice(us.URL_SCHEME.length)):null;Le.registerSaveRouter(I0);function S0(n="model"){return new us(n)}function T0(n){return new k0(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bh(n,e,t,s){o(n),t=t==null?0:t,s=s==null?1:s,i(t,s);let r=0;const a=c=>(c.then(l=>{const u=t+ ++r/n.length*(s-t);return e(u),l}),c);function o(c){C(c!=null&&Array.isArray(c)&&c.length>0,()=>"promises must be a none empty array")}function i(c,l){C(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${c}`),C(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),C(l>=c,()=>`startFraction must be no more than endFraction, but got startFraction ${c} and endFraction ${l}`)}return Promise.all(n.map(a))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Vh(n,e){e==null&&(e={});const t=e.fetchFunc==null?M().platform.fetch:e.fetchFunc,s=n.map(d=>t(d,e.requestInit,{isBinary:!0})),r=0,a=.5,i=(e.onProgress==null?await Promise.all(s):await Bh(s,e.onProgress,r,a)).map(d=>d.arrayBuffer()),c=.5,l=1;return e.onProgress==null?await Promise.all(i):await Bh(i,e.onProgress,c,l)}async function E0(n,e="",t,s){return Mh(o=>Vh(o,{requestInit:s}))(n,e,t)}function Mh(n){return async(e,t="",s)=>{const r=e.map(()=>!1),a={},o=s!=null?s.map(()=>!1):[],i=[];if(e.forEach((h,f)=>{let m=0;h.weights.forEach(g=>{const y="quantization"in g?g.quantization.dtype:g.dtype,x=pu[y]*B(g.shape),w=()=>{r[f]=!0,a[f]==null&&(a[f]=[]),a[f].push({manifestEntry:g,groupOffset:m,sizeBytes:x})};s!=null?s.forEach(($,v)=>{$===g.name&&(w(),o[v]=!0)}):w(),i.push(g.name),m+=x})}),!o.every(h=>h)){const h=s.filter((f,m)=>!o[m]);throw new Error(`Could not find weights in manifest with names: ${h.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}const c=r.reduce((h,f,m)=>(f&&h.push(m),h),[]),l=[];c.forEach(h=>{e[h].paths.forEach(f=>{const m=t+(t.endsWith("/")?"":"/")+f;l.push(m)})});const u=await n(l),d={};let p=0;return c.forEach(h=>{const f=e[h].paths.length;let m=0;for(let $=0;$<f;$++)m+=u[p+$].byteLength;const g=new ArrayBuffer(m),y=new Uint8Array(g);let x=0;for(let $=0;$<f;$++){const v=new Uint8Array(u[p+$]);y.set(v,x),x+=v.byteLength}a[h].forEach($=>{const v=g.slice($.groupOffset,$.groupOffset+$.sizeBytes),k=hu(v,[$.manifestEntry]);for(const I in k)d[I]=k[I]}),p+=f}),d}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R0="application/octet-stream",_0="application/json";class $u{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(C(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=M().platform.fetch,C(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&C(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=Ih(e,s);t.body.append("model.json",new Blob([JSON.stringify(r)],{type:_0}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:R0}),"model.weights.bin");const a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:Ra(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const s=t.modelTopology,r=t.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return gu(t,a=>this.loadWeights(a))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=A0(t),a=this.weightPathPrefix||s,o=[];for(const u of e)o.push(...u.weights);const i=[],c=[];for(const u of e)for(const d of u.paths)this.weightUrlConverter!=null?c.push(this.weightUrlConverter(d)):i.push(a+d+r);this.weightUrlConverter&&i.push(...await Promise.all(c));const l=await Vh(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[o,mu(l)]}}$u.URL_SCHEME_REGEX=/^https?:\/\//;function A0(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),s=n.substring(0,e),r=t>e?n.substring(t):"";return[s+"/",r]}function vu(n){return n.match($u.URL_SCHEME_REGEX)!=null}const Wh=(n,e)=>{if(typeof fetch=="undefined"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(s=>vu(s)):t=vu(n),t)return Cu(n,e)}return null};Le.registerSaveRouter(Wh);Le.registerLoadRouter(Wh);function Cu(n,e){return new $u(n,e)}function Nu(n,e){return Cu(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ku{constructor(e){this.modelArtifacts=e}async load(){return this.modelArtifacts}}class D0{constructor(e){this.saveHandler=e}async save(e){return this.saveHandler(e)}}function F0(n,e,t,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new ku(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ku({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ku({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:s}))}function O0(n){return new D0(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var P0=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",browserFiles:T0,browserHTTPRequest:Nu,concatenateArrayBuffers:mu,decodeWeights:hu,encodeWeights:Hb,fromMemory:F0,getLoadHandlers:Th,getModelArtifactsForJSON:gu,getModelArtifactsInfoForJSON:Ra,getSaveHandlers:Sh,http:Cu,isHTTPScheme:vu,loadWeights:E0,registerLoadRouter:e0,registerSaveRouter:Jb,weightsLoaderFactory:Mh,withSaveHandler:O0,copyModel:f0,listModels:p0,moveModel:m0,removeModel:h0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L0(n,e,t=!1,s=!1){let r=N(n,"a","matMul"),a=N(e,"b","matMul");[r,a]=Pe(r,a);const o={a:r,b:a},i={transposeA:t,transposeB:s};return E.runKernel(Eo,o,i)}const xe=T({matMul_:L0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B0(n,e,t=1,s=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const a={indices:N(n,"indices","oneHot","int32")},o={depth:e,onValue:t,offValue:s};return E.runKernel(vi,a,o)}const hc=T({oneHot_:B0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V0(n,e){const t=N(n,"x","transpose");if(e==null&&(e=t.shape.map((a,o)=>o).reverse()),C(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of perm ${e}.`),e.forEach(a=>{C(a>=0&&a<t.rank,()=>`All entries in 'perm' must be between 0 and ${t.rank-1} but got ${e}`)}),t.rank<=1)return t.clone();const s={x:t},r={perm:e};return E.runKernel(Qi,s,r)}const _a=T({transpose_:V0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M0(n,e,t){const s=N(n,"labels","confusionMatrix"),r=N(e,"predictions","confusionMatrix");C(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),C(s.rank===1,()=>`Expected the rank of labels to be 1, but got ${s.rank}`),C(r.rank===1,()=>`Expected the rank of predictions to be 1, but got ${r.rank}`),C(s.shape[0]===r.shape[0],()=>`Mismatch in the number of examples: ${s.shape[0]} vs. ${r.shape[0]}. Labels and predictions should have the same number of elements.`),C(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);const a=hc(ve(s,"int32"),t),o=hc(ve(r,"int32"),t),i=_a(a),c=xe(i,o);return ve(c,"int32")}const W0=T({confusionMatrix_:M0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var z0=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",confusionMatrix:W0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zh(n,e,t){if(Jn(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=Yt(n,t);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Rn(n,e,s,t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ds;function Uh(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,s=!1,r=!1,a=!1,o=!1,i=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData!="undefined"&&n instanceof ImageData)s=!0;else if(typeof HTMLVideoElement!="undefined"&&n instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement!="undefined"&&n instanceof HTMLImageElement)a=!0;else if(n.getContext!=null)o=!0;else if(typeof ImageBitmap!="undefined"&&n instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(r){const f=2;if(r&&n.readyState<f)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(rc(nc,E.backendName)!=null){const f={pixels:n},m={numChannels:e};return E.runKernel(nc,f,m)}const[l,u]=r?[n.videoWidth,n.videoHeight]:[n.width,n.height];let d;if(o)d=n.getContext("2d").getImageData(0,0,l,u).data;else if(s||t)d=n.data;else if(a||r||i){if(ds==null)if(typeof document=="undefined")if(typeof OffscreenCanvas!="undefined"&&typeof OffscreenCanvasRenderingContext2D!="undefined")ds=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else ds=document.createElement("canvas").getContext("2d");ds.canvas.width=l,ds.canvas.height=u,ds.drawImage(n,0,0,l,u),d=ds.getImageData(0,0,l,u).data}let p;if(e===4)p=new Int32Array(d);else{const f=l*u;p=new Int32Array(f*e);for(let m=0;m<f;m++)for(let g=0;g<e;++g)p[m*e+g]=d[m*4+g]}return zh(p,[u,l,e],"int32")}function U0(n){return n!=null&&n.data instanceof Uint8Array}function G0(){return typeof window!="undefined"&&typeof ImageBitmap!="undefined"&&window.hasOwnProperty("createImageBitmap")}function H0(n){return n!=null&&n.width!==0&&n.height!==0}function q0(n){return G0()&&!(n instanceof ImageBitmap)&&H0(n)&&!U0(n)}async function j0(n,e=3){let t=null;if(M().getBool("WRAP_TO_IMAGEBITMAP")&&q0(n)){let s;try{s=await createImageBitmap(n,{premultiplyAlpha:"none"})}catch{s=null}s!=null&&s.width===n.width&&s.height===n.height?t=s:t=n}else t=n;return Uh(t,e)}async function K0(n,e){let t=N(n,"img","toPixels");if(!(n instanceof Ve)){const l=t;t=ve(l,"int32"),l.dispose()}if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);const[s,r]=t.shape.slice(0,2),a=t.rank===2?1:t.shape[2];if(a>4||a===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${a}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`);const o=await t.data(),i=t.dtype==="float32"?255:1,c=new Uint8ClampedArray(r*s*4);for(let l=0;l<s*r;++l){const u=[0,0,0,255];for(let p=0;p<a;p++){const h=o[l*a+p];if(t.dtype==="float32"){if(h<0||h>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${h}.`)}else if(t.dtype==="int32"&&(h<0||h>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${h}.`);a===1?(u[0]=h*i,u[1]=h*i,u[2]=h*i):u[p]=h*i}const d=l*4;c[d+0]=Math.round(u[0]),c[d+1]=Math.round(u[1]),c[d+2]=Math.round(u[2]),c[d+3]=Math.round(u[3])}if(e!=null){e.width=r,e.height=s;const l=e.getContext("2d"),u=new ImageData(c,r,s);l.putImageData(u,0,0)}return t!==n&&t.dispose(),c}const X0=T({fromPixels_:Uh});var Y0=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",fromPixelsAsync:j0,toPixels:K0,fromPixels:X0});function fc(n,e){const t=n.shape.length,s=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${t}`);if(B(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=e.shape,a=r[r.length-1];let o=1;for(let d=0;d<r.length-1;++d)o*=r[d];const i=n.shape,c=r.slice();c.pop();let l=1;for(let d=a;d<t;++d)l*=i[d],c.push(i[d]);const u=[...se(n.shape).map(d=>d/l),1].slice(0,a);return[c,o,l,u]}var Q0=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",prepareAndValidate:fc});function Iu(n,e,t){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,a=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(t.rank<r)throw new Error(a+` update.rank < ${r}. `);if(n.length<s+(t.rank-r))throw new Error(a+` Output shape length < ${s+(t.rank-r)}`);if(t.rank!==r+n.length-s)throw new Error(a+` update.rank != ${r+n.length-s}`);for(let o=0;o<r;++o)if(t.shape[o]!==e.shape[o])throw new Error(a+` updates.shape[${o}] (${t.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<t.rank-r;++o)if(t.shape[o+r]!==n[o+s])throw new Error(a+` updates.shape[${o+r}] (${t.shape[o+r]}) != shape[${o+r}] (${n[o+r]})`)}function Su(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}Iu(t,e,n)}function Vs(n,e,t){const s=e.shape.length,r=s>1?e.shape[s-1]:1,a=t.length;let o=1;for(let d=r;d<a;++d)o*=t[d];const i=r<1?1:r,c=B(e.shape)/i,l=[...se(t.slice(0,r)),1],u=B(t);return{sliceRank:r,numUpdates:c,sliceSize:o,strides:l,outputSize:u}}var Z0=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",validateUpdateShape:Iu,validateInput:Su,calculateShapes:Vs});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tu=-2,J0=-1;function Eu(n,e,t){const s=n.shape.length;C(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),C(s===t.length,()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)C(e[r]+t[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+t[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function e1(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function Ru(n,e,t){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((e[r]-n[r])/t[r]);return s}function Gh(n,e,t,s){const r=[...n];for(let a=r.length;a<s.length;a++)r.push(1);for(let a=0;a<t;a++)a===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function Hh(n,e,t){return t<=n?t:t-(e-1)}function qh(n,e){const t=[];for(let s=0;s<n;s++)t.push(e+s);return t}function t1(n,e,t,s,r,a,o,i,c){const l=n.length;let u=new Array(l),d=new Array(l),p=new Array(l);if(e.length&&t>0){const h=e[0],f=t+1;u=jh(o,h,f,s,n),d=Kh(i,h,f,r,n),p=Gh(a,h,f,n)}else for(let h=0;h<l;h++)u[h]=Yh(o,s,a,n,h,c),d[h]=Qh(i,r,a,n,h,c),p[h]=Xh(a,h,c);return{begin:u,end:d,strides:p}}function jh(n,e,t,s,r){const a=[...r],o=qh(t,e);for(let i=0;i<a.length;i++)if(o.indexOf(i)>-1)a[i]=0;else{const c=Hh(e,t,i);let l=s[c];n&1<<c&&(l=0),a[i]=l}return a}function Kh(n,e,t,s,r){const a=[...r],o=qh(t,e);for(let i=0;i<a.length;i++)if(o.indexOf(i)>-1)a[i]=Number.MAX_SAFE_INTEGER;else{const c=Hh(e,t,i);let l=s[c];n&1<<c&&(l=Number.MAX_SAFE_INTEGER),a[i]=l}for(let i=0;i<a.length;i++){const c=r[i];a[i]<0&&(a[i]+=c),a[i]=kn(0,a[i],r[i])}return a}function Xh(n,e,t){let s=n[e];return(t&1<<e||s==null)&&(s=1),s}function Yh(n,e,t,s,r,a){let o=e[r];const i=t[r]||1;(n&1<<r||a&1<<r||o==null)&&(i>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const c=s[r];return o<0&&(o+=c),o=kn(0,o,c-1),o}function Qh(n,e,t,s,r,a){let o=e[r];const i=t[r]||1;(n&1<<r||a&1<<r||o==null)&&(i>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const c=s[r];return o<0&&(o+=c),i>0?o=kn(0,o,c):o=kn(-1,o,c-1),o}function _u(n,e,t){let s=t.length;for(let r=0;r<t.length;r++)if(t[r]>1){s=r;break}for(let r=s+1;r<t.length;r++)if(e[r]>0||t[r]!==n[r])return!1;return!0}function Au(n,e){let t=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)t+=n[s]*e[s];return t}function Du(n,e,t){let s;const r=n.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(o=>{C(o!==-1,()=>"slice() does not support negative begin indexing.")});let a;return t==null?a=new Array(r).fill(-1):typeof t=="number"?a=[t,...new Array(r-1).fill(-1)]:t.length<r?a=t.concat(new Array(r-t.length).fill(-1)):a=t,a=a.map((o,i)=>o>=0?o:(C(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${i}.`),n.shape[i]-s[i])),[s,a]}function Fu(n,e,t,s,r,a,o,i,c){let l;if(s==null?(l=new Array(e.length),l.fill(1)):l=s,o!=null&&(o&o-1)!=0)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const d={dims:l.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:l.slice(),beginMask:r,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:c};for(let w=0;w<d.dims;w++)u&&(1<<w&i)!=0&&d.numAddAxisAfterEllipsis++,1<<w&o&&(u=!0);u||(d.ellipsisMask|=1<<d.dims,d.dims++);const p={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};n1(d,p);let h=!0,f=!0,m=!0;const g=[],y=[];for(let w=0;w<n.length;++w){if(p.strides[w]===0)throw Error(`strides[${w}] must be non-zero`);const $=!!(p.shrinkAxisMask&1<<w),v=n[w];if(v===-1){g.push($?1:-1);continue}const k=[p.beginMask&1<<w,p.endMask&1<<w],I=[p.strides[w]>0?0:-1,p.strides[w]>0?v:v-1];if($&&p.strides[w]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&p.strides[w]===1;const S=!!(p.beginMask&1<<w&&p.endMask&1<<w);if(p.beginValid&&p.endValid){if($){const D=p.begin[w]<0?v+p.begin[w]:p.begin[w];if(p.begin[w]=D,p.end[w]=p.begin[w]+1,D<0||D>=v)throw Error(`slice index ${p.begin[w]} of dimension ${w} out of bounds.`)}else p.begin[w]=Zh(p.begin[w],0,p.strides[w],v,k,I),p.end[w]=Zh(p.end[w],1,p.strides[w],v,k,I);const _=p.strides[w]===1&&p.begin[w]===0&&p.end[w]===v;h=h&&_,f=f&&(w===0&&p.strides[w]===1||_)}else h=h&&p.strides[w]===1&&S,f=f&&(w===0&&p.strides[w]===1||S);let A,R=!1;if(p.beginValid&&p.endValid?(A=p.end[w]-p.begin[w],R=!0):$?(A=1,R=!0):S&&v>=0&&(p.strides[w]<0?A=-v:A=v,R=!0),R){let _;A===0||A<0!=p.strides[w]<0?_=0:_=Math.trunc(A/p.strides[w])+(A%p.strides[w]!=0?1:0),g.push(_)}else g.push(-1)}for(let w=0;w<p.finalShapeGatherIndices.length;++w){const $=p.finalShapeGatherIndices[w];$>=0?y.push(g[$]):$===Tu&&y.push(1)}return{finalShapeSparse:y.filter((w,$)=>p.finalShapeGatherIndices[$]!==Tu),finalShape:y,isIdentity:h,sliceDim0:f,isSimpleSlice:m,begin:p.begin,end:p.end,strides:p.strides}}function n1(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(e.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<r;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=s}else if(1<<s&n.newAxisMask)e.finalShapeGatherIndices.push(Tu),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[s]),n.end!=null&&(e.end[t]=n.end[s]),e.strides[t]=n.strides[s],n.beginMask&1<<s&&(e.beginMask|=1<<t),n.endMask&1<<s&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(J0),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[t]=s,t++}}function Zh(n,e,t,s,r,a){if(r[e])return t>0?a[e]:a[e+1&1];{const o=n<0?s+n:n;return o<a[0]?a[0]:o>a[1]?a[1]:o}}var Jh=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",assertParamsValid:Eu,maskToAxes:e1,computeOutShape:Ru,stridesWithElidedDims:Gh,getNormalizedAxes:t1,startIndicesWithElidedDims:jh,stopIndicesWithElidedDims:Kh,stridesForAxis:Xh,startForAxis:Yh,stopForAxis:Qh,isSliceContinous:_u,computeFlatOffset:Au,parseSliceParams:Du,sliceInfo:Fu});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ef{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class Dn{constructor(){this.classNameMap={}}static getMap(){return Dn.instance==null&&(Dn.instance=new Dn),Dn.instance}static register(e){Dn.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Fn(n){C(n.className!=null,()=>"Class being registered does not have the static className property defined."),C(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),C(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Dn.register(n)}var s1=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",Serializable:ef,SerializationMap:Dn,registerClass:Fn});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r1=.001,tf=.1;function a1(n,e,t){return t==null&&(t=Ou()),Pu(n,e,(s,r)=>Lu(s,r,t))}function Ou(){return E.backend.floatPrecision()===32?r1:tf}function Pu(n,e,t){let s=!0;if((nt(n)||nt(e))&&(s=!1),nt(n)&&nt(e)&&(s=!0),s){const o=n.constructor.name,i=e.constructor.name;if(o!==i)throw new Error(`Arrays are of different type. Actual: ${o}. Expected: ${i}`)}if(Array.isArray(n)&&Array.isArray(e)){const o=Yt(n),i=Yt(e);if(!$e(o,i))throw new Error(`Arrays have different shapes. Actual: [${o}]. Expected: [${i}]`)}const r=nt(n)?n:ln(n),a=nt(e)?e:ln(e);if(r.length!==a.length)throw new Error(`Arrays have different lengths actual: ${r.length} vs expected: ${a.length}.
Actual:   ${r}.
Expected: ${a}.`);for(let o=0;o<a.length;++o){const i=r[o],c=a[o];if(!t(i,c))throw new Error(`Arrays differ: actual[${o}] = ${i}, expected[${o}] = ${c}.
Actual:   ${r}.
Expected: ${a}.`)}}function o1(n,e){n().then(()=>e.fail(),()=>e())}function i1(n,e){const t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return jt(n)||jt(n[0])||jt(e)||jt(e[0])?Pu(n,t,(s,r)=>s==r):Pu(n,e,(s,r)=>Lu(s,r,0))}function c1(n,e,t){if(t==null&&(t=Ou()),!Lu(n,e,t))throw new Error(`Numbers differ: actual === ${n}, expected === ${e}`)}function Lu(n,e,t){return!isFinite(n)&&!isFinite(e)?!0:!(isNaN(n)||isNaN(e)||Math.abs(n-e)>t)}function l1(n,e,t){for(let s=0;s<n.length;s++)if(n[s]<e||n[s]>t)throw new Error(`Value out of range:${n[s]} low: ${e}, high: ${t}`)}function u1(n,e){expect(new Float32Array(n)).toEqual(new Float32Array(e))}function nf(n){for(let e=0;e<n.length;e++){const t=n[e];Array.isArray(t)?nf(t):n[e]=Kt(t)}return n}var d1=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",TEST_EPSILON_FLOAT16:tf,expectArraysClose:a1,testEpsilon:Ou,expectPromiseToFail:o1,expectArraysEqual:i1,expectNumbersClose:c1,expectValuesInRange:l1,expectArrayBuffersEqual:u1,encodeStrings:nf});/** @license See the LICENSE file. */const p1="3.11.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h1(){M().set("PROD",!0)}function f1(){M().set("DEBUG",!0)}function m1(){M().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function g1(n){M().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function y1(){E.disposeVariables()}function On(){return E}function x1(){return E.memory()}function b1(n){return E.profile(n)}function ce(n,e){return E.tidy(n,e)}function ft(n){iu(n).forEach(t=>t.dispose())}function Zt(n){return E.keep(n)}function w1(n){return E.time(n)}function $1(n){return E.setBackend(n)}function v1(){return E.ready()}function C1(){return E.backendName}function N1(n){E.removeBackend(n)}function k1(n){return E.findBackend(n)}function I1(n){return E.findBackendFactory(n)}function Bu(n,e,t=1){return E.registerBackend(n,e,t)}function S1(){return E.backend}function T1(n,e){M().setPlatform(n,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E1(n,e){let t=N(n,"a","add"),s=N(e,"b","add");[t,s]=Pe(t,s);const r={a:t,b:s};return E.runKernel(_s,r)}const ie=T({add_:E1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R1(n,e){let t=N(n,"a","floorDiv"),s=N(e,"b","floorDiv");[t,s]=Pe(t,s);const r={a:t,b:s};return E.runKernel(Pr,r)}const Vu=T({floorDiv_:R1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _1(n,e){let t=N(n,"a","div"),s=N(e,"b","div");if([t,s]=Pe(t,s),t.dtype==="int32"&&s.dtype==="int32")return Vu(t,s);const r={a:t,b:s},a={};return E.runKernel(Er,r,a)}const Te=T({div_:_1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A1(n,e){let t=N(n,"a","mul"),s=N(e,"b","mul");[t,s]=Pe(t,s);const r={a:t,b:s};return E.runKernel(Jr,r)}const Q=T({mul_:A1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D1(n){const e=N(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return E.runKernel(Fo,t)}else{const t={x:e};return E.runKernel($o,t)}}const wt=T({abs_:D1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F1(n){const t={x:N(n,"x","acos")};return E.runKernel(yr,t)}const sf=T({acos_:F1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O1(n){const t={x:N(n,"x","acosh")};return E.runKernel(xr,t)}const rf=T({acosh_:O1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P1(n){C(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),C(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((r,a)=>N(r,`tensors${a}`,"addN")),t=e[0];e.forEach(r=>{if(r.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(r=>{if(!$e(r.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return E.runKernel(vo,s)}const af=T({addN_:P1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L1(n,e=null,t=!1){const r={x:N(n,"x","all","bool")},a={axis:e,keepDims:t};return E.runKernel(Co,r,a)}const of=T({all_:L1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B1(n,e=null,t=!1){const r={x:N(n,"x","any","bool")},a={axis:e,keepDims:t};return E.runKernel(No,r,a)}const cf=T({any_:B1});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V1(n,e=0){const s={x:N(n,"x","argMax")},r={axis:e};return E.runKernel(ko,s,r)}const lf=T({argMax_:V1});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M1(n,e=0){const s={x:N(n,"x","argMin")},r={axis:e};return E.runKernel(Io,s,r)}const uf=T({argMin_:M1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W1(n){const t={x:N(n,"x","asin")};return E.runKernel(br,t)}const df=T({asin_:W1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z1(n){const t={x:N(n,"x","asinh")};return E.runKernel(wr,t)}const pf=T({asinh_:z1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U1(n){const t={x:N(n,"x","atan")};return E.runKernel($r,t)}const hf=T({atan_:U1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G1(n,e){let t=N(n,"a","atan2"),s=N(e,"b","atan2");[t,s]=Pe(t,s);const r={a:t,b:s};return E.runKernel(Cr,r)}const ff=T({atan2_:G1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H1(n){const t={x:N(n,"x","atanh")};return E.runKernel(vr,t)}const mf=T({atanh_:H1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aa(n,e,t,s,r="NHWC",a){const o=n[3],i=[...e,o],c=fn(r);return je(n,i,t,a,s,null,null,c)}function Pt(n,e,t,s,r,a,o="channelsLast"){const[i,c]=mc(e);let l;if(o==="channelsLast")l=[i,c,n[3],n[3]];else if(o==="channelsFirst")l=[i,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return je(n,l,t,s,r,a,!1,o)}function hn(n,e,t,s,r,a,o="NDHWC"){const[i,c,l]=Wu(e);let u,d;if(o==="NDHWC")d="channelsLast",u=[i,c,l,n[4],n[4]];else if(o==="NCDHW")d="channelsFirst",u=[i,c,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return Pn(n,u,t,s,r,!1,d,a)}function je(n,e,t,s,r,a,o=!1,i="channelsLast"){let[c,l,u,d]=[-1,-1,-1,-1];if(i==="channelsLast")[c,l,u,d]=n;else if(i==="channelsFirst")[c,d,l,u]=n;else throw new Error(`Unknown dataFormat ${i}`);const[p,h,,f]=e,[m,g]=mc(t),[y,x]=mc(s),w=Ms(p,y),$=Ms(h,x),{padInfo:v,outHeight:k,outWidth:I}=K1(r,l,u,m,g,w,$,a,i),S=o?f*d:f;let A;return i==="channelsFirst"?A=[c,S,k,I]:i==="channelsLast"&&(A=[c,k,I,S]),{batchSize:c,dataFormat:i,inHeight:l,inWidth:u,inChannels:d,outHeight:k,outWidth:I,outChannels:S,padInfo:v,strideHeight:m,strideWidth:g,filterHeight:p,filterWidth:h,effectiveFilterHeight:w,effectiveFilterWidth:$,dilationHeight:y,dilationWidth:x,inShape:n,outShape:A,filterShape:e}}function Pn(n,e,t,s,r,a=!1,o="channelsLast",i){let[c,l,u,d,p]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[c,l,u,d,p]=n;else if(o==="channelsFirst")[c,p,l,u,d]=n;else throw new Error(`Unknown dataFormat ${o}`);const[h,f,m,,g]=e,[y,x,w]=Wu(t),[$,v,k]=Wu(s),I=Ms(h,$),S=Ms(f,v),A=Ms(m,k),{padInfo:R,outDepth:_,outHeight:D,outWidth:F}=X1(r,l,u,d,y,x,w,I,S,A,i),P=a?g*p:g;let L;return o==="channelsFirst"?L=[c,P,_,D,F]:o==="channelsLast"&&(L=[c,_,D,F,P]),{batchSize:c,dataFormat:o,inDepth:l,inHeight:u,inWidth:d,inChannels:p,outDepth:_,outHeight:D,outWidth:F,outChannels:P,padInfo:R,strideDepth:y,strideHeight:x,strideWidth:w,filterDepth:h,filterHeight:f,filterWidth:m,effectiveFilterDepth:I,effectiveFilterHeight:S,effectiveFilterWidth:A,dilationDepth:$,dilationHeight:v,dilationWidth:k,inShape:n,outShape:L,filterShape:e}}function q1(n,e,t,s,r){s==null&&(s=Mu(n,e,t));const a=n[0],o=n[1],i=ps((a-e+2*s)/t+1,r),c=ps((o-e+2*s)/t+1,r);return[i,c]}function j1(n,e,t,s,r,a){r==null&&(r=Mu(n,e,s));const o=n[0],i=n[1],c=n[2],l=ps((o-e+2*r)/s+1,a),u=ps((i-e+2*r)/s+1,a),d=ps((c-e+2*r)/s+1,a);return[l,u,d,t]}function Mu(n,e,t,s=1){const r=Ms(e,s);return Math.floor((n[0]*(t-1)-t+r)/2)}function mc(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function Wu(n){return typeof n=="number"?[n,n,n]:n}function Ms(n,e){return e<=1?n:n+(n-1)*(e-1)}function K1(n,e,t,s,r,a,o,i,c){let l,u,d;if(typeof n=="number"){l={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const h=q1([e,t],a,s,n,i);u=h[0],d=h[1]}else if(n==="same"){u=Math.ceil(e/s),d=Math.ceil(t/r);const p=Math.max(0,(u-1)*s+a-e),h=Math.max(0,(d-1)*r+o-t),f=Math.floor(p/2),m=p-f,g=Math.floor(h/2),y=h-g;l={top:f,bottom:m,left:g,right:y,type:"SAME"}}else if(n==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-a+1)/s),d=Math.ceil((t-o+1)/r);else if(typeof n=="object"){const p=c==="channelsLast"?n[1][0]:n[2][0],h=c==="channelsLast"?n[1][1]:n[2][1],f=c==="channelsLast"?n[2][0]:n[3][0],m=c==="channelsLast"?n[2][1]:n[3][1];l={top:p,bottom:h,left:f,right:m,type:p===0&&h===0&&f===0&&m===0?"VALID":"EXPLICIT"},u=ps((e-a+p+h)/s+1,i),d=ps((t-o+f+m)/r+1,i)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:l,outHeight:u,outWidth:d}}function X1(n,e,t,s,r,a,o,i,c,l,u){let d,p,h,f;if(typeof n=="number"){d={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const g=j1([e,t,s,1],i,1,r,n,u);p=g[0],h=g[1],f=g[2]}else if(n==="same"){p=Math.ceil(e/r),h=Math.ceil(t/a),f=Math.ceil(s/o);const m=(p-1)*r+i-e,g=(h-1)*a+c-t,y=(f-1)*o+l-s,x=Math.floor(m/2),w=m-x,$=Math.floor(g/2),v=g-$,k=Math.floor(y/2),I=y-k;d={top:$,bottom:v,left:k,right:I,front:x,back:w,type:"SAME"}}else if(n==="valid")d={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},p=Math.ceil((e-i+1)/r),h=Math.ceil((t-c+1)/a),f=Math.ceil((s-l+1)/o);else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:d,outDepth:p,outHeight:h,outWidth:f}}function ps(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function Da(n){const[e,t,s]=mc(n);return e===1&&t===1&&s===1}function st(n,e){return Da(n)||Da(e)}function fn(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y1(n,e){const s={x:N(n,"x","reshape","string_or_numeric")},r={shape:e};return E.runKernel(Ei,s,r)}const W=T({reshape_:Y1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q1(n,e,t,s,r){const a=N(n,"x","avgPool","float32"),o=1;C(st(t,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);let i=a,c=!1;a.rank===3&&(c=!0,i=W(a,[1,a.shape[0],a.shape[1],a.shape[2]])),C(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),r!=null&&C(at(s),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);const l={x:i},u={filterSize:e,strides:t,pad:s,dimRoundingMode:r};let d=E.runKernel(So,l,u);return d=ve(d,a.dtype),c?W(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const zu=T({avgPool_:Q1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z1(n,e,t,s,r,a="NDHWC"){const o=N(n,"x","avgPool3d","float32");let i=o,c=!1;o.rank===4&&(c=!0,i=W(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),C(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),C(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),r!=null&&C(at(s),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);const l={x:i},u={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:a};let d=E.runKernel(To,l,u);return d=ve(d,i.dtype),c?W(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const gf=T({avgPool3d_:Z1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J1(n,e=0){C(n.length>=1,()=>"Pass at least one tensor to concat");const t=Ea(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),t.length===1)return An(t[0]);const s=t,r={axis:e};return E.runKernel(Oo,s,r)}const rt=T({concat_:J1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ew(n){const t={x:N(n,"x","sigmoid","float32")};return E.runKernel(da,t)}const hs=T({sigmoid_:ew});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tw(n,e,t){const s=N(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},a={begin:e,size:t};return E.runKernel(Oi,r,a)}const Ce=T({slice_:tw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nw(n){const t={x:N(n,"x","tanh","float32")};return E.runKernel(ya,t)}const gc=T({tanh_:nw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sw(n,e,t,s,r,a){const o=N(n,"forgetBias","basicLSTMCell"),i=N(e,"lstmKernel","basicLSTMCell"),c=N(t,"lstmBias","basicLSTMCell"),l=N(s,"data","basicLSTMCell"),u=N(r,"c","basicLSTMCell"),d=N(a,"h","basicLSTMCell"),p=rt([l,d],1),h=xe(p,i),f=ie(h,c),m=f.shape[0],g=f.shape[1]/4,y=[m,g],x=Ce(f,[0,0],y),w=Ce(f,[0,g],y),$=Ce(f,[0,g*2],y),v=Ce(f,[0,g*3],y),k=ie(Q(hs(x),gc(w)),Q(u,hs(ie(o,$)))),I=Q(gc(k),hs(v));return[k,I]}const rw=T({basicLSTMCell_:sw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aw(n,e,t){const s=N(n,"x","batchToSpaceND"),r=e.reduce((i,c)=>i*c);C(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),C(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),C(s.shape[0]%r==0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const a={x:s},o={blockShape:e,crops:t};return E.runKernel(Ro,a,o)}const Uu=T({batchToSpaceND_:aw});function ow(n){let e;return n.rank===0||n.rank===1?e=W(n,[1,1,1,n.size]):n.rank===2?e=W(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=W(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iw(n,e,t,s,r,a){a==null&&(a=.001);const o=N(n,"x","batchNorm"),i=N(e,"mean","batchNorm"),c=N(t,"variance","batchNorm");let l;r!=null&&(l=N(r,"scale","batchNorm"));let u;s!=null&&(u=N(s,"offset","batchNorm")),C(i.rank===c.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),C(u==null||i.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),C(l==null||i.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const p={x:ow(o),scale:l,offset:u,mean:i,variance:c},h={varianceEpsilon:a},f=E.runKernel(ti,p,h);return W(f,o.shape)}const Ws=T({batchNorm_:iw});function cw(n,e,t,s,r,a){const o=N(n,"x","batchNorm"),i=N(e,"mean","batchNorm"),c=N(t,"variance","batchNorm");let l;r!=null&&(l=N(r,"scale","batchNorm"));let u;return s!=null&&(u=N(s,"offset","batchNorm")),C(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),C(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),C(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${c.rank}.`),l!=null&&C(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&C(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),Ws(o,i,c,u,l,a)}const lw=T({batchNorm2d_:cw});function uw(n,e,t,s,r,a){const o=N(n,"x","batchNorm"),i=N(e,"mean","batchNorm"),c=N(t,"variance","batchNorm");let l;r!=null&&(l=N(r,"scale","batchNorm"));let u;return s!=null&&(u=N(s,"offset","batchNorm")),C(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),C(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),C(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${c.rank}.`),l!=null&&C(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&C(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),Ws(o,i,c,u,l,a)}const dw=T({batchNorm3d_:uw});function pw(n,e,t,s,r,a){const o=N(n,"x","batchNorm"),i=N(e,"mean","batchNorm"),c=N(t,"variance","batchNorm");let l;r!=null&&(l=N(r,"scale","batchNorm"));let u;return s!=null&&(u=N(s,"offset","batchNorm")),C(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),C(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),C(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${c.rank}.`),l!=null&&C(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&C(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),Ws(o,i,c,u,l,a)}const hw=T({batchNorm4d_:pw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fw(n,e,t){const s=N(n,"x","bincount"),r=N(e,"weights","bincount");C(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),C(t>=0,()=>`size must be non-negative, but got ${t}.`),C(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const a={x:s,weights:r},o={size:t};return E.runKernel(_o,a,o)}const Gu=T({bincount_:fw});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mw(n,e){const t=N(n,"s0","broadcastArgs","int32"),s=N(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:t,s1:s};return E.runKernel(Ao,r)}const yf=T({broadcastArgs_:mw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gw(n,e){let t=N(n,"broadcastTo","x");const s=t.shape;if(e.some(l=>!(l>0)||l%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const l=t.shape.slice();for(;l.length<e.length;)l.unshift(1);t=W(t,l)}const r=t.shape,a=Array.from(e);for(let l=e.length-1;l>=0;l--)if(r[l]===e[l])a[l]=1;else if(t.shape[l]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(a.map((l,u)=>l>1?u:-1).filter(l=>l>=0).length===0)return An(t);const i={x:t},c={reps:a};return E.runKernel(xa,i,c)}const Fa=T({broadcastTo_:gw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yw(n){const t={x:N(n,"x","ceil","float32")};return E.runKernel(kr,t)}const xf=T({ceil_:yw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xw(n,e,t){const s=N(n,"x","clipByValue");C(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`);const r={x:s},a={clipValueMin:e,clipValueMax:t};return E.runKernel(Ir,r,a)}const bf=T({clipByValue_:xw});function bw(n){return rt(n,0)}const ww=T({concat1d_:bw});function $w(n,e){return rt(n,e)}const vw=T({concat2d_:$w});function Cw(n,e){return rt(n,e)}const Nw=T({concat3d_:Cw});function kw(n,e){return rt(n,e)}const Iw=T({concat4d_:kw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sw(n,e,t,s,r="NHWC",a=[1,1],o){const i=N(n,"x","conv2d","float32"),c=N(e,"filter","conv2d","float32");let l=i,u=!1;i.rank===3&&(u=!0,l=W(i,[1,i.shape[0],i.shape[1],i.shape[2]])),C(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),C(c.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${c.rank}.`),o!=null&&C(at(s),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`);const d=r==="NHWC"?l.shape[3]:l.shape[1];C(d===c.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${c.shape[2]}.`),C(st(t,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);const p={x:l,filter:c},h={strides:t,pad:s,dataFormat:r,dilations:a,dimRoundingMode:o},f=E.runKernel(Po,p,h);return u?W(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Oa=T({conv2d_:Sw});function Tw(n,e,t,s,r="NWC",a=1,o){const i=N(n,"x","conv1d"),c=N(e,"filter","conv1d");let l=i,u=!1;i.rank===2&&(u=!0,l=W(i,[1,i.shape[0],i.shape[1]])),C(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),C(c.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${c.rank}.`),o!=null&&C(at(s),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`),C(l.shape[2]===c.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${c.shape[1]}.`),C(st(t,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${a}'`),C(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const d=W(c,[1,c.shape[0],c.shape[1],c.shape[2]]),p=W(l,[l.shape[0],1,l.shape[1],l.shape[2]]),g=Oa(p,d,[1,t],s,"NHWC",[1,a],o);return u?W(g,[g.shape[2],g.shape[3]]):W(g,[g.shape[0],g.shape[2],g.shape[3]])}const wf=T({conv1d_:Tw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ew(n,e,t,s,r,a="NHWC",o){C(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let i=n,c=e,l=!1;e.rank===3&&(l=!0,c=W(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,n[0],n[1],n[2]]),C(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),C(c.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${c.rank}`),C(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const u=a==="NHWC"?i[3]:i[1],d=a==="NHWC"?c.shape[3]:c.shape[1];C(u===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[2]}.`),C(d===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${t.shape[3]}.`),o!=null&&C(at(r),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`);const p={dy:c,filter:t},h={strides:s,pad:r,dataFormat:a,dimRoundingMode:o,inputShape:i},f=E.runKernel(Bo,p,h);return l?W(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const $f=T({conv2DBackpropInput_:Ew});function Rw(n,e,t,s,r,a){const o=N(n,"x","conv2dTranspose"),i=N(e,"filter","conv2dTranspose");return $f(t,o,i,s,r,"NHWC",a)}const vf=T({conv2dTranspose_:Rw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _w(n,e,t,s,r="NDHWC",a=[1,1,1]){const o=N(n,"x","conv3d"),i=N(e,"filter","conv3d");let c=o,l=!1;o.rank===4&&(l=!0,c=W(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),C(c.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${c.rank}.`),C(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),C(c.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${c.shape[4]}) must match input depth for filter ${i.shape[3]}.`),C(st(t,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),C(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`);const u={x:c,filter:i},d={strides:t,pad:s,dataFormat:r,dilations:a},p=E.runKernel(Vo,u,d);return l?W(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const Cf=T({conv3d_:_w});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aw(n,e,t,s,r){C(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,o=e,i=!1;e.rank===4&&(i=!0,o=W(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),a=[1,n[0],n[1],n[2],n[3]]);const c=a[4],l=o.shape[4];C(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),C(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),C(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),C(c===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[3]}.`),C(l===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${t.shape[4]}.`);const u={dy:o,filter:t},d={pad:r,strides:s,inputShape:a},p=E.runKernel(Mo,u,d);return i?W(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const Dw=T({conv3DBackpropInput_:Aw});function Fw(n,e,t,s,r){const a=N(n,"x","conv3dTranspose"),o=N(e,"filter","conv3dTranspose");return Dw(t,a,o,s,r)}const Ow=T({conv3dTranspose_:Fw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pw(n){const t={x:N(n,"x","cos","float32")};return E.runKernel(Sr,t)}const Nf=T({cos_:Pw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lw(n){const t={x:N(n,"x","cosh","float32")};return E.runKernel(Tr,t)}const kf=T({cosh_:Lw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bw(n,e=0,t=!1,s=!1){const a={x:N(n,"x","cumsum")},o={axis:e,exclusive:t,reverse:s};return E.runKernel(Wo,a,o)}const If=T({cumsum_:Bw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vw(n,e,t,s=!1){const r=N(n,"x","denseBincount"),a=N(e,"weights","denseBincount");C(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),C(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),C(t>=0,()=>`size must be non-negative, but got ${t}.`),C(a.size===r.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${a.shape}.`);const o={x:r,weights:a},i={size:t,binaryOutput:s};return E.runKernel(Uo,o,i)}const Sf=T({denseBincount_:Vw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mw(n,e,t="NHWC"){const s=N(n,"x","depthToSpace","float32"),r=t==="NHWC"?s.shape[1]:s.shape[2],a=t==="NHWC"?s.shape[2]:s.shape[3],o=t==="NHWC"?s.shape[3]:s.shape[1];C(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),C(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${s.shape}`),C(a*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${e} for depthToSpace with input shape
        ${s.shape}`),C(o%(e*e)==0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${s.shape}`);const i={x:s},c={blockSize:e,dataFormat:t};return E.runKernel(Go,i,c)}const Tf=T({depthToSpace_:Mw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ww(n,e,t,s,r="NHWC",a=[1,1],o){const i=N(n,"x","depthwiseConv2d","float32"),c=N(e,"filter","depthwiseConv2d","float32");let l=i,u=!1;i.rank===3&&(u=!0,l=W(i,[1,i.shape[0],i.shape[1],i.shape[2]])),C(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),C(c.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${c.rank}.`),C(l.shape[3]===c.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),o!=null&&C(at(s),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`);const d={x:l,filter:c},p={strides:t,pad:s,dataFormat:r,dilations:a,dimRoundingMode:o},h=E.runKernel(Ho,d,p);return u?W(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const yc=T({depthwiseConv2d_:Ww});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zw(n){const t={x:N(n,"x","diag")};return E.runKernel(Ko,t)}const Uw=T({diag_:zw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gw(n,e,t,s,r=[1,1],a="NHWC"){const o=N(n,"x","dilation2d"),i=N(e,"filter","dilation2d");C(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),C(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),C(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let c=o,l=!1;o.rank===3&&(c=W(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=!0);const u={x:c,filter:i},d={strides:t,pad:s,dilations:r},p=E.runKernel(Xo,u,d);return l?W(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Ef=T({dilation2d_:Gw});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zs(n,e){const t=n.length,s=[];for(let r=0;r<t;r++){const a=t-1-r,o=n[a]||1;(e[e.length-1-r]||1)>1&&o===1&&s.unshift(a)}return s}function Rf(n,e){const t=[];for(let s=0;s<e.length;s++){const r=n[n.length-s-1],a=e.length-s-1,o=e[a];(r==null||r===1&&o>1)&&t.unshift(a)}return t}function ye(n,e){const t=[],s=Math.max(n.length,e.length);for(let r=0;r<s;r++){let a=n[n.length-r-1];a==null&&(a=1);let o=e[e.length-r-1];if(o==null&&(o=1),a===1)t.unshift(o);else if(o===1)t.unshift(a);else if(a!==o){const i=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(i)}else t.unshift(a)}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hw(n,e){let t=N(n,"a","equal","string_or_numeric"),s=N(e,"b","equal","string_or_numeric");[t,s]=Pe(t,s),ye(t.shape,s.shape);const r={a:t,b:s};return E.runKernel(Ar,r)}const Hu=T({equal_:Hw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qw(n,e,t){const s=N(e,"a","where"),r=N(t,"b","where"),a=N(n,"condition","where","bool"),o=ye(ye(a.shape,s.shape),r.shape),i=Fa(a,o),c=Fa(s,o),l=Fa(r,o),u={condition:i,t:c,e:l};return E.runKernel(Fi,u)}const fs=T({where_:qw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jw(n){const t={x:N(n,"x","zerosLike")};return E.runKernel(tc,t)}const $t=T({zerosLike_:jw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kw(n,e){let t=N(n,"a","div"),s=N(e,"b","div");[t,s]=Pe(t,s);const r=Te(t,s),a=$t(r),o=Hu(s,a);return fs(o,a,r)}const _f=T({divNoNan_:Kw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xw(n,e){const t=N(n,"t1","dot"),s=N(e,"t2","dot");C((t.rank===1||t.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${s.rank}.`);const r=t.rank===1?t.size:t.shape[1],a=s.rank===1?s.size:s.shape[0];if(C(r===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${a}.`),t.rank===1&&s.rank===1){const o=W(t,[1,-1]),i=W(s,[-1,1]),c=xe(o,i);return W(c,[])}else if(t.rank===1&&s.rank===2){const o=W(t,[1,-1]),i=W(s,[s.shape[0],s.shape[1]]),c=xe(o,i);return W(c,[c.size])}else if(t.rank===2&&s.rank===1){const o=W(s,[-1,1]),i=xe(t,o);return W(i,[i.size])}else{const o=W(s,[s.shape[0],s.shape[1]]);return xe(t,o)}}const Yw=T({dot_:Xw});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qw(n,...e){const t=e.map((r,a)=>N(r,`tensors${a}`,"einsum")),s={equation:n};return E.runKernel(Yo,t,s)}const Af=T({einsum_:Qw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zw(n){const t={x:N(n,"x","elu","float32")};return E.runKernel(Rr,t)}const qu=T({elu_:Zw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jw(n){let e=N(n,"x","erf");C(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=ve(e,"float32"));const t={x:e};return E.runKernel(_r,t)}const Df=T({erf_:Jw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e$(n){const t={x:N(n,"x","exp")};return E.runKernel(Dr,t)}const Ln=T({exp_:e$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t$(n,e=0){const t=N(n,"x","expandDims","string_or_numeric");C(e<=t.rank,()=>"Axis must be <= rank of the tensor");const s={input:t},r={dim:e};return E.runKernel(Qo,s,r)}const Bn=T({expandDims_:t$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n$(n){const t={x:N(n,"x","expm1")};return E.runKernel(Fr,t)}const Ff=T({expm1_:n$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s$(n,e){const t=N(n,"x","tile","string_or_numeric");C(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const s={x:t},r={reps:e};return E.runKernel(xa,s,r)}const Us=T({tile_:s$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r$(n,e,t,s="float32"){e==null&&(e=n);const r=ue([n,e],s),a=n<=e?n:e;for(let i=0;i<a;++i)r.set(1,i,i);const o=W(r.toTensor(),[n,e]);if(t==null)return o;if(t.length===1)return Us(Bn(o,0),[t[0],1,1]);if(t.length===2)return Us(Bn(Bn(o,0),0),[t[0],t[1],1,1]);if(t.length===3)return Us(Bn(Bn(Bn(o,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const Of=T({eye_:r$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pa(n,e,t){const s={shape:n,value:e,dtype:t};return E.runKernel(Jo,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a$(n){const t={x:N(n,"x","floor","float32")};return E.runKernel(Or,t)}const ju=T({floor_:a$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o$(n,e,t=0,s=0){const r=N(n,"x","gather"),a=N(e,"indices","gather","int32"),o={x:r,indices:a},i={axis:t,batchDims:s};return E.runKernel(ni,o,i)}const xc=T({gather_:o$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i$(n,e){let t=N(n,"a","greater","string_or_numeric"),s=N(e,"b","greater","string_or_numeric");[t,s]=Pe(t,s),ye(t.shape,s.shape);const r={a:t,b:s};return E.runKernel(Lr,r)}const La=T({greater_:i$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c$(n,e){let t=N(n,"a","greaterEqual","string_or_numeric"),s=N(e,"b","greaterEqual","string_or_numeric");[t,s]=Pe(t,s),ye(t.shape,s.shape);const r={a:t,b:s};return E.runKernel(Br,r)}const Ku=T({greaterEqual_:c$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l$(n){const t={input:N(n,"input","imag")};return E.runKernel(ai,t)}const bc=T({imag_:l$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u$(n){const t={x:N(n,"x","isFinite")};return E.runKernel(Mr,t)}const d$=T({isFinite_:u$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p$(n){const t={x:N(n,"x","isInf")};return E.runKernel(Wr,t)}const h$=T({isInf_:p$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f$(n){const t={x:N(n,"x","isNaN")};return E.runKernel(zr,t)}const Pf=T({isNaN_:f$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m$(n,e=.2){const s={x:N(n,"x","leakyRelu")},r={alpha:e};return E.runKernel(oi,s,r)}const Xu=T({leakyRelu_:m$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g$(n,e){let t=N(n,"a","less","string_or_numeric"),s=N(e,"b","less","string_or_numeric");[t,s]=Pe(t,s),ye(t.shape,s.shape);const r={a:t,b:s};return E.runKernel(Ur,r)}const Lf=T({less_:g$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y$(n,e){let t=N(n,"a","lessEqual","string_or_numeric"),s=N(e,"b","lessEqual","string_or_numeric");[t,s]=Pe(t,s),ye(t.shape,s.shape);const r={a:t,b:s};return E.runKernel(Gr,r)}const wc=T({lessEqual_:y$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bf(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const s={start:n,stop:e,num:t};return E.runKernel(ii,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x$(n,e=5,t=1,s=1,r=.5){const a=N(n,"x","localResponseNormalization");C(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),C(at(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=a,i=!1;a.rank===3&&(i=!0,o=W(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const c={x:o},l={depthRadius:e,bias:t,alpha:s,beta:r},u=E.runKernel(ci,c,l);return i?W(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const Vf=T({localResponseNormalization_:x$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b$(n){const t={x:N(n,"x","log","float32")};return E.runKernel(Hr,t)}const Gs=T({log_:b$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w$(n){const t={x:N(n,"x","log1p")};return E.runKernel(qr,t)}const Yu=T({log1p_:w$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $$(n){return C(In(n),()=>"The f passed in grad(f) must be a function"),(e,t)=>{const s=N(e,"x","tf.grad","string_or_numeric"),r=t!=null?N(t,"dy","tf.grad"):null;return E.tidy(()=>{const{value:a,grads:o}=E.gradients(()=>n(s),[s],r);return r!=null&&Ye(a.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),$c(o),o[0]})}}function v$(n){return C(In(n),()=>"The f passed in grads(f) must be a function"),(e,t)=>{C(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const s=Ea(e,"args","tf.grads","string_or_numeric"),r=t!=null?N(t,"dy","tf.grads"):null;return E.tidy(()=>{const{value:a,grads:o}=E.gradients(()=>n(...s),s,r);return r!=null&&Ye(a.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),$c(o),o})}}function C$(n){return C(In(n),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{C(e instanceof Ve,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),C(t==null||t instanceof Ve,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:s,value:r}=E.gradients(()=>n(e),[e],t);return $c(s),{grad:s[0],value:r}}}function N$(n){return C(In(n),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{C(Array.isArray(e)&&e.every(r=>r instanceof Ve),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),C(t==null||t instanceof Ve,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const s=E.gradients(()=>n(...e),e,t);return t!=null&&Ye(s.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),$c(s.grads),s}}function Mf(n,e){C(In(n),()=>"The f passed in variableGrads(f) must be a function"),C(e==null||Array.isArray(e)&&e.every(l=>l instanceof Ta),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const l in E.registeredVariables)e.push(E.registeredVariables[l])}const s=t?e.filter(l=>!l.trainable):null,r=e.length;e=e.filter(l=>l.trainable),C(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const a=!0,{value:o,grads:i}=E.gradients(n,e,null,a);C(i.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),C(o.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${o.rank} tensor`);const c={};return e.forEach((l,u)=>{i[u]!=null&&(c[l.name]=i[u])}),s!=null&&s.forEach(l=>c[l.name]=null),{value:o,grads:c}}function Jt(n){return E.customGrad(n)}function $c(n){if(n.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k$(n){const t={x:N(n,"x","neg")};return E.runKernel(yi,t)}const mn=T({neg_:k$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I$(n){const t={x:N(n,"x","softplus")};return E.runKernel(pa,t)}const Qu=T({softplus_:I$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S$(n){const e=N(n,"x","logSigmoid");return Jt(s=>({value:mn(Qu(mn(s))),gradFunc:o=>Q(o,hs(mn(s)))}))(e)}const T$=T({logSigmoid_:S$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E$(n,e=null,t=!1){const r={x:N(n,"x","max")},a={reductionIndices:e,keepDims:t};return E.runKernel(li,r,a)}const ms=T({max_:E$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R$(n,e){let t=N(n,"a","sub"),s=N(e,"b","sub");[t,s]=Pe(t,s);const r={a:t,b:s};return E.runKernel(ma,r)}const de=T({sub_:R$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _$(n,e=null,t=!1){let s=N(n,"x","sum");s.dtype==="bool"&&(s=ve(s,"int32"));const r={x:s},a={axis:e,keepDims:t};return E.runKernel(Pi,r,a)}const Ee=T({sum_:_$});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A$(n,e=-1){const t=N(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return Jt((r,a)=>{const o=!0,i=ms(r,e,!0),c=de(r,i),l=de(ve(c,"float32"),Gs(Ee(Ln(c),e,o)));return a([l]),{value:l,gradFunc:(d,p)=>{const[h]=p,f=!0,m=Ln(h);return de(d,Q(Ee(d,e,f),m))}}})(t)}const Wf=T({logSoftmax_:A$});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zu(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function zf(n,e,t){const s=n.length+e.length,r=[];let a=0,o=0;for(let i=0;i<s;i++)t.indexOf(i)===-1?r.push(n[a++]):r.push(e[o++]);return r}function Ze(n,e){const t=[],s=n.length;for(let a=0;a<s;a++)e.indexOf(a)===-1&&t.push(n[a]);const r=e.map(a=>n[a]);return[t,r]}function He(n,e){const t=e.map(s=>1);return zf(n,t,e)}function Je(n,e,t){C(Zu(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function Me(n,e){if(Zu(n,e))return null;const t=[];for(let s=0;s<e;++s)n.indexOf(s)===-1&&t.push(s);return n.forEach(s=>t.push(s)),t}function vc(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function We(n,e){const t=[];for(let s=e-n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D$(n,e=null,t=!1){const s=N(n,"x","logSumExp"),r=ge(e,s.shape),a=ms(s,r,!0),o=de(s,a),i=Ln(o),c=Ee(i,r),l=Gs(c),u=ie(W(a,l.shape),l);if(t){const d=He(u.shape,r);return W(u,d)}return u}const Uf=T({logSumExp_:D$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F$(n,e){const t=N(n,"a","logicalAnd","bool"),s=N(e,"b","logicalAnd","bool");ye(t.shape,s.shape);const r={a:t,b:s};return E.runKernel(jr,r)}const Ba=T({logicalAnd_:F$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O$(n){const t={x:N(n,"x","logicalNot","bool")};return E.runKernel(Kr,t)}const Ju=T({logicalNot_:O$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P$(n,e){const t=N(n,"a","logicalOr","bool"),s=N(e,"b","logicalOr","bool");ye(t.shape,s.shape);const r={a:t,b:s};return E.runKernel(Xr,r)}const ed=T({logicalOr_:P$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L$(n,e){const t=N(n,"a","logicalXor","bool"),s=N(e,"b","logicalXor","bool");return ye(t.shape,s.shape),Ba(ed(n,e),Ju(Ba(n,e)))}const B$=T({logicalXor_:L$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V$(n,e,t,s,r){const a=N(n,"x","maxPool"),o=1;let i=a,c=!1;a.rank===3&&(c=!0,i=W(a,[1,a.shape[0],a.shape[1],a.shape[2]])),C(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),C(st(t,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),r!=null&&C(at(s),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);const l={x:i},u={filterSize:e,strides:t,pad:s,dimRoundingMode:r},d=E.runKernel(ui,l,u);return c?W(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const td=T({maxPool_:V$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M$(n,e=[1,1,1],t,s,r,a="NDHWC"){const o=N(n,"x","maxPool3d");let i=o,c=!1;o.rank===4&&(c=!0,i=W(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),C(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),C(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),r!=null&&C(at(s),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${r} but got pad ${s}.`);const l={x:i},u={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:a},d=E.runKernel(di,l,u);return c?W(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const Gf=T({maxPool3d_:M$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W$(n,e,t,s,r=!1){const o={x:N(n,"x","maxPoolWithArgmax")},i={filterSize:e,strides:t,pad:s,includeBatchInIndex:r},c=E.runKernel(pi,o,i);return{result:c[0],indexes:c[1]}}const Hf=T({maxPoolWithArgmax_:W$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z$(n,e){let t=N(n,"a","maximum"),s=N(e,"b","maximum");[t,s]=Pe(t,s),t.dtype==="bool"&&(t=ve(t,"int32"),s=ve(s,"int32")),ye(t.shape,s.shape);const r={a:t,b:s};return E.runKernel(Yr,r)}const nd=T({maximum_:z$});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U$(n,e=null,t=!1){const r={x:N(n,"x","mean")},a={axis:e,keepDims:t};return E.runKernel(hi,r,a)}const Va=T({mean_:U$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vn(n,e="float32"){if(e==="complex64"){const s=Vn(n,"float32"),r=Vn(n,"float32");return En(s,r)}const t=Qe(B(n),e);return E.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mn(n,e="float32"){if(e==="complex64"){const s=Mn(n,"float32"),r=Vn(n,"float32");return En(s,r)}const t=_l(B(n),e);return E.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G$(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let s=N(n,"x","meshgrid",n instanceof Ve?n.dtype:"float32");if(e===void 0)return[s];let r=N(e,"y","meshgrid",e instanceof Ve?e.dtype:"float32");const a=B(s.shape),o=B(r.shape);return t==="xy"?(s=W(s,[1,-1]),r=W(r,[-1,1]),[xe(Mn([o,1],s.dtype),s),xe(r,Mn([1,a],r.dtype))]):(s=W(s,[-1,1]),r=W(r,[1,-1]),[xe(s,Mn([1,o],s.dtype)),xe(Mn([a,1],r.dtype),r)])}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H$(n,e=null,t=!1){const r={x:N(n,"x","min")},a={axis:e,keepDims:t};return E.runKernel(fi,r,a)}const Cc=T({min_:H$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q$(n,e){let t=N(n,"a","minimum"),s=N(e,"b","minimum");[t,s]=Pe(t,s),t.dtype==="bool"&&(t=ve(t,"int32"),s=ve(s,"int32")),ye(t.shape,s.shape);const r={a:t,b:s};return E.runKernel(Qr,r)}const sd=T({minimum_:q$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j$(n,e,t){C(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const s=N(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");C(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r=t==="reflect"?1:0;for(let i=0;i<s.rank;i++)C(e[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),C(e[i][0]>=0&&e[i][0]<=s.shape[i]-r&&e[i][1]>=0&&e[i][1]<=s.shape[i]-r,()=>`Padding in dimension ${i} cannot be greater than or equal to ${s.shape[i]-r} or less than 0 for input of shape ${s.shape}`);const a={paddings:e,mode:t},o={x:s};return E.runKernel(mi,o,a)}const qf=T({mirrorPad_:j$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K$(n,e){let t=N(n,"a","mod"),s=N(e,"b","mod");[t,s]=Pe(t,s);const r={a:t,b:s};return E.runKernel(Zr,r)}const jf=T({mod_:K$});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X$(n){const e=N(n,"x","square"),t={};return E.runKernel("Square",{x:e},t)}const Lt=T({square_:X$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y$(n,e=null,t=!1){n=N(n,"x","moments");const s=ge(e,n.shape),r=Va(n,s,t);let a=r.shape;t||(a=He(r.shape,s));const o=Lt(de(ve(n,"float32"),W(r,a))),i=Va(o,s,t);return{mean:r,variance:i}}const Q$=T({moments_:Y$});function Z$(n,e,t,s){const r=N(e,"data","multiRNNCell"),a=Ea(t,"c","multiRNNCell"),o=Ea(s,"h","multiRNNCell");let i=r;const c=[];for(let d=0;d<n.length;d++){const p=n[d](i,a[d],o[d]);c.push(p[0]),c.push(p[1]),i=p[1]}const l=[],u=[];for(let d=0;d<c.length;d+=2)l.push(c[d]),u.push(c[d+1]);return[l,u]}const J$=T({multiRNNCell_:Z$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ev(n,e,t,s=!1){const r=N(n,"logits","multinomial"),a=r.size,o=r.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);t=t||Math.random();const c={logits:o===1?W(r,[1,-1]):r},l={numSamples:e,seed:t,normalized:s},u=E.runKernel(gi,c,l);return o===1?W(u,[u.size]):u}const Kf=T({multinomial_:ev});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tv(n,e){let t=N(n,"a","notEqual","string_or_numeric"),s=N(e,"b","notEqual","string_or_numeric");[t,s]=Pe(t,s),ye(t.shape,s.shape);const r={a:t,b:s};return E.runKernel(ea,r)}const rd=T({notEqual_:tv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nv(n){const t={x:N(n,"x","onesLike")};return E.runKernel($i,t)}const Xf=T({onesLike_:nv});function sv(n,e){const t=N(n,"v1","outerProduct"),s=N(e,"v2","outerProduct");C(t.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${s.rank}.`);const r=W(t,[-1,1]),a=W(s,[1,-1]);return xe(r,a)}const rv=T({outerProduct_:sv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function av(n,e,t=0){const s=N(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:t},a={x:s};return E.runKernel(Ni,a,r)}const Hs=T({pad_:av});function ov(n,e,t=0){return C(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),Hs(n,[e],t)}const iv=T({pad1d_:ov});function cv(n,e,t=0){return C(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Hs(n,e,t)}const lv=T({pad2d_:cv});function uv(n,e,t=0){return C(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Hs(n,e,t)}const dv=T({pad3d_:uv});function pv(n,e,t=0){return C(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Hs(n,e,t)}const hv=T({pad4d_:pv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fv(n,e,t){const s=N(n,"x","spaceToBatchND");C(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),C(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),C(s.shape.reduce((o,i,c)=>c>0&&c<=e.length?o&&(i+t[c-1][0]+t[c-1][1])%e[c-1]==0:o,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:s},a={blockShape:e,paddings:t};return E.runKernel(Li,r,a)}const ad=T({spaceToBatchND_:fv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mv(n,e,t,s,r,a){r==null&&(r=[1,1]),a==null&&(a=1),s===0&&(s="valid");const o=N(n,"x","maxPool");let i=o,c=!1;o.rank===3&&(c=!0,i=W(o,[1,o.shape[0],o.shape[1],o.shape[2]])),C(st(a,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${r}'`);const l=Pt(i.shape,e,a,r,s),u=[l.dilationHeight,l.dilationWidth];let d;s==="same"?d=yv([l.filterHeight,l.filterWidth],u):d=[[0,0],[0,0]];const p=u[0]===1&&u[1]===1,[h,f]=gv([l.inHeight,l.inWidth],u,d),m=p?s:"valid",g=p?i:ad(i,u,h),x=(t==="avg"?()=>zu(g,e,a,m):()=>td(g,e,a,m))(),w=p?x:Uu(x,u,f);return c?W(w,[w.shape[1],w.shape[2],w.shape[3]]):w}function gv(n,e,t){const s=t.map(u=>u[0]),r=t.map(u=>u[1]),a=n.concat(s,r),o=e.map((u,d)=>(u-a[d]%u)%u),i=r.map((u,d)=>u+o[d]),c=e.map((u,d)=>[s[d],i[d]]),l=e.map((u,d)=>[0,o[d]]);return[c,l]}function yv(n,e){const s=n.map((o,i)=>o+(o-1)*(e[i]-1)).map(o=>o-1),r=s.map(o=>Math.floor(o/2)),a=s.map((o,i)=>o-r[i]);return s.map((o,i)=>[r[i],a[i]])}const xv=T({pool_:mv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bv(n,e){let t=N(n,"base","pow"),s=N(e,"exp","pow");[t,s]=Pe(t,s);const r={a:t,b:s};return E.runKernel(ta,r)}const qs=T({pow_:bv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wv(n,e){const t=N(n,"x","prelu"),s=N(e,"alpha","prelu"),r={x:t,alpha:s};return E.runKernel(ki,r)}const od=T({prelu_:wv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $v(n,e=null,t=!1){let s=N(n,"x","prod");s.dtype==="bool"&&(s=ve(s,"int32"));const r={x:s},a={axis:e,keepDims:t};return E.runKernel(Ii,r,a)}const id=T({prod_:$v});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vv(n,e,t){const s=B(n);let r=null;if(t==null||t==="float32")r=new Float32Array(s);else if(t==="int32")r=new Int32Array(s);else if(t==="bool")r=new Uint8Array(s);else throw new Error(`Unknown data type ${t}`);for(let a=0;a<s;a++)r[a]=e();return E.makeTensor(r,n,t)}const Cv=T({rand_:vv});var Yf={exports:{}};(function(n){(function(e,t,s){function r(c){var l=this,u=i();l.next=function(){var d=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=d-(l.c=d|0)},l.c=1,l.s0=u(" "),l.s1=u(" "),l.s2=u(" "),l.s0-=u(c),l.s0<0&&(l.s0+=1),l.s1-=u(c),l.s1<0&&(l.s1+=1),l.s2-=u(c),l.s2<0&&(l.s2+=1),u=null}function a(c,l){return l.c=c.c,l.s0=c.s0,l.s1=c.s1,l.s2=c.s2,l}function o(c,l){var u=new r(c),d=l&&l.state,p=u.next;return p.int32=function(){return u.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,d&&(typeof d=="object"&&a(d,u),p.state=function(){return a(u,{})}),p}function i(){var c=4022871197,l=function(u){u=u.toString();for(var d=0;d<u.length;d++){c+=u.charCodeAt(d);var p=.02519603282416938*c;c=p>>>0,p-=c,p*=c,c=p>>>0,p-=c,c+=p*4294967296}return(c>>>0)*23283064365386963e-26};return l}t&&t.exports?t.exports=o:s&&s.amd?s(function(){return o}):this.alea=o})(ts,n,!1)})(Yf);var Qf={exports:{}};(function(n){(function(e,t,s){function r(i){var c=this,l="";c.x=0,c.y=0,c.z=0,c.w=0,c.next=function(){var d=c.x^c.x<<11;return c.x=c.y,c.y=c.z,c.z=c.w,c.w^=c.w>>>19^d^d>>>8},i===(i|0)?c.x=i:l+=i;for(var u=0;u<l.length+64;u++)c.x^=l.charCodeAt(u)|0,c.next()}function a(i,c){return c.x=i.x,c.y=i.y,c.z=i.z,c.w=i.w,c}function o(i,c){var l=new r(i),u=c&&c.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var p=l.next()>>>11,h=(l.next()>>>0)/4294967296,f=(p+h)/(1<<21);while(f===0);return f},d.int32=l.next,d.quick=d,u&&(typeof u=="object"&&a(u,l),d.state=function(){return a(l,{})}),d}t&&t.exports?t.exports=o:s&&s.amd?s(function(){return o}):this.xor128=o})(ts,n,!1)})(Qf);var Zf={exports:{}};(function(n){(function(e,t,s){function r(i){var c=this,l="";c.next=function(){var d=c.x^c.x>>>2;return c.x=c.y,c.y=c.z,c.z=c.w,c.w=c.v,(c.d=c.d+362437|0)+(c.v=c.v^c.v<<4^(d^d<<1))|0},c.x=0,c.y=0,c.z=0,c.w=0,c.v=0,i===(i|0)?c.x=i:l+=i;for(var u=0;u<l.length+64;u++)c.x^=l.charCodeAt(u)|0,u==l.length&&(c.d=c.x<<10^c.x>>>4),c.next()}function a(i,c){return c.x=i.x,c.y=i.y,c.z=i.z,c.w=i.w,c.v=i.v,c.d=i.d,c}function o(i,c){var l=new r(i),u=c&&c.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var p=l.next()>>>11,h=(l.next()>>>0)/4294967296,f=(p+h)/(1<<21);while(f===0);return f},d.int32=l.next,d.quick=d,u&&(typeof u=="object"&&a(u,l),d.state=function(){return a(l,{})}),d}t&&t.exports?t.exports=o:s&&s.amd?s(function(){return o}):this.xorwow=o})(ts,n,!1)})(Zf);var Jf={exports:{}};(function(n){(function(e,t,s){function r(i){var c=this;c.next=function(){var u=c.x,d=c.i,p,h;return p=u[d],p^=p>>>7,h=p^p<<24,p=u[d+1&7],h^=p^p>>>10,p=u[d+3&7],h^=p^p>>>3,p=u[d+4&7],h^=p^p<<7,p=u[d+7&7],p=p^p<<13,h^=p^p<<9,u[d]=h,c.i=d+1&7,h};function l(u,d){var p,h=[];if(d===(d|0))h[0]=d;else for(d=""+d,p=0;p<d.length;++p)h[p&7]=h[p&7]<<15^d.charCodeAt(p)+h[p+1&7]<<13;for(;h.length<8;)h.push(0);for(p=0;p<8&&h[p]===0;++p);for(p==8&&(h[7]=-1),u.x=h,u.i=0,p=256;p>0;--p)u.next()}l(c,i)}function a(i,c){return c.x=i.x.slice(),c.i=i.i,c}function o(i,c){i==null&&(i=+new Date);var l=new r(i),u=c&&c.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var p=l.next()>>>11,h=(l.next()>>>0)/4294967296,f=(p+h)/(1<<21);while(f===0);return f},d.int32=l.next,d.quick=d,u&&(u.x&&a(u,l),d.state=function(){return a(l,{})}),d}t&&t.exports?t.exports=o:s&&s.amd?s(function(){return o}):this.xorshift7=o})(ts,n,!1)})(Jf);var em={exports:{}};(function(n){(function(e,t,s){function r(i){var c=this;c.next=function(){var u=c.w,d=c.X,p=c.i,h,f;return c.w=u=u+1640531527|0,f=d[p+34&127],h=d[p=p+1&127],f^=f<<13,h^=h<<17,f^=f>>>15,h^=h>>>12,f=d[p]=f^h,c.i=p,f+(u^u>>>16)|0};function l(u,d){var p,h,f,m,g,y=[],x=128;for(d===(d|0)?(h=d,d=null):(d=d+"\0",h=0,x=Math.max(x,d.length)),f=0,m=-32;m<x;++m)d&&(h^=d.charCodeAt((m+32)%d.length)),m===0&&(g=h),h^=h<<10,h^=h>>>15,h^=h<<4,h^=h>>>13,m>=0&&(g=g+1640531527|0,p=y[m&127]^=h+g,f=p==0?f+1:0);for(f>=128&&(y[(d&&d.length||0)&127]=-1),f=127,m=4*128;m>0;--m)h=y[f+34&127],p=y[f=f+1&127],h^=h<<13,p^=p<<17,h^=h>>>15,p^=p>>>12,y[f]=h^p;u.w=g,u.X=y,u.i=f}l(c,i)}function a(i,c){return c.i=i.i,c.w=i.w,c.X=i.X.slice(),c}function o(i,c){i==null&&(i=+new Date);var l=new r(i),u=c&&c.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var p=l.next()>>>11,h=(l.next()>>>0)/4294967296,f=(p+h)/(1<<21);while(f===0);return f},d.int32=l.next,d.quick=d,u&&(u.X&&a(u,l),d.state=function(){return a(l,{})}),d}t&&t.exports?t.exports=o:s&&s.amd?s(function(){return o}):this.xor4096=o})(ts,n,!1)})(em);var tm={exports:{}};(function(n){(function(e,t,s){function r(i){var c=this,l="";c.next=function(){var d=c.b,p=c.c,h=c.d,f=c.a;return d=d<<25^d>>>7^p,p=p-h|0,h=h<<24^h>>>8^f,f=f-d|0,c.b=d=d<<20^d>>>12^p,c.c=p=p-h|0,c.d=h<<16^p>>>16^f,c.a=f-d|0},c.a=0,c.b=0,c.c=2654435769|0,c.d=1367130551,i===Math.floor(i)?(c.a=i/4294967296|0,c.b=i|0):l+=i;for(var u=0;u<l.length+20;u++)c.b^=l.charCodeAt(u)|0,c.next()}function a(i,c){return c.a=i.a,c.b=i.b,c.c=i.c,c.d=i.d,c}function o(i,c){var l=new r(i),u=c&&c.state,d=function(){return(l.next()>>>0)/4294967296};return d.double=function(){do var p=l.next()>>>11,h=(l.next()>>>0)/4294967296,f=(p+h)/(1<<21);while(f===0);return f},d.int32=l.next,d.quick=d,u&&(typeof u=="object"&&a(u,l),d.state=function(){return a(l,{})}),d}t&&t.exports?t.exports=o:s&&s.amd?s(function(){return o}):this.tychei=o})(ts,n,!1)})(tm);var nm={exports:{}};(function(n){(function(e,t){var s=this,r=256,a=6,o=52,i="random",c=t.pow(r,a),l=t.pow(2,o),u=l*2,d=r-1,p;function h($,v,k){var I=[];v=v==!0?{entropy:!0}:v||{};var S=y(g(v.entropy?[$,w(e)]:$==null?x():$,3),I),A=new f(I),R=function(){for(var _=A.g(a),D=c,F=0;_<l;)_=(_+F)*r,D*=r,F=A.g(1);for(;_>=u;)_/=2,D/=2,F>>>=1;return(_+F)/D};return R.int32=function(){return A.g(4)|0},R.quick=function(){return A.g(4)/4294967296},R.double=R,y(w(A.S),e),(v.pass||k||function(_,D,F,P){return P&&(P.S&&m(P,A),_.state=function(){return m(A,{})}),F?(t[i]=_,D):_})(R,S,"global"in v?v.global:this==t,v.state)}t["seed"+i]=h;function f($){var v,k=$.length,I=this,S=0,A=I.i=I.j=0,R=I.S=[];for(k||($=[k++]);S<r;)R[S]=S++;for(S=0;S<r;S++)R[S]=R[A=d&A+$[S%k]+(v=R[S])],R[A]=v;(I.g=function(_){for(var D,F=0,P=I.i,L=I.j,O=I.S;_--;)D=O[P=d&P+1],F=F*r+O[d&(O[P]=O[L=d&L+D])+(O[L]=D)];return I.i=P,I.j=L,F})(r)}function m($,v){return v.i=$.i,v.j=$.j,v.S=$.S.slice(),v}function g($,v){var k=[],I=typeof $,S;if(v&&I=="object")for(S in $)try{k.push(g($[S],v-1))}catch{}return k.length?k:I=="string"?$:$+"\0"}function y($,v){for(var k=$+"",I,S=0;S<k.length;)v[d&S]=d&(I^=v[d&S]*19)+k.charCodeAt(S++);return w(v)}function x(){try{var $;return p&&($=p.randomBytes)?$=$(r):($=new Uint8Array(r),(s.crypto||s.msCrypto).getRandomValues($)),w($)}catch{var v=s.navigator,k=v&&v.plugins;return[+new Date,s,k,s.screen,w(e)]}}function w($){return String.fromCharCode.apply(0,$)}if(y(t.random(),e),n.exports){n.exports=h;try{p=require("crypto")}catch{}}})([],Math)})(nm);var Nv=Yf.exports,kv=Qf.exports,Iv=Zf.exports,Sv=Jf.exports,Tv=em.exports,Ev=tm.exports,gs=nm.exports;gs.alea=Nv;gs.xor128=kv;gs.xorwow=Iv;gs.xorshift7=Sv;gs.xor4096=Tv;gs.tychei=Ev;var Nc=gs;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cd{constructor(e,t,s,r,a){this.mean=e,this.stdDev=t,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=a||Math.random();this.random=Nc.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,t,s=!1;for(;!s;){let r,a,o;do r=2*this.random()-1,a=2*this.random()-1,o=r*r+a*a;while(o>=1||o===0);const i=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class Rv{constructor(e,t,s,r){this.alpha=e,this.beta=1/t,this.dtype=s;const a=r||Math.random();this.randu=Nc.alea(a.toString()),this.randn=new cd(0,1,s,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,s,r,a,o;for(;;){do r=this.randn.nextValue(),o=1+this.c*r;while(o<=0);if(o*=o*o,e=r*r,t=1-.331*e*e,s=.5*e+this.d*(1-o+Math.log(o)),a=this.randu(),a<t||Math.log(a)<s)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class _v{constructor(e=0,t=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Nc.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Av(n,e,t=1,s="float32",r){if(t==null&&(t=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const a=new Rv(e,t,s,r),o=ue(n,s);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const Dv=T({randomGamma_:Av});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fv(n,e=0,t=1,s,r){if(s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const a=new cd(e,t,s,!1,r),o=ue(n,s);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const Ov=T({randomNormal_:Fv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pv(n,e=0,t=1,s="float32",r){const a=ue(n,s),o=new _v(e,t,null,r);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const ld=T({randomUniform_:Pv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function js(n,e,t=1,s="float32"){if(t===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:e,step:t,dtype:s};return E.runKernel(Si,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lv(n){const t={input:N(n,"input","real")};return E.runKernel(Ti,t)}const Ma=T({real_:Lv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bv(n){const t={x:N(n,"x","reciprocal")};return E.runKernel(na,t)}const sm=T({reciprocal_:Bv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vv(n){const t={x:N(n,"x","relu")};return E.runKernel(sa,t)}const Wa=T({relu_:Vv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mv(n){const t={x:N(n,"x","relu6")};return E.runKernel(ra,t)}const ud=T({relu6_:Mv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wv(n,e){const s={x:N(n,"x","reverse")},r={dims:e};return E.runKernel(Ai,s,r)}const gn=T({reverse_:Wv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zv(n){const e=N(n,"x","reverse");return C(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),gn(e,0)}const Uv=T({reverse1d_:zv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gv(n,e){const t=N(n,"x","reverse");return C(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),gn(t,e)}const Hv=T({reverse2d_:Gv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qv(n,e){const t=N(n,"x","reverse");return C(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),gn(t,e)}const jv=T({reverse3d_:qv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kv(n,e){const t=N(n,"x","reverse");return C(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),gn(t,e)}const Xv=T({reverse4d_:Kv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yv(n){const t={x:N(n,"x","round")};return E.runKernel(aa,t)}const dd=T({round_:Yv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qv(n){const t={x:N(n,"x","rsqrt","float32")};return E.runKernel(oa,t)}const rm=T({rsqrt_:Qv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pe(n,e){if((nt(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&nt(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Rn(n,[],[],e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zv(n){const t={x:N(n,"x","selu")};return E.runKernel(ia,t)}const am=T({selu_:Zv});function Jv(n,e,t,s,r,a=[1,1],o="NHWC"){const i=N(n,"x","separableConv2d"),c=N(e,"depthwiseFilter","separableConv2d"),l=N(t,"pointwiseFilter","separableConv2d");let u=i,d=!1;if(i.rank===3&&(d=!0,u=W(i,[1,i.shape[0],i.shape[1],i.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");C(u.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),C(c.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${c.rank}.`),C(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${c.rank}.`),C(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),C(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);const p=c.shape[2],h=c.shape[3];C(l.shape[2]===p*h,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${p*h}, but got ${l.shape[2]}.`);const f=yc(u,c,s,r,o,a),g=Oa(f,l,1,"valid",o);return d?W(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const e2=T({separableConv2d_:Jv});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function t2(n,e){const t=N(n,"x","setdiff1d"),s=N(e,"y","setdiff1d");C(t.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${s.dtype}).`),C(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),C(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await t.data(),a=await s.data(),o=new Set(a);let i=0;for(let u=0;u<r.length;u++)o.has(r[u])||i++;const c=new Ge([i],t.dtype),l=new Ge([i],"int32");for(let u=0,d=0;u<r.length;u++)o.has(r[u])||(c.values[d]=r[u],l.values[d]=u,d++);return[c.toTensor(),l.toTensor()]}const om=t2;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n2(n){const t={x:N(n,"x","sign")};return E.runKernel(ua,t)}const im=T({sign_:n2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s2(n){const t={x:N(n,"x","sin","float32")};return E.runKernel(ca,t)}const cm=T({sin_:s2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r2(n){const t={x:N(n,"x","sinh")};return E.runKernel(la,t)}const lm=T({sinh_:r2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a2(n,e,t){const s=N(n,"x","slice1d");return C(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),Ce(s,[e],[t])}const o2=T({slice1d_:a2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i2(n,e,t){const s=N(n,"x","slice2d");return C(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),Ce(s,e,t)}const c2=T({slice2d_:i2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l2(n,e,t){const s=N(n,"x","slice3d");return C(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),Ce(s,e,t)}const u2=T({slice3d_:l2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d2(n,e,t){const s=N(n,"x","slice4d");return C(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),Ce(s,e,t)}const p2=T({slice4d_:d2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h2(n,e=-1){const t=N(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const s={logits:t},r={dim:e};return E.runKernel(Vi,s,r)}const um=T({softmax_:h2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f2(n){C(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return E.runKernel(Zo,e)}const kc=T({fft_:f2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m2(n){C(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return E.runKernel(ri,e)}const za=T({ifft_:m2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g2(n){const e=n.shape[n.shape.length-1],t=n.size/e;let s;if(e<=2){const r=W(n,[t,e]);s=za(r)}else{const r=[t,2*(e-1)],a=W(Ma(n),[t,e]),o=W(bc(n),[t,e]),i=gn(Ce(a,[0,1],[t,e-2]),1),c=Q(gn(Ce(o,[0,1],[t,e-2]),1),pe(-1)),l=rt([a,i],1),u=rt([o,c],1),d=W(En(l,u),[r[0],r[1]]);s=za(d)}if(s=Ma(s),n.rank===3&&n.shape[0]!==0){const r=s,a=n.shape[0];s=W(s,[a,s.shape[0]/a,s.shape[1]]),r.dispose()}return s}const pd=T({irfft_:g2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y2(n,e,t=0){const r={x:N(n,"x","split")},a={numOrSizeSplits:e,axis:t};return E.runKernel(Bi,r,a)}const Ks=T({split_:y2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x2(n,e){C(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const s=n.size/t;let r;if(e!=null&&e<t){const f=n.shape.map(g=>0),m=n.shape.map(g=>g);m[n.shape.length-1]=e,r=Ce(n,f,m),t=e}else if(e!=null&&e>t){const f=n.shape.map(m=>m);f[n.shape.length-1]=e-t,r=rt([n,Vn(f)],n.shape.length-1),t=e}else r=n;const a=$t(r),o=W(En(r,a),[s,t]),i=kc(o),c=Math.floor(t/2)+1,l=Ma(i),u=bc(i),d=Ks(l,[c,t-c],l.shape.length-1),p=Ks(u,[c,t-c],u.shape.length-1),h=r.shape.slice();return h[r.shape.length-1]=c,W(En(d[0],p[0]),h)}const Ic=T({rfft_:x2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b2(n){const t={x:N(n,"x","sqrt","float32")};return E.runKernel(ha,t)}const en=T({sqrt_:b2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w2(n,e){let t=N(n,"a","squaredDifference"),s=N(e,"b","squaredDifference");[t,s]=Pe(t,s),ye(t.shape,s.shape);const r={a:t,b:s},a={};return E.runKernel(fa,r,a)}const hd=T({squaredDifference_:w2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $2(n,e){const t=N(n,"x","squeeze");return W(t,un(t.shape,e).newShape)}const Xs=T({squeeze_:$2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v2(n,e=0){const t=Ea(n,"tensors","stack","string_or_numeric");C(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&C(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const s=t,r={axis:e};return E.runKernel(Ci,s,r)}const tn=T({stack_:v2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C2(n,e=0){const s={x:N(n,"x","step")},r={alpha:e};return E.runKernel(ba,s,r)}const dm=T({step_:C2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N2(n,e,t,s,r=0,a=0,o=0,i=0,c=0){const u={x:N(n,"x","stridedSlice","string_or_numeric")},d={begin:e,end:t,strides:s,beginMask:r,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:c};return E.runKernel(Hi,u,d)}const pm=T({stridedSlice_:N2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k2(n){const t={x:N(n,"x","tan","float32")};return E.runKernel(ga,t)}const hm=T({tan_:k2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tt(n,e){Jn(n);const t=Yt(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Rn(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ua(n,e,t){if(Jn(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=Yt(n,t);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Rn(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I2(n,e,t){if(Jn(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=Yt(n,t);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Rn(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S2(n,e,t){if(Jn(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=Yt(n,t);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Rn(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T2(n,e,t){if(Jn(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=Yt(n,t);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||s,Rn(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E2(n,e=1,t=!0){const s=N(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const a={x:s},o={k:e,sorted:t},[i,c]=E.runKernel(Xi,a,o);return{values:i,indices:c}}const fm=T({topk_:E2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R2(n,e=0,t=1,s,r){if(s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const a=new cd(e,t,s,!0,r),o=ue(n,s);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const mm=T({truncatedNormal_:R2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _2(n,e=0){const t=N(n,"x","unique","string_or_numeric");C(t.rank>0,()=>"The input tensor must be at least 1D");const s={x:t},r={axis:e},[a,o]=E.runKernel(Zi,s,r);return{values:a,indices:o}}const fd=T({unique_:_2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A2(n,e,t){const s=N(n,"x","unsortedSegmentSum"),r=N(e,"segmentIds","unsortedSegmentSum","int32");C(at(t),()=>"numSegments must be of dtype int");const a={x:s,segmentIds:r},o={numSegments:t};return E.runKernel(ec,a,o)}const D2=T({unsortedSegmentSum_:A2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F2(n,e=0){const t=N(n,"x","unstack","string_or_numeric");C(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const s={value:t},r={axis:e};return E.runKernel(Ji,s,r)}const Wn=T({unstack_:F2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O2(n,e=!0,t,s){return E.makeVariable(n,e,t,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sc(n,e){const t=[];for(let a=0;a<e.length;a++)e[a]&&t.push(a);const s=ue(n,"int32"),r=ue([t.length,n.length],"int32");for(let a=0;a<t.length;a++){const o=s.indexToLoc(t[a]),i=a*n.length;r.values.set(o,i)}return r.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function P2(n){const e=N(n,"condition","whereAsync","bool"),t=await e.data(),s=Sc(e.shape,t);return n!==e&&e.dispose(),s}const md=P2;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function L2(n,e,t){const s=N(n,"tensor","boolMask"),r=N(e,"mask","boolMask","bool"),a=t==null?0:t,o=r.rank,i=s.shape;C(o>0,()=>"mask cannot be scalar"),Ye(i.slice(a,a+o),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let c=1;for(let m=a;m<a+o;m++)c*=i[m];const l=i.slice(0,a).concat([c],i.slice(a+o)),u=W(s,l),d=W(r,[-1]),p=await md(d),h=Xs(p,[1]),f=xc(u,h,a);return n!==s&&s.dispose(),e!==r&&r.dispose(),h.dispose(),u.dispose(),d.dispose(),p.dispose(),f}const B2=L2;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V2(n,e="euclidean",t=null,s=!1){n=N(n,"x","norm");const r=gm(n,e,t);let a=r.shape;if(s){const o=ge(t,n.shape);a=He(r.shape,o)}return W(r,a)}function gm(n,e,t=null){if(n.rank===0)return wt(n);if(n.rank!==1&&t===null)return gm(W(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Ee(wt(n),t);if(e===1/0)return ms(wt(n),t);if(e===-1/0)return Cc(wt(n),t);if(e==="euclidean"||e===2)return en(Ee(qs(wt(n),pe(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return ms(Ee(wt(n),t[0]),t[1]-1);if(e===1/0)return ms(Ee(wt(n),t[1]),t[0]);if(e===-1/0)return Cc(Ee(wt(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return en(Ee(Lt(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const gd=T({norm_:V2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M2(n,e,t,s,r=!0){const a=N(n,"v","movingAverage"),o=N(e,"x","movingAverage"),i=N(t,"decay","movingAverage");yh(a,o),C($e(a.shape,o.shape),()=>"Shape mismatch in v and x");const c=pe(1),l=de(c,i);let u=Q(de(o,a),l);if(r){C(s!=null,()=>"When using zeroDebias: true, step is required.");const d=N(s,"step","movingAverage");u=Te(u,de(c,qs(i,d)))}return ie(a,u)}const W2=T({movingAverage_:M2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z2(n,e,t){const s=N(n,"indices","scatterND","int32"),r=N(e,"updates","scatterND");Su(r,s,t);const a={indices:s,updates:r},o={shape:t};return E.runKernel(Di,a,o)}const ym=T({scatterND_:z2});function U2(n,e,t,s){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const r=n.rank>0?n.shape[0]:1,a=n.rank>1?n.shape[1]:1;if(t.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${a}.`);const o=e.size;if(!(e.rank===0||e.rank===1&&o===r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G2(n,e,t,s=0){const r=N(n,"sparseIndices","sparseToDense","int32"),a=N(e,"sparseValues","sparseToDense"),o=N(s,"defaultValue","sparseToDense",a.dtype);U2(r,a,t,o);const i={sparseIndices:r,sparseValues:a,defaultValue:o},c={outputShape:t};return E.runKernel(Gi,i,c)}const yd=T({sparseToDense_:G2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H2(n,e){const t=N(e,"indices","gatherND","int32"),r={params:N(n,"x","gatherND","string_or_numeric"),indices:t};return E.runKernel(si,r)}const xm=T({gatherND_:H2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q2(n,e){if(e==null)return n.shape.slice();if($e(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let s=0;s<n.shape.length;s++)e[s]==null&&n.shape[s]!=null?t.push(n.shape[s]):t.push(e[s]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j2(n,e,t,s){const r=N(n,"x","dropout");if(C(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),C(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof Ve?r.clone():r;const a=q2(r,t),o=1-e,i=Te(ju(ie(ld(a,0,1,"float32",s),o)),o);return Q(r,i)}const K2=T({dropout_:j2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bm(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function xd(n,e,t){const s=1-n%2,r=new Float32Array(n);for(let a=0;a<n;++a){const o=2*Math.PI*a/(n+s-1);r[a]=e-t*Math.cos(o)}return Tt(r,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function X2(n,e,t=1){const s=N(n,"predictions","inTopK"),r=N(e,"targets","inTopK");C(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),C(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`),Ye(s.shape.slice(0,s.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=s.shape[s.shape.length-1];C(t>0&&t<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${t}`);const o=await s.data(),i=await r.data(),[c,l]=[o.length/a,a],u=Ue("bool",c);for(let d=0;d<c;d++){const p=d*l,h=o.subarray(p,p+l),f=[];for(let m=0;m<h.length;m++)f.push({value:h[m],index:m});f.sort((m,g)=>g.value-m.value),u[d]=0;for(let m=0;m<t;m++)if(f[m].index===i[d]){u[d]=1;break}}return n!==s&&s.dispose(),e!==r&&r.dispose(),Qt(u,r.shape,"bool")}const Y2=X2;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q2(n,e,t,s,r,a="NHWC",o){let i=n;n.rank===3&&(i=W(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let c=e;c.rank===3&&(c=W(e,[1,e.shape[0],e.shape[1],e.shape[2]])),C(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),C(c.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${c.shape}.`),C(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const l=a==="NHWC"?i.shape[3]:i.shape[1],u=a==="NHWC"?c.shape[3]:c.shape[1];C(l===t[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${t[2]}.`),C(u===t[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${t[3]}).`),o!=null&&C(at(r),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${o} but got pad ${r}.`);const d={x:i,dy:c},p={strides:s,pad:r,dataFormat:a,dimRoundingMode:o,filterShape:t};return E.runKernel(Lo,d,p)}const Z2=T({conv2DBackpropFilter_:Q2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tc(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return Q(n,dm(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function Ec(n,e){let t=e;const s=Rf(n.shape,e.shape);return s.length>0&&(t=Ee(t,s)),W(t,n.shape)}function Rc(n,e,t,s){if(e==="linear")return n;if(e==="relu")return Wa(n);if(e==="elu")return qu(n);if(e==="relu6")return ud(n);if(e==="prelu")return od(n,t);if(e==="leakyrelu")return Xu(n,s);if(e==="sigmoid")return hs(n);throw new Error(`Unknown fused activation ${e}.`)}const _c=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J2({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:c="linear",preluActivationWeights:l,leakyreluAlpha:u}){if(c=c||"linear",_c(E.state.gradientDepth,c)===!1){let v=Oa(n,e,t,s,r,a,o);return i!=null&&(v=ie(v,i)),Rc(v,c,l,u)}const d=N(n,"x","conv2d","float32"),p=N(e,"filter","conv2d","float32");let h=d,f=!1;d.rank===3&&(f=!0,h=W(d,[1,d.shape[0],d.shape[1],d.shape[2]])),C(h.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${h.rank}.`),C(p.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`),o!=null&&C(at(s),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`),C(h.shape[3]===p.shape[2],()=>`Error in conv2d: depth of input (${h.shape[3]}) must match input depth for filter ${p.shape[2]}.`),C(st(t,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),C(r==="NHWC",()=>`Error in conv2d: got dataFormat of ${r} but only NHWC is currently supported.`);const m=je(h.shape,p.shape,t,a,s,o);let g;i!=null&&(g=N(i,"bias","fused conv2d"),[g]=Pe(g,d),ye(m.outShape,g.shape));let y;l!=null&&(y=N(l,"prelu weights","fused conv2d"));const x=(v,k)=>{const[I,S,A,R]=k,_=Tc(v,A,c);C(Da(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const D=$f(S.shape,_,I,t,s),F=Z2(S,_,I.shape,t,s),P=[D,F];if(R!=null){const L=Ec(R,_);P.push(L)}return P},w={x:h,filter:p,bias:g,preluActivationWeights:y},$={strides:t,pad:s,dataFormat:r,dilations:a,dimRoundingMode:o,activation:c,leakyreluAlpha:u};return i==null?Jt((k,I,S)=>{let A=E.runKernel($a,w,$);return S([I,k,A]),f&&(A=W(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:x}})(h,p):Jt((k,I,S,A)=>{let R=E.runKernel($a,w,$);return A([I,k,R,S]),f&&(R=W(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:x}})(h,p,g)}const wm=T({fusedConv2d_:J2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eC(n,e,t,s,r,a=[1,1],o){let i=n;n.rank===3&&(i=W(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let c=e;c.rank===3&&(c=W(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={x:i,dy:c},u={strides:s,pad:r,dimRoundingMode:o,dilations:a,filterShape:t};return E.runKernel(qo,l,u)}const tC=T({depthwiseConv2dNativeBackpropFilter_:eC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nC(n,e,t,s,r,a=[1,1],o){let i=e,c=!1;e.rank===3&&(c=!0,i=W(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={dy:i,filter:t},u={strides:s,pad:r,dimRoundingMode:o,dilations:a,inputShape:n},d=E.runKernel(jo,l,u);return c?W(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const sC=T({depthwiseConv2dNativeBackpropInput_:nC});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rC({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:c="linear",preluActivationWeights:l,leakyreluAlpha:u}){if(_c(E.state.gradientDepth,c)===!1){let v=yc(n,e,t,s,r,a,o);return i!=null&&(v=ie(v,i)),Rc(v,c,l,u)}const d=N(n,"x","depthwiseConv2d","float32"),p=N(e,"filter","depthwiseConv2d","float32");let h=d,f=!1;d.rank===3&&(f=!0,h=W(d,[1,d.shape[0],d.shape[1],d.shape[2]])),C(h.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),C(p.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${p.rank}.`),C(h.shape[3]===p.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),a==null&&(a=[1,1]),C(st(t,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),o!=null&&C(at(s),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${o} but got pad ${s}.`);const m=je(h.shape,p.shape,t,a,s,o,!0);let g;i!=null&&(g=N(i,"bias","fused conv2d"),[g]=Pe(g,d),ye(m.outShape,g.shape));let y;l!=null&&(y=N(l,"prelu weights","fused depthwiseConv2d"));const x=(v,k)=>{C(Da(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[I,S,A,R]=k,_=Tc(v,A,c),D=sC(S.shape,_,I,t,s,a,o),F=tC(S,_,I.shape,t,s,a,o);if(R!=null){const P=Ec(g,_);return[D,F,P]}return[D,F]},w={x:h,filter:p,bias:g,preluActivationWeights:y},$={strides:t,pad:s,dataFormat:r,dilations:a,dimRoundingMode:o,activation:c,leakyreluAlpha:u};return i==null?Jt((k,I,S)=>{let A=E.runKernel(va,w,$);return S([I,k,A]),f&&(A=W(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:x}})(h,p):Jt((k,I,S,A)=>{let R=E.runKernel(va,w,$);return A([I,k,R,S]),f&&(R=W(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:x}})(h,p,g)}const $m=T({fusedDepthwiseConv2d_:rC});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aC({a:n,b:e,transposeA:t=!1,transposeB:s=!1,bias:r,activation:a="linear",preluActivationWeights:o,leakyreluAlpha:i}){if(_c(E.state.gradientDepth,a)===!1){let R=xe(n,e,t,s);return r!=null&&(R=ie(R,r)),Rc(R,a,o,i)}let c=N(n,"a","fused matMul"),l=N(e,"b","fused matMul");[c,l]=Pe(c,l);const u=t?c.shape[c.rank-2]:c.shape[c.rank-1],d=s?l.shape[l.rank-1]:l.shape[l.rank-2],p=t?c.shape[c.rank-1]:c.shape[c.rank-2],h=s?l.shape[l.rank-2]:l.shape[l.rank-1],f=c.shape.slice(0,-2),m=l.shape.slice(0,-2),g=B(f),y=B(m);C(c.rank>=2&&l.rank>=2&&c.rank===l.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${c.rank} and ${l.rank}.`),C($e(f,m),()=>`Error in fused matMul: outer dimensions (${f}) and (${m}) of Tensors with shapes ${c.shape} and ${l.shape} must match.`),C(u===d,()=>`Error in fused matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${c.shape} and ${l.shape} and transposeA=${t} and transposeB=${s} must match.`);const x=c.shape.slice(0,-2).concat([p,h]),w=t?W(c,[g,u,p]):W(c,[g,p,u]),$=s?W(l,[y,h,d]):W(l,[y,d,h]);let v;r!=null&&(v=N(r,"bias","fused matMul"),[v]=Pe(v,c),ye(x,v.shape));let k;o!=null&&(k=N(o,"prelu weights","fused matMul"));const I=(R,_)=>{const[D,F,P,L]=_,O=Tc(W(R,P.shape),P,a);let z,V;if(!t&&!s?(z=xe(O,F,!1,!0),V=xe(D,O,!0,!1)):!t&&s?(z=xe(O,F,!1,!1),V=xe(O,D,!0,!1)):t&&!s?(z=xe(F,O,!1,!0),V=xe(D,O,!1,!1)):(z=xe(F,O,!0,!0),V=xe(O,D,!0,!0)),r!=null){const U=Ec(L,O);return[z,V,U]}else return[z,V]},S={a:w,b:$,bias:v,preluActivationWeights:k},A={transposeA:t,transposeB:s,activation:a,leakyreluAlpha:i};return r==null?Jt((_,D,F)=>{const P=E.runKernel(wa,S,A);return F([_,D,P]),{value:W(P,x),gradFunc:I}})(w,$):Jt((_,D,F,P)=>{const L=E.runKernel(wa,S,A);return P([_,D,L,F]),{value:W(L,x),gradFunc:I}})(w,$,v)}const vm=T({fusedMatMul_:aC});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var oC=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",conv2d:wm,depthwiseConv2d:$m,matMul:vm});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iC(n){return xd(n,.54,.46)}const cC=T({hammingWindow_:iC});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lC(n){return xd(n,.5,.5)}const Cm=T({hannWindow_:lC});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uC(n,e,t,s=!1,r=0){let a=0;const o=[];for(;a+e<=n.size;)o.push(Ce(n,a,e)),a+=t;if(s)for(;a<n.size;){const i=a+e-n.size,c=rt([Ce(n,a,e-i),Pa([i],r)]);o.push(c),a+=t}return o.length===0?Ua([],[0,e]):W(rt(o),[o.length,e])}const Nm=T({frame_:uC});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dC(n,e,t,s,r=Cm){s==null&&(s=bm(e));const a=Nm(n,e,t),o=Q(a,r(e));return Ic(o,s)}const pC=T({stft_:dC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hC(n,e,t,s,r="bilinear",a=0){const o=N(n,"image","cropAndResize"),i=N(e,"boxes","cropAndResize","float32"),c=N(t,"boxInd","cropAndResize","int32"),l=i.shape[0];C(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),C(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${i.shape}.`),C(c.rank===1&&c.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${i.shape}.`),C(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),C(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),C(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const u={image:o,boxes:i,boxInd:c},d={method:r,extrapolationValue:a,cropSize:s};return E.runKernel(zo,u,d)}const fC=T({cropAndResize_:hC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mC(n){const e=N(n,"image","flipLeftRight","float32");C(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return E.runKernel(ei,t,{})}const gC=T({flipLeftRight_:mC});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yC(n){const e=N(n,"image","grayscaleToRGB"),t=e.rank-1,s=e.shape[t];C(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),C(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(e.rank);return r.fill(1,0,t),r[t]=3,Us(e,r)}const xC=T({grayscaleToRGB_:yC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bC(n,e,t=0,s=.5){const r=N(n,"image","rotateWithOffset","float32");C(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const a={image:r},o={radians:e,fillValue:t,center:s};return E.runKernel(sc,a,o)}const wC=T({rotateWithOffset_:bC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ys(n,e,t,s,r,a){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),a==null&&(a=0);const o=n.shape[0];return t=Math.min(t,o),C(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),C(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),C(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),C(e.rank===1,()=>"scores must be a 1D tensor"),C(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),C(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $C(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const a=N(n,"boxes","nonMaxSuppression","float32"),o=N(e,"scores","nonMaxSuppression","float32"),i=Ys(a,o,t,s,r);t=i.maxOutputSize,s=i.iouThreshold,r=i.scoreThreshold;const c={maxOutputSize:t,iouThreshold:s,scoreThreshold:r};return E.runKernel(xi,{boxes:a,scores:o},c)}const vC=T({nonMaxSuppression_:$C});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CC(n,e,t){const s=NC(n,e,t),r=s<0?-(s+1):s;n.splice(r,0,e)}function NC(n,e,t){return IC(n,e,t||kC)}function kC(n,e){return n>e?1:n<e?-1:0}function IC(n,e,t){let s=0,r=n.length,a=0,o=!1;for(;s<r;){a=s+(r-s>>>1);const i=t(e,n[a]);i>0?s=a+1:(r=a,o=!i)}return o?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ac(n,e,t,s,r){return bd(n,e,t,s,r,0)}function Dc(n,e,t,s,r,a){return bd(n,e,t,s,r,0,!1,a,!0)}function Fc(n,e,t,s,r,a){return bd(n,e,t,s,r,a,!0)}function bd(n,e,t,s,r,a,o=!1,i=!1,c=!1){const l=[];for(let g=0;g<e.length;g++)e[g]>r&&l.push({score:e[g],boxIndex:g,suppressBeginIndex:0});l.sort(km);const u=a>0?-.5/a:0,d=[],p=[];for(;d.length<t&&l.length>0;){const g=l.pop(),{score:y,boxIndex:x,suppressBeginIndex:w}=g;if(y<r)break;let $=!1;for(let v=d.length-1;v>=w;--v){const k=SC(n,x,d[v]);if(k>=s){$=!0;break}if(g.score=g.score*TC(s,u,k),g.score<=r)break}g.suppressBeginIndex=d.length,$||(g.score===y?(d.push(x),p.push(g.score)):g.score>r&&CC(l,g,km))}const h=d.length,f=t-h;i&&f>0&&(d.push(...new Array(f).fill(0)),p.push(...new Array(f).fill(0)));const m={selectedIndices:d};return o&&(m.selectedScores=p),c&&(m.validOutputs=h),m}function SC(n,e,t){const s=n.subarray(e*4,e*4+4),r=n.subarray(t*4,t*4+4),a=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),i=Math.max(s[0],s[2]),c=Math.max(s[1],s[3]),l=Math.min(r[0],r[2]),u=Math.min(r[1],r[3]),d=Math.max(r[0],r[2]),p=Math.max(r[1],r[3]),h=(i-a)*(c-o),f=(d-l)*(p-u);if(h<=0||f<=0)return 0;const m=Math.max(a,l),g=Math.max(o,u),y=Math.min(i,d),x=Math.min(c,p),w=Math.max(y-m,0)*Math.max(x-g,0);return w/(h+f-w)}function TC(n,e,t){const s=Math.exp(e*t*t);return t<=n?s:0}function km(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function EC(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const a=N(n,"boxes","nonMaxSuppressionAsync"),o=N(e,"scores","nonMaxSuppressionAsync"),i=Ys(a,o,t,s,r);t=i.maxOutputSize,s=i.iouThreshold,r=i.scoreThreshold;const c=await Promise.all([a.data(),o.data()]),l=c[0],u=c[1],{selectedIndices:d}=Ac(l,u,t,s,r);return a!==n&&a.dispose(),o!==e&&o.dispose(),Tt(d,"int32")}const RC=EC;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _C(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,a=0){const o=N(n,"boxes","nonMaxSuppression"),i=N(e,"scores","nonMaxSuppression"),c=Ys(o,i,t,s,r,a);t=c.maxOutputSize,s=c.iouThreshold,r=c.scoreThreshold,a=c.softNmsSigma;const l={boxes:o,scores:i},u={maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:a},d=E.runKernel(wi,l,u);return{selectedIndices:d[0],selectedScores:d[1]}}const AC=T({nonMaxSuppressionWithScore_:_C});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function DC(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,a=0){const o=N(n,"boxes","nonMaxSuppressionAsync"),i=N(e,"scores","nonMaxSuppressionAsync"),c=Ys(o,i,t,s,r,a);t=c.maxOutputSize,s=c.iouThreshold,r=c.scoreThreshold,a=c.softNmsSigma;const l=await Promise.all([o.data(),i.data()]),u=l[0],d=l[1],{selectedIndices:p,selectedScores:h}=Fc(u,d,t,s,r,a);return o!==n&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:Tt(p,"int32"),selectedScores:Tt(h)}}const FC=DC;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OC(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,a=!1){const o=N(n,"boxes","nonMaxSuppression"),i=N(e,"scores","nonMaxSuppression"),c=Ys(o,i,t,s,r,null),l=c.maxOutputSize,u=c.iouThreshold,d=c.scoreThreshold,p={boxes:o,scores:i},h={maxOutputSize:l,iouThreshold:u,scoreThreshold:d,padToMaxOutputSize:a},f=E.runKernel(bi,p,h);return{selectedIndices:f[0],validOutputs:f[1]}}const PC=T({nonMaxSuppressionPadded_:OC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function LC(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,a=!1){const o=N(n,"boxes","nonMaxSuppressionAsync"),i=N(e,"scores","nonMaxSuppressionAsync"),c=Ys(o,i,t,s,r,null),l=c.maxOutputSize,u=c.iouThreshold,d=c.scoreThreshold,[p,h]=await Promise.all([o.data(),i.data()]),{selectedIndices:f,validOutputs:m}=Dc(p,h,l,u,d,a);return o!==n&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:Tt(f,"int32"),validOutputs:pe(m,"int32")}}const BC=LC;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VC(n,e,t=!1,s=!1){const r=N(n,"images","resizeBilinear");C(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),C(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),C(s===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=r,o=!1;r.rank===3&&(o=!0,a=W(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const i={images:a},c={alignCorners:t,halfPixelCenters:s,size:e},l=E.runKernel(_i,i,c);return o?W(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const MC=T({resizeBilinear_:VC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WC(n,e,t=!1,s=!1){const r=N(n,"images","resizeNearestNeighbor");C(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),C(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),C(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),C(s===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=r,o=!1;r.rank===3&&(o=!0,a=W(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const i={images:a},c={alignCorners:t,halfPixelCenters:s,size:e},l=E.runKernel(Ri,i,c);return o?W(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const zC=T({resizeNearestNeighbor_:WC});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UC(n,e="binary",t=!1,s=.5){const r=N(n,"image","threshold"),a=.2989,o=.587,i=.114,c=r.shape[0]*r.shape[1];let l=Q(Tt([s]),255),u,d,p,h;if(C(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),C(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),C(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),C(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[u,d,p]=Ks(r,[1,1,1],-1);const g=Q(u,a),y=Q(d,o),x=Q(p,i);h=ie(ie(g,y),x)}else h=n;if(e==="otsu"){const g=Gu(ve(dd(h),"int32"),Qt([]),256);l=GC(g,c)}const f=t?wc(h,l):La(h,l);return ve(Q(f,255),"int32")}function GC(n,e){let t=Tt([-1]),s=Tt([0]),r=Tt([0]),a,o,i,c,l,u;for(let d=0;d<n.size-1;d++){a=Ce(n,0,d+1),o=Ce(n,d+1),l=Te(Ee(a),e),u=Te(Ee(o),e);const p=Ee(Q(a,js(0,a.size)));i=Te(p,Ee(a));const h=Pa(o.shape,a.size),f=ie(js(0,o.size),h),m=Q(o,f);c=Te(Ee(m),Ee(o));const g=de(i,c),y=de(i,c),x=Q(l,u);r=Q(Q(x,g),y);const w=La(r,s);s=fs(w,r,s),t=fs(w,Tt([d]),t)}return t}const HC=T({threshold_:UC});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qC(n,e,t="nearest",s="constant",r=0,a){const o=N(n,"image","transform","float32"),i=N(e,"transforms","transform","float32");C(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),C(i.rank===2&&(i.shape[0]===o.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),C(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);const c={image:o,transforms:i},l={interpolation:t,fillMode:s,fillValue:r,outputShape:a};return E.runKernel(Yi,c,l)}const jC=T({transform_:qC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KC(n,e,t){C(e%1==0,()=>`bandPart(): numLower must be an integer, got ${e}.`),C(t%1==0,()=>`bandPart(): numUpper must be an integer, got ${t}.`);const s=N(n,"a","bandPart");C(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[a,o]=s.shape.slice(-2);if(!(e<=a))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${a}).`);if(!(t<=o))throw new Error(`bandPart(): numUpper (${t}) must not be greater than the number of columns (${o}).`);e<0&&(e=a),t<0&&(t=o);const i=W(js(0,a,1,"int32"),[-1,1]),c=js(0,o,1,"int32"),l=de(i,c),u=Ba(wc(l,pe(+e,"int32")),Ku(l,pe(-t,"int32"))),d=Vn([a,o],s.dtype);return W(tn(Wn(W(s,[-1,a,o])).map(p=>fs(u,p,d))),r)}const XC=T({bandPart_:KC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YC(n){let e;if(Array.isArray(n)){e=!1,C(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let a=1;a<n.length;++a)C(n[a].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[a].shape[0]} vs. ${r})`)}else e=!0,n=Ks(n,n.shape[0],0).map(r=>Xs(r,[0]));C(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],s=n;for(let r=0;r<n.length;++r)t.push(E.tidy(()=>{let a=s[r];if(r>0)for(let o=0;o<r;++o){const i=Q(Ee(Q(t[o],a)),t[o]);a=de(a,i)}return Te(a,gd(a,"euclidean"))}));return e?tn(t,0):t}const QC=T({gramSchmidt_:YC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZC(n,e=!1){if(C(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return Im(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((c,l)=>c*l),s=Wn(W(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],a=[];s.forEach(c=>{const[l,u]=Im(c,e);r.push(l),a.push(u)});const o=W(tn(r,0),n.shape),i=W(tn(a,0),n.shape);return[o,i]}}function Im(n,e=!1){return E.tidy(()=>{C(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],s=n.shape[1];let r=Of(t),a=An(n);const o=Ua([[1]],[1,1]);let i=An(o);const c=t>=s?s:t;for(let l=0;l<c;++l){const u=a,d=i,p=r;[i,a,r]=E.tidy(()=>{const h=Ce(a,[l,l],[t-l,1]),f=gd(h),m=Ce(a,[l,l],[1,1]),g=fs(La(m,0),Ua([[-1]]),Ua([[1]])),y=de(m,Q(g,f)),x=Te(h,y);x.shape[0]===1?i=An(o):i=rt([o,Ce(x,[1,0],[x.shape[0]-1,x.shape[1]])],0);const w=mn(Te(xe(g,y),f)),$=Ce(a,[l,0],[t-l,s]),v=Q(w,i),k=_a(i);if(l===0)a=de($,xe(v,xe(k,$)));else{const A=de($,xe(v,xe(k,$)));a=rt([Ce(a,[0,0],[l,s]),A],0)}const I=_a(v),S=Ce(r,[0,l],[t,r.shape[1]-l]);if(l===0)r=de(S,xe(xe(S,i),I));else{const A=de(S,xe(xe(S,i),I));r=rt([Ce(r,[0,0],[t,l]),A],1)}return[i,a,r]}),ft([u,d,p])}return!e&&t>s&&(r=Ce(r,[0,0],[t,s]),a=Ce(a,[0,0],[s,s])),[r,a]})}const JC=T({qr_:ZC});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ct;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(ct||(ct={}));function eN(n,e,t=ct.SUM_BY_NONZERO_WEIGHTS){const s=N(n,"losses","computeWeightedLoss");let r=null;e!=null&&(r=N(e,"weights","computeWeightedLoss"));const a=r==null?s:Q(s,r);if(t===ct.NONE)return a;if(t===ct.SUM)return Ee(a);if(t===ct.MEAN){if(r==null)return Va(a);{const o=s.size/r.size,i=Te(Ee(a),Ee(r));return o>1?Te(i,pe(o)):i}}if(t===ct.SUM_BY_NONZERO_WEIGHTS){if(r==null)return Te(Ee(a),pe(s.size));{const o=Q(r,Mn(s.shape)),i=ve(Ee(rd(o,pe(0))),"float32");return Te(Ee(a),i)}}throw Error(`Unknown reduction: ${t}`)}const yn=T({computeWeightedLoss_:eN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tN(n,e,t,s=ct.SUM_BY_NONZERO_WEIGHTS){const r=N(n,"labels","absoluteDifference"),a=N(e,"predictions","absoluteDifference");let o=null;t!=null&&(o=N(t,"weights","absoluteDifference")),Ye(r.shape,a.shape,"Error in absoluteDifference: ");const i=wt(de(r,a));return yn(i,o,s)}const nN=T({absoluteDifference_:tN});function sN(n,e,t,s,r=ct.SUM_BY_NONZERO_WEIGHTS){const a=N(n,"labels","cosineDistance"),o=N(e,"predictions","cosineDistance");let i=null;s!=null&&(i=N(s,"weights","cosineDistance")),Ye(a.shape,o.shape,"Error in cosineDistance: ");const c=pe(1),l=de(c,Ee(Q(a,o),t,!0));return yn(l,i,r)}const rN=T({cosineDistance_:sN});function aN(n,e,t,s=ct.SUM_BY_NONZERO_WEIGHTS){let r=N(n,"labels","hingeLoss");const a=N(e,"predictions","hingeLoss");let o=null;t!=null&&(o=N(t,"weights","hingeLoss")),Ye(r.shape,a.shape,"Error in hingeLoss: ");const i=pe(1);r=de(Q(pe(2),r),i);const c=Wa(de(i,Q(r,a)));return yn(c,o,s)}const oN=T({hingeLoss_:aN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iN(n,e,t,s=1,r=ct.SUM_BY_NONZERO_WEIGHTS){const a=N(n,"labels","huberLoss"),o=N(e,"predictions","huberLoss");let i=null;t!=null&&(i=N(t,"weights","huberLoss")),Ye(a.shape,o.shape,"Error in huberLoss: ");const c=pe(s),l=wt(de(o,a)),u=sd(l,c),d=de(l,u),p=ie(Q(pe(.5),Lt(u)),Q(c,d));return yn(p,i,r)}const cN=T({huberLoss_:iN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lN(n,e,t,s=1e-7,r=ct.SUM_BY_NONZERO_WEIGHTS){const a=N(n,"labels","logLoss"),o=N(e,"predictions","logLoss");let i=null;t!=null&&(i=N(t,"weights","logLoss")),Ye(a.shape,o.shape,"Error in logLoss: ");const c=pe(1),l=pe(s),u=mn(Q(a,Gs(ie(o,l)))),d=Q(de(c,a),Gs(ie(de(c,o),l))),p=de(u,d);return yn(p,i,r)}const uN=T({logLoss_:lN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dN(n,e,t,s=ct.SUM_BY_NONZERO_WEIGHTS){const r=N(n,"labels","meanSquaredError"),a=N(e,"predictions","meanSquaredError");let o=null;t!=null&&(o=N(t,"weights","meanSquaredError")),Ye(r.shape,a.shape,"Error in meanSquaredError: ");const i=hd(r,a);return yn(i,o,s)}const pN=T({meanSquaredError_:dN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hN(n,e){const t=N(n,"labels","sigmoidCrossEntropyWithLogits"),s=N(e,"logits","sigmoidCrossEntropyWithLogits");Ye(t.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=Wa(s),a=Q(s,t),o=Yu(Ln(mn(wt(s))));return ie(de(r,a),o)}function fN(n,e,t,s=0,r=ct.SUM_BY_NONZERO_WEIGHTS){let a=N(n,"multiClassLabels","sigmoidCrossEntropy");const o=N(e,"logits","sigmoidCrossEntropy");let i=null;if(t!=null&&(i=N(t,"weights","sigmoidCrossEntropy")),Ye(a.shape,o.shape,"Error in sigmoidCrossEntropy: "),s>0){const l=pe(s),u=pe(1),d=pe(.5);a=ie(Q(a,de(u,l)),Q(d,l))}const c=hN(a,o);return yn(c,i,r)}const mN=T({sigmoidCrossEntropy_:fN});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gN(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return Jt((r,a,o)=>{const c=Uf(a,[t],!0),l=de(ve(a,"float32"),c);o([r,l]);const u=mn(Q(l,r));return{value:Ee(u,[t]),gradFunc:(h,f)=>{const[m,g]=f,y=He(h.shape,[t]);return[Q(W(h,y),de(ve(m,"float32"),Ln(g))),Q(W(h,y),de(Ln(g),ve(m,"float32")))]}}})(n,e)}function yN(n,e,t,s=0,r=ct.SUM_BY_NONZERO_WEIGHTS){let a=N(n,"onehotLabels","softmaxCrossEntropy");const o=N(e,"logits","softmaxCrossEntropy");let i=null;if(t!=null&&(i=N(t,"weights","softmaxCrossEntropy")),Ye(a.shape,o.shape,"Error in softmaxCrossEntropy: "),s>0){const l=pe(s),u=pe(1),d=pe(a.shape[1]);a=ie(Q(a,de(u,l)),Te(l,d))}const c=gN(a,o);return yn(c,i,r)}const xN=T({softmaxCrossEntropy_:yN});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bN(n,e,t,s){const r=N(n,"indices","sparseFillEmptyRows"),a=N(e,"values","sparseFillEmptyRows"),o=N(t,"denseShape","sparseFillEmptyRows"),i=N(s,"defaultValue","sparseFillEmptyRows",a.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(a.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);const c={indices:r,values:a,denseShape:o,defaultValue:i},l=E.runKernel(Mi,c);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}const wN=T({sparseFillEmptyRows_:bN});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $N(n,e,t){const s=N(n,"inputIndices","sparseReshape"),r=N(e,"inputShape","sparseReshape"),a=N(t,"newShape","sparseReshape");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(a.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const o={inputIndices:s,inputShape:r,newShape:a},i=E.runKernel(Wi,o);return{outputIndices:i[0],outputShape:i[1]}}const vN=T({sparseReshape_:$N});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CN(n,e,t){const s=N(n,"data","sparseSegmentMean"),r=N(e,"indices","sparseSegmentMean"),a=N(t,"segmentIds","sparseSegmentMean");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${a.shape}`);const o={data:s,indices:r,segmentIds:a};return E.runKernel(zi,o)}const NN=T({sparseSegmentMean_:CN});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kN(n,e,t){const s=N(n,"data","sparseSegmentSum"),r=N(e,"indices","sparseSegmentSum"),a=N(t,"segmentIds","sparseSegmentSum");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${a.shape}`);const o={data:s,indices:r,segmentIds:a};return E.runKernel(Ui,o)}const IN=T({sparseSegmentSum_:kN});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SN(n,e,t,s,r,a,o,i){const c=N(n,"data","stringNGrams","string");if(c.dtype!=="string")throw new Error("Data must be of datatype string");if(c.shape.length!==1)throw new Error(`Data must be a vector, saw: ${c.shape}`);const l=N(e,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const u={separator:t,nGramWidths:s,leftPad:r,rightPad:a,padWidth:o,preserveShortSequences:i},d={data:c,dataSplits:l},p=E.runKernel(qi,d,u);return{nGrams:p[0],nGramsSplits:p[1]}}const TN=T({stringNGrams_:SN});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EN(n,e,t=!0){const s=N(n,"input","stringSplit","string"),r=N(e,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const a={skipEmpty:t},o={input:s,delimiter:r},i=E.runKernel(ji,o,a);return{indices:i[0],values:i[1],shape:i[2]}}const RN=T({stringSplit_:EN});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _N(n,e){const t=N(n,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:t};return E.runKernel(Ki,r,s)}const AN=T({stringToHashBucketFast_:_N});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DN={fft:kc,ifft:za,rfft:Ic,irfft:pd},FN={hammingWindow:cC,hannWindow:Cm,frame:Nm,stft:pC},ys={flipLeftRight:gC,grayscaleToRGB:xC,resizeNearestNeighbor:zC,resizeBilinear:MC,rotateWithOffset:wC,cropAndResize:fC,nonMaxSuppression:vC,nonMaxSuppressionAsync:RC,nonMaxSuppressionWithScore:AC,nonMaxSuppressionWithScoreAsync:FC,nonMaxSuppressionPadded:PC,nonMaxSuppressionPaddedAsync:BC,threshold:HC,transform:jC},ON={bandPart:XC,gramSchmidt:QC,qr:JC},PN={absoluteDifference:nN,computeWeightedLoss:yn,cosineDistance:rN,hingeLoss:oN,huberLoss:cN,logLoss:uN,meanSquaredError:pN,sigmoidCrossEntropy:mN,softmaxCrossEntropy:xN},Ga={sparseFillEmptyRows:wN,sparseReshape:vN,sparseSegmentMean:NN,sparseSegmentSum:IN},Oc={stringNGrams:TN,stringSplit:RN,stringToHashBucketFast:AN};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zn extends ef{minimize(e,t=!1,s){const{value:r,grads:a}=this.computeGradients(e,s);if(s!=null){const o=s.map(i=>({name:i.name,tensor:a[i.name]}));this.applyGradients(o)}else this.applyGradients(a);return ft(a),t?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return Mf(e,t)}dispose(){this.iterations_!=null&&ft(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:pe(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(zn,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pc extends zn{constructor(e,t,s=null){super();this.learningRate=e,this.rho=t,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=E.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const a=E.registeredVariables[s],o=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:ce(()=>$t(a).variable(o))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:ce(()=>$t(a).variable(o))});const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const c=this.accumulatedGrads[r].variable,l=this.accumulatedUpdates[r].variable;ce(()=>{const u=ie(Q(c,this.rho),Q(Lt(i),1-this.rho)),d=Q(Te(en(ie(l,this.epsilon)),en(ie(c,this.epsilon))),i),p=ie(Q(l,this.rho),Q(Lt(d),1-this.rho));c.assign(u),l.assign(p);const h=ie(Q(d,-this.learningRate),a);a.assign(h)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(ft(this.accumulatedGrads.map(e=>e.variable)),ft(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}Pc.className="Adadelta";Fn(Pc);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lc extends zn{constructor(e,t=.1){super();this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const a=E.registeredVariables[s];if(this.accumulatedGrads[r]==null){const c=!1;this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:ce(()=>Pa(a.shape,this.initialAccumulatorValue).variable(c))}}const o=Array.isArray(e)?e[r].tensor:e[s];if(o==null)return;const i=this.accumulatedGrads[r].variable;ce(()=>{const c=ie(i,Lt(o));i.assign(c);const l=ie(Q(Te(o,en(ie(c,E.backend.epsilon()))),-this.learningRate),a);a.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&ft(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}Lc.className="Adagrad";Fn(Lc);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bc extends zn{constructor(e,t,s,r=null){super();this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],ce(()=>{this.accBeta1=pe(t).variable(),this.accBeta2=pe(s).variable()}),r==null&&(this.epsilon=E.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);ce(()=>{const s=de(1,this.accBeta1),r=de(1,this.accBeta2);t.forEach((a,o)=>{const i=E.registeredVariables[a],c=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${a}/m`,variable:ce(()=>$t(i).variable(c))}),this.accumulatedSecondMoment[o]==null&&(this.accumulatedSecondMoment[o]={originalName:`${a}/v`,variable:ce(()=>$t(i).variable(c))});const l=Array.isArray(e)?e[o].tensor:e[a];if(l==null)return;const u=this.accumulatedFirstMoment[o].variable,d=this.accumulatedSecondMoment[o].variable,p=ie(Q(u,this.beta1),Q(l,1-this.beta1)),h=ie(Q(d,this.beta2),Q(Lt(l),1-this.beta2)),f=Te(p,s),m=Te(h,r);u.assign(p),d.assign(h);const g=ie(Q(Te(f,ie(en(m),this.epsilon)),-this.learningRate),i);i.assign(g)}),this.accBeta1.assign(Q(this.accBeta1,this.beta1)),this.accBeta2.assign(Q(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&ft(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&ft(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),ce(()=>{this.accBeta1.assign(qs(this.beta1,this.iterations_+1)),this.accBeta2.assign(qs(this.beta2,this.iterations_+1))});const t=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}Bc.className="Adam";Fn(Bc);/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/class Vc extends zn{constructor(e,t,s,r=null,a=0){super();this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=r,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],ce(()=>{this.iteration=pe(0).variable(),this.accBeta1=pe(t).variable()}),r==null&&(this.epsilon=E.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);ce(()=>{const s=de(1,this.accBeta1),r=Te(-this.learningRate,ie(Q(this.iteration,this.decay),1));t.forEach((a,o)=>{const i=E.registeredVariables[a],c=!1;this.accumulatedFirstMoment[o]==null&&(this.accumulatedFirstMoment[o]={originalName:`${a}/m`,variable:$t(i).variable(c)}),this.accumulatedWeightedInfNorm[o]==null&&(this.accumulatedWeightedInfNorm[o]={originalName:`${a}/v`,variable:$t(i).variable(c)});const l=Array.isArray(e)?e[o].tensor:e[a];if(l==null)return;const u=this.accumulatedFirstMoment[o].variable,d=this.accumulatedWeightedInfNorm[o].variable,p=ie(Q(u,this.beta1),Q(l,1-this.beta1)),h=Q(d,this.beta2),f=wt(l),m=nd(h,f);u.assign(p),d.assign(m);const g=ie(Q(Te(r,s),Te(p,ie(m,this.epsilon))),i);i.assign(g)}),this.iteration.assign(ie(this.iteration,1)),this.accBeta1.assign(Q(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&ft(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&ft(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}Vc.className="Adamax";Fn(Vc);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ha extends zn{constructor(e){super();this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const a=Array.isArray(e)?e[r].tensor:e[s];if(a==null)return;const o=E.registeredVariables[s];ce(()=>{const i=ie(Q(this.c,a),o);o.assign(i)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Zt(pe(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}Ha.className="SGD";Fn(Ha);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mc extends Ha{constructor(e,t,s=!1){super(e);this.learningRate=e,this.momentum=t,this.useNesterov=s,this.accumulations=[],this.m=pe(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const a=E.registeredVariables[s];if(this.accumulations[r]==null){const c=!1;this.accumulations[r]={originalName:`${s}/momentum`,variable:ce(()=>$t(a).variable(c))}}const o=this.accumulations[r].variable,i=Array.isArray(e)?e[r].tensor:e[s];i!=null&&ce(()=>{let c;const l=ie(Q(this.m,o),i);this.useNesterov?c=ie(Q(this.c,ie(i,Q(l,this.m))),a):c=ie(Q(this.c,l),a),o.assign(l),a.assign(c)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&ft(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}Mc.className="Momentum";Fn(Mc);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wc extends zn{constructor(e,t=.9,s=0,r=null,a=!1){super();if(this.learningRate=e,this.decay=t,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,r==null&&(this.epsilon=E.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(s=>s.name):Object.keys(e)).forEach((s,r)=>{const a=E.registeredVariables[s],o=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:ce(()=>$t(a).variable(o))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:ce(()=>$t(a).variable(o))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:ce(()=>$t(a).variable(o))});const i=Array.isArray(e)?e[r].tensor:e[s];if(i==null)return;const c=this.accumulatedMeanSquares[r].variable,l=this.accumulatedMoments[r].variable;ce(()=>{const u=ie(Q(c,this.decay),Q(Lt(i),1-this.decay));if(this.centered){const d=this.accumulatedMeanGrads[r].variable,p=ie(Q(d,this.decay),Q(i,1-this.decay)),h=Te(Q(i,this.learningRate),en(de(u,ie(Lt(p),this.epsilon)))),f=ie(Q(l,this.momentum),h);c.assign(u),d.assign(p),l.assign(f);const m=de(a,f);a.assign(m)}else{const d=ie(Q(c,this.decay),Q(Lt(i),1-this.decay)),p=ie(Q(l,this.momentum),Te(Q(i,this.learningRate),en(ie(d,this.epsilon))));c.assign(d),l.assign(p);const h=de(a,p);a.assign(h)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&ft(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&ft(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&ft(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,t).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=e.slice(t,t*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}Wc.className="RMSProp";Fn(Wc);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Un{static sgd(e){return new Ha(e)}static momentum(e,t,s=!1){return new Mc(e,t,s)}static rmsprop(e,t=.9,s=0,r=null,a=!1){return new Wc(e,t,s,r,a)}static adam(e=.001,t=.9,s=.999,r=null){return new Bc(e,t,s,r)}static adadelta(e=.001,t=.95,s=null){return new Pc(e,t,s)}static adamax(e=.002,t=.9,s=.999,r=null,a=0){return new Vc(e,t,s,r,a)}static adagrad(e,t=.1){return new Lc(e,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LN={sgd:Un.sgd,momentum:Un.momentum,adadelta:Un.adadelta,adagrad:Un.adagrad,rmsprop:Un.rmsprop,adamax:Un.adamax,adam:Un.adam};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BN=(()=>typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:n=>n())();function VN(){return new Promise(n=>BN(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wd(n,e){const t=n[0].length;n.forEach((r,a)=>{C(r.length===t,()=>`Error in concat${t}D: rank of tensors[${a}] must be the same as the rank of the rest (${t})`)}),C(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const s=n[0];n.forEach((r,a)=>{for(let o=0;o<t;o++)C(o===e||r[o]===s[o],()=>`Error in concat${t}D: Shape of tensors[${a}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${a}.`)})}function nn(n,e){const t=n[0].slice();for(let s=1;s<n.length;s++)t[e]+=n[s][e];return t}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $d=30;function zc(n){return n<=$d?n:wo(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vd(n,e,t){const s=t*(typeof n=="number"?n:n[0]),r=e*(typeof n=="number"?n:n[1]);return[s,r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qa(n,e,t,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(n[0]/t),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const a=e.length;for(let o=0;o<a;++o)r=r.concat([n[o+1]/e[o],e[o]]);r=r.concat(n.slice(a+1))}return r}function ja(n,e,t=!0){const s=[];if(t){s.push(e);for(let r=e+1;r<n;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],a=[];for(let o=1;o<n;++o)o>=e*2+1||o%2==1?a.push(o):r.push(o);s.push(...r),s.push(0),s.push(...a)}return s}function Ka(n,e,t,s=!0){const r=[];s?r.push(n[0]/t):r.push(n[0]*t);for(let a=1;a<n.length;++a)a<=e.length?s?r.push(e[a-1]*n[a]):r.push(n[a]/e[a-1]):r.push(n[a]);return r}function Cd(n,e){const t=[0];for(let s=0;s<e;++s)t.push(n[s][0]);return t}function Nd(n,e,t){const s=n.slice(0,1);for(let r=0;r<t;++r)s.push(n[r+1]-e[r][0]-e[r][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kd=1.7580993408473768,Id=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sd=.3275911,Td=.254829592,Ed=-.284496736,Rd=1.421413741,_d=-1.453152027,Ad=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xn(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let s=0;s<t.length;s+=2)t[s]=n[s/2],t[s+1]=e[s/2];return t}function Sm(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)e[s/2]=n[s],t[s/2]=n[s+1];return{real:e,imag:t}}function Tm(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function Em(n){const e=Math.floor(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function Dd(n,e){const t=n[e*2],s=n[e*2+1];return{real:t,imag:s}}function Rm(n,e,t,s){n[s*2]=e,n[s*2+1]=t}function _m(n,e){const t=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const a=(e?2:-2)*Math.PI*(r/n);t[r]=Math.cos(a),s[r]=Math.sin(a)}return{real:t,imag:s}}function Am(n,e,t){const s=(t?2:-2)*Math.PI*(n/e),r=Math.cos(s),a=Math.sin(s);return{real:r,imag:a}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fd="->",MN=/->/g,Dm=",",Fm="...";function Od(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(MN,"").length)/Fd.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${Fd}").`);const[s,r]=n.split(Fd);C(s.indexOf(Fm)===-1,()=>`The ellipsis notation ("${Fm}") is not supported yet.`);const a=s.split(Dm),o=a.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let p=0;p<r.length;++p){const h=r[p];if(!a.some(f=>f.indexOf(h)!==-1))throw new Error(`Output subscripts contain the label ${h} not present in the input subscripts.`);i.indexOf(h)===-1&&i.push(h)}for(let p=0;p<s.length;++p){const h=s[p];i.indexOf(h)===-1&&h!==Dm&&i.push(h)}const c=new Array(a.length);for(let p=0;p<o;++p){if(new Set(a[p].split("")).size!==a[p].length)throw new Error(`Found duplicate axes in input component ${a[p]}. Support for duplicate axes in input is not implemented yet.`);c[p]=[];for(let h=0;h<a[p].length;++h)c[p].push(i.indexOf(a[p][h]))}const l=i.length,u=r.length,d=[];for(let p=u;p<l;++p)d.push(p);return{allDims:i,summedDims:d,idDims:c}}function Pd(n,e){let t=new Array(n);t.fill(-1);for(let r=0;r<e.length;++r)t[e[r]]=r;const s=[];for(let r=0;r<n;++r)t[r]===-1&&s.push(r);return t=t.filter(r=>r!==-1),{permutationIndices:t,expandDims:s}}function Ld(n,e,t){const s=new Array(n);for(let r=0;r<t.length;++r){const a=t[r].shape;for(let o=0;o<e[r].length;++o)s[e[r][o]]===void 0?s[e[r][o]]=a[o]:C(s[e[r][o]]===a[o],()=>`Expected dimension ${s[e[r][o]]} at axis ${o} of input shaped ${JSON.stringify(a)}, but got dimension ${a[o]}`)}}function Bd(n,e){const t=n,s=[];let r=0;n.length===0&&t.push(-1),r=n.length+1;for(let o=0;o<r;++o)s.push([]);const a=[];for(let o=0;o<t.length;++o){const i=t[o],c=WN(e,i);for(const l of c)a.indexOf(l)===-1&&(s[o].push(l),a.push(l))}return{path:t,steps:s}}function Vd(n){return n.every((e,t)=>e===t)}function WN(n,e){const t=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(e)!==-1||e===-1)&&t.push(s);return t}function Md(n,e,t=0){let s=[];if(typeof e=="number")C(n.shape[t]%e==0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(n.shape[t]/e);else{const r=e.reduce((o,i)=>(i===-1&&(o+=1),o),0);C(r<=1,()=>"There should be only one negative value in split array.");const a=e.indexOf(-1);if(a!==-1){const o=e.reduce((i,c)=>c>0?i+c:i);e[a]=n.shape[t]-o}C(n.shape[t]===e.reduce((o,i)=>o+i),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Om(n,e){let t=!1,s;for(n<=$d?(s=n,t=!0):s=wo(n,Math.floor(Math.sqrt(n)));!t;)s>e||s===n?t=!0:s=wo(n,s+1);return s}function Pm(n,e,t){const s=[],r=n.length;for(let a=0;a<r;a++)a!==e?s.push(n[a]):s.push(t);return s}function Wd(n,e,t,s){const r=e.shape.length,a=n.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>a)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${a}).`);if(t<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${t}).`);for(let d=0;d<s;++d)if(n.shape[d]!==e.shape[d])throw new Error(`x.shape[${d}]: ${n.shape[d]} should be equal to indices.shape[${d}]: ${e.shape[d]}.`);const o=n.shape[t],i=[];let c=1,l=1,u=1;for(let d=0;d<s;++d)i.push(n.shape[d]),c*=n.shape[d];for(let d=s;d<t;d++)i.push(n.shape[d]),l*=n.shape[d];for(let d=s;d<r;d++)i.push(e.shape[d]);for(let d=t+1;d<a;d++)i.push(n.shape[d]),u*=n.shape[d];return{batchSize:c,sliceSize:u,outerSize:l,dimSize:o,outputShape:i}}var zN=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",segOpComputeOptimalWindowSize:Om,computeOutShape:Pm,collectGatherOpShapeInfo:Wd});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xs(n){try{return n.map(e=>os(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function Lm(n){return n.map(e=>Kt(e))}var Bm=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",slice_util:Jh,segment_util:zN,fromUint8ToStringArray:xs,fromStringArrayToUint8:Lm,upcastType:xt,axesAreInnerMostDims:Zu,combineLocations:zf,computeOutAndReduceShapes:Ze,expandShapeToKeepDim:He,assertAxesAreInnerMostDims:Je,getAxesPermutation:Me,getUndoAxesPermutation:vc,getInnerMostAxes:We,getBroadcastDims:zs,getReductionAxes:Rf,assertAndGetBroadcastShape:ye,assertParamsConsistent:wd,computeOutShape:nn,computeDilation2DInfo:Aa,computePool2DInfo:Pt,computePool3DInfo:hn,computeConv2DInfo:je,computeConv3DInfo:Pn,computeDefaultPad:Mu,tupleValuesAreOne:Da,eitherStridesOrDilationsAreOne:st,convertConv2DDataFormat:fn,getFusedDyActivation:Tc,getFusedBiasGradient:Ec,applyActivation:Rc,shouldFuse:_c,PARALLELIZE_THRESHOLD:$d,computeOptimalWindowSize:zc,getImageCenter:vd,getReshaped:qa,getPermuted:ja,getReshapedPermuted:Ka,getSliceBeginCoords:Cd,getSliceSize:Nd,prepareAndValidate:fc,validateUpdateShape:Iu,validateInput:Su,calculateShapes:Vs,SELU_SCALEALPHA:kd,SELU_SCALE:Id,ERF_P:Sd,ERF_A1:Td,ERF_A2:Ed,ERF_A3:Rd,ERF_A4:_d,ERF_A5:Ad,warn:ht,log:sb,mergeRealAndImagArrays:xn,splitRealAndImagArrays:Sm,complexWithEvenIndex:Tm,complexWithOddIndex:Em,getComplexWithIndex:Dd,assignToTypedArray:Rm,exponents:_m,exponent:Am,decodeEinsumEquation:Od,getEinsumPermutation:Pd,checkEinsumDimSizes:Ld,getEinsumComputePath:Bd,isIdentityPermutation:Vd,prepareSplitSize:Md});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var UN=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",nonMaxSuppressionV3Impl:Ac,nonMaxSuppressionV4Impl:Dc,nonMaxSuppressionV5Impl:Fc,whereImpl:Sc});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var GN=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",OptimizerConstructors:Un,AdadeltaOptimizer:Pc,AdagradOptimizer:Lc,AdamOptimizer:Bc,AdamaxOptimizer:Vc,MomentumOptimizer:Mc,Optimizer:zn,RMSPropOptimizer:Wc,SGDOptimizer:Ha,Tensor:Ve,TensorBuffer:Ge,Variable:Ta,get Rank(){return nu},sumOutType:uc,upcastType:xt,get Reduction(){return ct},customGrad:Jt,grad:$$,grads:v$,valueAndGrad:C$,valueAndGrads:N$,variableGrads:Mf,Environment:Jp,env:M,get ENV(){return Fl},nextFrame:VN,KernelBackend:yo,DataStorage:Il,abs:wt,acos:sf,acosh:rf,add:ie,addN:af,all:of,any:cf,argMax:lf,argMin:uf,asin:df,asinh:pf,atan:hf,atan2:ff,atanh:mf,avgPool:zu,avgPool3d:gf,basicLSTMCell:rw,batchToSpaceND:Uu,batchNorm:Ws,batchNorm2d:lw,batchNorm3d:dw,batchNorm4d:hw,bincount:Gu,broadcastArgs:yf,broadcastTo:Fa,buffer:ue,cast:ve,ceil:xf,clipByValue:bf,clone:An,complex:En,concat:rt,concat1d:ww,concat2d:vw,concat3d:Nw,concat4d:Iw,conv1d:wf,conv2d:Oa,conv2dTranspose:vf,conv3d:Cf,conv3dTranspose:Ow,cos:Nf,cosh:kf,cumsum:If,denseBincount:Sf,depthToSpace:Tf,depthwiseConv2d:yc,diag:Uw,dilation2d:Ef,div:Te,divNoNan:_f,dot:Yw,einsum:Af,elu:qu,equal:Hu,erf:Df,exp:Ln,expandDims:Bn,expm1:Ff,eye:Of,fill:Pa,floor:ju,floorDiv:Vu,gather:xc,greater:La,greaterEqual:Ku,imag:bc,isFinite:d$,isInf:h$,isNaN:Pf,leakyRelu:Xu,less:Lf,lessEqual:wc,linspace:Bf,localResponseNormalization:Vf,log:Gs,log1p:Yu,logSigmoid:T$,logSoftmax:Wf,logSumExp:Uf,logicalAnd:Ba,logicalNot:Ju,logicalOr:ed,logicalXor:B$,matMul:xe,max:ms,maxPool:td,maxPool3d:Gf,maxPoolWithArgmax:Hf,maximum:nd,mean:Va,meshgrid:G$,min:Cc,minimum:sd,mirrorPad:qf,mod:jf,moments:Q$,mul:Q,multiRNNCell:J$,multinomial:Kf,neg:mn,notEqual:rd,oneHot:hc,ones:Mn,onesLike:Xf,outerProduct:rv,pad:Hs,pad1d:iv,pad2d:lv,pad3d:dv,pad4d:hv,pool:xv,pow:qs,prelu:od,print:Ph,prod:id,rand:Cv,randomGamma:Dv,randomNormal:Ov,randomUniform:ld,range:js,real:Ma,reciprocal:sm,relu:Wa,relu6:ud,reshape:W,reverse:gn,reverse1d:Uv,reverse2d:Hv,reverse3d:jv,reverse4d:Xv,round:dd,rsqrt:rm,scalar:pe,selu:am,separableConv2d:e2,setdiff1dAsync:om,sigmoid:hs,sign:im,sin:cm,sinh:lm,slice:Ce,slice1d:o2,slice2d:c2,slice3d:u2,slice4d:p2,softmax:um,softplus:Qu,spaceToBatchND:ad,fft:kc,ifft:za,irfft:pd,rfft:Ic,split:Ks,sqrt:en,square:Lt,squaredDifference:hd,squeeze:Xs,stack:tn,step:dm,stridedSlice:pm,sub:de,sum:Ee,tan:hm,tanh:gc,tensor:Qt,tensor1d:Tt,tensor2d:Ua,tensor3d:zh,tensor4d:I2,tensor5d:S2,tensor6d:T2,tile:Us,topk:fm,truncatedNormal:mm,unique:fd,unsortedSegmentSum:D2,unstack:Wn,variable:O2,where:fs,whereAsync:md,zeros:Vn,zerosLike:$t,op:T,OP_SCOPE_SUFFIX:Ch,booleanMaskAsync:B2,transpose:_a,norm:gd,movingAverage:W2,scatterND:ym,sparseToDense:yd,gatherND:xm,dropout:K2,enclosingPowerOfTwo:bm,cosineWindow:xd,inTopKAsync:Y2,image:ys,linalg:ON,losses:PN,spectral:DN,fused:oC,signal:FN,sparse:Ga,string:Oc,train:LN,enableProdMode:h1,enableDebugMode:f1,disableDeprecationWarnings:m1,deprecationWarn:g1,disposeVariables:y1,engine:On,memory:x1,profile:b1,tidy:ce,dispose:ft,keep:Zt,time:w1,setBackend:$1,ready:v1,getBackend:C1,removeBackend:N1,findBackend:k1,findBackendFactory:I1,registerBackend:Bu,backend:S1,setPlatform:T1,getKernel:rc,getGradient:Xl,getKernelsForBackend:ac,registerKernel:oc,registerGradient:pb,unregisterKernel:hb,unregisterGradient:fb,copyRegisteredKernels:mb,Abs:$o,Acos:yr,Acosh:xr,Add:_s,AddN:vo,All:Co,Any:No,ArgMax:ko,ArgMin:Io,Asin:br,Asinh:wr,Atan:$r,Atanh:vr,Atan2:Cr,AvgPool:So,AvgPoolGrad:Ll,AvgPool3D:To,AvgPool3DGrad:Bl,BatchMatMul:Eo,BatchToSpaceND:Ro,Bincount:_o,BroadcastTo:lb,BroadcastArgs:Ao,Cast:Nr,Ceil:kr,ClipByValue:Ir,Complex:Do,ComplexAbs:Fo,Concat:Oo,Conv2D:Po,Conv2DBackpropFilter:Lo,Conv2DBackpropInput:Bo,Conv3D:Vo,Conv3DBackpropFilterV2:Vl,Conv3DBackpropInputV2:Mo,Cos:Sr,Cosh:Tr,Cumsum:Wo,CropAndResize:zo,DenseBincount:Uo,DepthToSpace:Go,DepthwiseConv2dNative:Ho,DepthwiseConv2dNativeBackpropFilter:qo,DepthwiseConv2dNativeBackpropInput:jo,Diag:Ko,Dilation2D:Xo,Dilation2DBackpropInput:Ml,Dilation2DBackpropFilter:Wl,RealDiv:Er,Einsum:Yo,Elu:Rr,EluGrad:zl,Erf:_r,Equal:Ar,Exp:Dr,ExpandDims:Qo,Expm1:Fr,FFT:Zo,Fill:Jo,FlipLeftRight:ei,Floor:Or,FloorDiv:Pr,FusedBatchNorm:ti,GatherV2:ni,GatherNd:si,Greater:Lr,GreaterEqual:Br,Identity:Vr,IFFT:ri,Imag:ai,IsFinite:Mr,IsInf:Wr,IsNan:zr,LeakyRelu:oi,Less:Ur,LessEqual:Gr,LinSpace:ii,Log:Hr,Log1p:qr,LogicalAnd:jr,LogicalNot:Kr,LogicalOr:Xr,LogSoftmax:ub,LRN:ci,LRNGrad:Ul,Max:li,Maximum:Yr,MaxPool:ui,MaxPoolGrad:Gl,MaxPool3D:di,MaxPool3DGrad:Hl,MaxPoolWithArgmax:pi,Mean:hi,Min:fi,Minimum:Qr,MirrorPad:mi,Mod:Zr,Multinomial:gi,Multiply:Jr,Neg:yi,NotEqual:ea,NonMaxSuppressionV3:xi,NonMaxSuppressionV4:bi,NonMaxSuppressionV5:wi,OnesLike:$i,OneHot:vi,Pack:Ci,PadV2:Ni,Pool:db,Pow:ta,Prelu:ki,Prod:Ii,Range:Si,Real:Ti,Reciprocal:na,Relu:sa,Reshape:Ei,ResizeNearestNeighbor:Ri,ResizeNearestNeighborGrad:ql,ResizeBilinear:_i,ResizeBilinearGrad:jl,Relu6:ra,Reverse:Ai,Round:aa,Rsqrt:oa,ScatterNd:Di,Select:Fi,Selu:ia,Slice:Oi,Sin:ca,Sinh:la,Sign:ua,Sigmoid:da,Softplus:pa,Sqrt:ha,Sum:Pi,SpaceToBatchND:Li,SplitV:Bi,Softmax:Vi,SparseFillEmptyRows:Mi,SparseReshape:Wi,SparseSegmentMean:zi,SparseSegmentSum:Ui,SparseToDense:Gi,SquaredDifference:fa,Square:Kl,StridedSlice:Hi,StringNGrams:qi,StringSplit:ji,StringToHashBucketFast:Ki,Sub:ma,Tan:ga,Tanh:ya,Tile:xa,TopK:Xi,Transform:Yi,Transpose:Qi,Unique:Zi,Unpack:Ji,UnsortedSegmentSum:ec,ZerosLike:tc,Step:ba,FromPixels:nc,RotateWithOffset:sc,_FusedMatMul:wa,FusedConv2D:$a,FusedDepthwiseConv2D:va,version_core:p1,browser:Y0,io:P0,math:z0,serialization:s1,test_util:d1,util:Nb,backend_util:Bm,tensor_util:Bb,slice_util:Jh,gather_util:Q0,scatter_util:Z0,device_util:Ub,kernel_impls:UN});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function te(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&C(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HN=Sc;class Uc extends yo{constructor(){super();this.blockSize=48,this.firstUse=!0,this.data=new Il(this,On())}nextDataId(){return Uc.nextDataId++}write(e,t,s){this.firstUse&&(this.firstUse=!1,M().get("IS_NODE")&&ht(`
============================
Hi there \u{1F44B}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.
============================`));const r={id:this.nextDataId()};return this.data.set(r,{values:e,dtype:s,refCount:1}),r}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&jt(s[0])){const a=s.map(o=>Kt(o));r=this.write(a,e,t)}else r=this.write(s,e,t);return{dataId:r,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,s,r,a){this.data.set(e,{values:t,dtype:r,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:s}=this.data.get(e);if(t==="complex64"){const r=this.readSync(s.real.dataId),a=this.readSync(s.imag.dataId);return xn(r,a)}return this.data.get(e).values}bufferSync(e){const t=this.readSync(e.dataId);let s=t;if(e.dtype==="string")try{s=t.map(r=>os(r))}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ue(e.shape,e.dtype,s)}makeOutput(e,t,s){const r=this.write(e,t,s);return On().makeTensorFromDataId(r,t,s,this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=yt();return e(),{kernelMs:yt()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){te([e],"where");const t=this.readSync(e.dataId);return HN(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}Uc.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vm(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const qN=n=>{const{x:e}=n.inputs,t=n.backend;te(e,"abs");let s=new Float32Array(B(e.shape));const r=t.data.get(e.dataId).values;return s=Vm(r),t.makeOutput(s,e.shape,e.dtype)},jN={kernelName:$o,backendName:"cpu",kernelFunc:qN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ze(n){return(e,t,s,r,a)=>{const o=ye(e,t),i=o.length,c=se(o),l=B(o),u=Ue(a,l),d=e.length,p=t.length,h=se(e),f=se(t),m=zs(e,o),g=zs(t,o);if(m.length+g.length===0)for(let y=0;y<u.length;++y)u[y]=n(s[y%s.length],r[y%r.length]);else for(let y=0;y<u.length;++y){const x=Es(y,i,c),w=x.slice(-d);m.forEach(I=>w[I]=0);const $=Wt(w,d,h),v=x.slice(-p);g.forEach(I=>v[I]=0);const k=Wt(v,p,f);u[y]=n(s[$],r[k])}return[u,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vt(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,a=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,i=t.makeTensorInfo(s.shape,"complex64"),c=t.data.get(i.dataId);return c.complexTensorInfos={real:t.makeTensorInfo(s.shape,"float32",a),imag:t.makeTensorInfo(r.shape,"float32",o)},i}const KN={kernelName:Do,backendName:"cpu",kernelFunc:vt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gc(n,e,t="float32"){if(t==="complex64"){const r=Gc(n,e,"float32"),a=Gc(n,e,"float32");return vt({inputs:{real:r,imag:a},backend:n})}const s=Qe(B(e),t);return n.makeTensorInfo(e,t,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sn(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const XN={kernelName:Vr,backendName:"cpu",kernelFunc:sn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bs(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.real,a=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,a)}const YN={kernelName:Ti,backendName:"cpu",kernelFunc:bs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gn(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:a}=s;if(a==="complex64"){if(r.dtype==="complex64")return sn({inputs:{x:r},backend:t});const o=Gc(t,r.shape,r.dtype),i=Gn({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),c=vt({inputs:{real:i,imag:o},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),c}if(r.dtype==="complex64"){const o=bs({inputs:{input:r},backend:t}),i=Gn({inputs:{x:o},backend:t,attrs:{dtype:a}});return t.disposeIntermediateTensorInfo(o),i}if(!Rl(r.dtype,a)){const o=sn({inputs:{x:r},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:a}}if(a==="int32"){const o=t.data.get(r.dataId).values,i=Int32Array.from(o);return t.makeTensorInfo(r.shape,"int32",i)}if(a==="bool"){const o=t.data.get(r.dataId).values,i=Tn([0],r.dtype),[c,l]=ze((u,d)=>u!==d?1:0)(r.shape,[],o,i,"bool");return t.makeTensorInfo(l,"bool",c)}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${a}`)}const QN={kernelName:Nr,backendName:"cpu",kernelFunc:Gn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ke(n,e,t,s){return t==null?({inputs:r,backend:a})=>{const{a:o,b:i}=r,c=a;te([o,i],n);const l=c.data.get(o.dataId).values,u=c.data.get(i.dataId).values,d=o.dtype==="string"?xs(l):l,p=o.dtype==="string"?xs(u):u,h=s||o.dtype,[f,m]=e(o.shape,i.shape,d,p,h);return c.makeTensorInfo(m,h,f)}:({inputs:r,backend:a})=>{const{a:o,b:i}=r,c=a;if(o.dtype==="complex64"||i.dtype==="complex64"){const l=Gn({inputs:{x:o},backend:c,attrs:{dtype:"complex64"}}),u=c.data.get(l.dataId),d=u.complexTensorInfos.real,p=u.complexTensorInfos.imag,h=c.data.get(d.dataId).values,f=c.data.get(p.dataId).values,m=Gn({inputs:{x:i},backend:c,attrs:{dtype:"complex64"}}),g=c.data.get(m.dataId),y=g.complexTensorInfos.real,x=g.complexTensorInfos.imag,w=c.data.get(y.dataId).values,$=c.data.get(x.dataId).values,[v,k,I]=t(o.shape,i.shape,h,f,w,$),S=c.makeTensorInfo(I,"float32",v),A=c.makeTensorInfo(I,"float32",k),R=vt({inputs:{real:S,imag:A},backend:c});return c.disposeIntermediateTensorInfo(l),c.disposeIntermediateTensorInfo(m),c.disposeIntermediateTensorInfo(S),c.disposeIntermediateTensorInfo(A),R}else{const l=c.data.get(o.dataId).values,u=c.data.get(i.dataId).values,d=s||o.dtype,[p,h]=e(o.shape,i.shape,l,u,d);return c.makeTensorInfo(h,d,p)}}}function zd(n){return(e,t,s,r,a,o)=>{const i=ye(e,t),c=B(i),l=i.length,u=se(i),d=Ue("float32",c),p=Ue("float32",c),h=zs(e,i),f=zs(t,i),m=xn(s,r),g=xn(a,o),y=e.length,x=se(e),w=t.length,$=se(t);if(h.length+f.length===0)for(let v=0;v<d.length;v++){const k=v%m.length,I=v%g.length,S=n(m[k*2],m[k*2+1],g[I*2],g[I*2+1]);d[v]=S.real,p[v]=S.imag}else for(let v=0;v<d.length;v++){const k=Es(v,l,u),I=k.slice(-y);h.forEach(D=>I[D]=0);const S=Wt(I,y,x),A=k.slice(-w);f.forEach(D=>A[D]=0);const R=Wt(A,w,$),_=n(m[S*2],m[S*2+1],g[R*2],g[R*2+1]);d[v]=_.real,p[v]=_.imag}return[d,p,i]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mm=ze((n,e)=>n+e),ZN=zd((n,e,t,s)=>({real:n+t,imag:e+s})),Xa=Ke(_s,Mm,ZN),JN={kernelName:_s,backendName:"cpu",kernelFunc:Xa};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ud(n,e,t,s,r){const a=B(s),o=Qe(r,t);for(let i=0;i<n.length;i++){const c=n[i];if(c<0)throw new Error("Input x must be non-negative!");c>=r||(a>0?o[c]+=e[i]:o[c]+=1)}return o}function Wm(n,e,t,s=!1){const r=n.shape[0],a=n.shape[1],o=ue([r,t],e.dtype);for(let i=0;i<r;i++)for(let c=0;c<a;c++){const l=n.get(i,c);if(l<0)throw new Error("Input x must be non-negative!");l>=t||(s?o.set(1,i,l):e.size>0?o.set(o.get(i,l)+e.get(i,c),i,l):o.set(o.get(i,l)+1,i,l))}return o}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hn(n){return(e,t,s)=>{const r=Ue(t,e.length);for(let a=0;a<e.length;++a)r[a]=n(e[a],s);return r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function we(n,e,t){return({inputs:s,attrs:r,backend:a})=>{const{x:o}=s;if(te(o,n),o.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");const i=a,c=i.data.get(o.dataId).values,l=B(o.shape),u=t||o.dtype,d=ot(u,l);for(let p=0;p<l;++p)d[p]=e(c[p],r);return i.makeTensorInfo(o.shape,u,d)}}function Qs(n,e,t){return({inputs:s,attrs:r,backend:a})=>{const{x:o}=s;if(te(o,n),o.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");const i=a,c=i.data.get(o.dataId).values,l=t||o.dtype,u=e(c,l,r);return i.makeTensorInfo(o.shape,l,u)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zm=Hn(n=>Math.ceil(n)),ek=Qs(kr,zm),tk={kernelName:kr,backendName:"cpu",kernelFunc:ek};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Um(n,e,t,s){const r=ot(t,B(e));if(s&&t!=="string"){let a=0;n.forEach(o=>{const i=B(o.shape);r.set(o.vals,a),a+=i})}else{let a=0;n.forEach(o=>{const i=t==="string"?xs(o.vals):o.vals;let c=0;for(let l=0;l<o.shape[0];++l){const u=l*e[1]+a;for(let d=0;d<o.shape[1];++d)r[u+d]=i[c++]}a+=o.shape[1]})}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gm=ze((n,e)=>n===e?1:0),Hm=Ke(Ar,Gm,null,"bool"),nk={kernelName:Ar,backendName:"cpu",kernelFunc:Hm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qm=Hn(n=>Math.exp(n)),jm=Qs(Dr,qm,"float32"),sk={kernelName:Dr,backendName:"cpu",kernelFunc:jm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Km=Hn(n=>Math.expm1(n)),rk=Qs(Fr,Km),ak={kernelName:Fr,backendName:"cpu",kernelFunc:rk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xm=Hn(n=>Math.floor(n)),ok=Qs(Or,Xm),ik={kernelName:Or,backendName:"cpu",kernelFunc:ok};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ym(n,e,t,s,r,a,o,i,c){const l=ue([s,a],t);for(let u=0;u<s;u++){const d=[];let p=0;for(let h=0;h<r;h++){const f=n[u*r+h];p+=f*o[h],d.push(f)}if(p<0||p>=c/a)throw new Error(`Invalid indices: ${d} does not index into ${i}`);for(let h=0;h<a;h++)l.values[u*a+h]=e.get(...e.indexToLoc(p*a+h))}return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qm(n,e,t){const s=ue(t,n.dtype);for(let r=0;r<s.size;++r){const o=s.indexToLoc(r).slice(),i=o[0],c=o[2],l=e.locToIndex([i,c]);o[2]=e.values[l];const u=n.locToIndex(o);s.values[r]=n.values[u]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zm=ze((n,e)=>n>e?1:0),ck=Ke(Lr,Zm,null,"bool"),lk={kernelName:Lr,backendName:"cpu",kernelFunc:ck};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jm=ze((n,e)=>n>=e?1:0),uk=Ke(Br,Jm,null,"bool"),dk={kernelName:Br,backendName:"cpu",kernelFunc:uk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eg=ze((n,e)=>n<e?1:0),pk=Ke(Ur,eg,null,"bool"),hk={kernelName:Ur,backendName:"cpu",kernelFunc:pk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tg=ze((n,e)=>n<=e?1:0),fk=Ke(Gr,tg,null,"bool"),mk={kernelName:Gr,backendName:"cpu",kernelFunc:fk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ng(n,e,t){const s=(e-n)/(t-1),r=Qe(t,"float32");r[0]=n;for(let a=1;a<r.length;a++)r[a]=r[a-1]+s;return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sg=Hn(n=>Math.log(n)),gk=Qs(Hr,sg),yk={kernelName:Hr,backendName:"cpu",kernelFunc:gk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rg(n,e,t,s){const r=Ue(s,B(t));for(let a=0;a<r.length;++a){const o=a*e;let i=n[o];for(let c=0;c<e;++c){const l=n[o+c];(Number.isNaN(l)||l>i)&&(i=l)}r[a]=i}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ag=ze((n,e)=>Math.max(n,e)),xk=Ke(Yr,ag),bk={kernelName:Yr,backendName:"cpu",kernelFunc:xk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const og=ze((n,e)=>Math.min(n,e)),wk=Ke(Qr,og),$k={kernelName:Qr,backendName:"cpu",kernelFunc:wk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gd=ze((n,e)=>n*e),vk=zd((n,e,t,s)=>({real:n*t-e*s,imag:n*s+e*t})),Hc=Ke(Jr,Gd,vk),Ck={kernelName:Jr,backendName:"cpu",kernelFunc:Hc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ig(n,e,t){const s=dn(-1,t);return Gd([],e,s,n,t)}function Nk(n){const{inputs:e,backend:t}=n,{x:s}=e;te(s,"neg");const r=t.data.get(s.dataId).values,[a,o]=ig(r,s.shape,s.dtype);return t.makeTensorInfo(o,s.dtype,a)}const kk={kernelName:yi,backendName:"cpu",kernelFunc:Nk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cg=ze((n,e)=>n!==e?1:0),Ik=Ke(ea,cg,null,"bool"),Sk={kernelName:ea,backendName:"cpu",kernelFunc:Ik};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hd(n,e,t,s,r){const a=e.length,o=B(e),i=se(e),c=se(r),l=Ue(t,B(r));for(let u=0;u<o;++u){const d=Es(u,a,i),p=new Array(d.length);for(let f=0;f<p.length;f++)p[f]=d[s[f]];const h=Wt(p,a,c);l[h]=n[u]}return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Et(n){const{inputs:e,attrs:t,backend:s}=n,{x:r}=e,{perm:a}=t;te(r,"transpose");const o=r.shape.length,i=new Array(o);for(let d=0;d<i.length;d++)i[d]=r.shape[a[d]];const c=s.data.get(r.dataId).values,l=Hd(c,r.shape,r.dtype,a,i);return{dataId:s.write(l,i,r.dtype),shape:i,dtype:r.dtype}}const Tk={kernelName:Qi,backendName:"cpu",kernelFunc:Et};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lg(n,e,t,s){const[r,a]=Ze(n,s),o=xt(e,"int32"),i=Qe(B(r),o),c=B(a);for(let l=0;l<i.length;++l){const u=l*c;let d=1;for(let p=0;p<c;++p)d*=t[u+p];i[l]=d}return{outVals:i,outShape:r,outDtype:o}}function Ek(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,keepDims:o}=s;te(r,"prod");const i=r.shape.length,c=ge(a,r.shape),l=Me(c,i);let u=c,d=r;const p=[];l!=null&&(d=Et({inputs:{x:r},backend:t,attrs:{perm:l}}),p.push(d),u=We(u.length,i));const h=t.data.get(d.dataId).values,{outVals:f,outShape:m,outDtype:g}=lg(d.shape,d.dtype,h,u);let y=m;return o&&(y=He(m,c)),p.forEach(x=>t.disposeIntermediateTensorInfo(x)),t.makeTensorInfo(y,g,f)}const Rk={kernelName:Ii,backendName:"cpu",kernelFunc:Ek};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ug(n,e,t,s){const r=n===e,a=n<e&&t<0,o=e<n&&t>1;if(r||a||o)return Qe(0,s);const i=Math.abs(Math.ceil((e-n)/t)),c=Qe(i,s);e<n&&t===1&&(t=-1),c[0]=n;for(let l=1;l<c.length;l++)c[l]=c[l-1]+t;return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dg=Hn(n=>1/Math.sqrt(n)),_k=Qs(oa,dg),Ak={kernelName:oa,backendName:"cpu",kernelFunc:_k};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dk=Hn(n=>1/(1+Math.exp(-n))),pg=we(da,n=>1/(1+Math.exp(-n))),Fk={kernelName:da,backendName:"cpu",kernelFunc:pg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hg(n,e,t,s,r){const a=_u(s,e,t),o=B(t),i=se(s);if(a){const d=Au(e,i);return r==="string"?n.slice(d,d+o):n.subarray(d,d+o)}const c=r==="string"?xs(n):n,l=ue(s,r,c),u=ue(t,r);for(let d=0;d<u.size;++d){const p=u.indexToLoc(d),h=p.map((f,m)=>f+e[m]);u.set(l.get(...h),...p)}return r==="string"?Lm(u.values):u.values}function ws(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:a,size:o}=s;te(r,"slice");const[i,c]=Du(r,a,o);Eu(r,i,c);const l=t.data.get(r.dataId).values,u=hg(l,i,c,r.shape,r.dtype);return t.makeTensorInfo(c,r.dtype,u)}const Ok={kernelName:Oi,backendName:"cpu",kernelFunc:ws};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fg(n,e,t,s,r,a,o){const i=e[0],c=a[0],l=new Array(c),u=new Array(i),d=e[1];if(c===0){if(i!==0)throw new Error(`Received SparseTensor with denseShape[0] = 0 but
         indices.shape[0] = ${i}`);const g=ot(t,0),y=ot(r,0);return[g,[0,d],y,l,u]}let p=!0,h=0;const f=new Array(c).fill(0);for(let g=0;g<i;++g){const y=n[g*d];if(y<0)throw new Error(`indices(${g}, 0) is invalid: ${y} < 0`);if(y>=c)throw new Error(`indices(${g}, 0) is invalid: ${y} >= ${c}`);++f[y],p=p&&y>=h,h=y}let m=!0;for(let g=0;g<c;++g){const y=f[g]===0;l[g]=y,m=m&&!y,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&p){const g=n,y=s;for(let x=0;x<i;++x)u[x]=x;return[g,[i,d],y,l,u]}else{const g=f[c-1],y=ot(t,g*d),x=ot(r,g),w=new Array(c).fill(0);for(let $=0;$<i;++$){const v=n[$*d],k=w[v],I=(v===0?0:f[v-1])+k;w[v]++;for(let S=0;S<d;++S)y[I*d+S]=n[$*d+S];x[I]=s[$],u[$]=I}for(let $=0;$<c;++$)if(w[$]===0){const k=$===0?0:f[$-1];y[k*d+0]=$;for(let I=1;I<d;++I)y[k*d+I]=0;x[k]=o}return[y,[g,d],x,l,u]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mg(n,e,t,s,r){const a=B(s),o=e[0],i=r.length,c=[];let l=1,u=-1;for(let g=0;g<i;++g){const y=r[g];if(y===-1){if(u!==-1)throw new Error(`only one output dimension may be -1, not both ${u} and ${g}`);u=g,c.push(1)}else{if(y<0)throw new Error(`size ${g} must be non-negative, not ${y}`);l*=y,c.push(y)}}if(u!==-1){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const g=Math.trunc(a/l);if(l*g!==a)throw new Error(`Input to reshape is a SparseTensor with ${a}
          dense values, but the requested shape requires a multiple of ${l}. inputShape=${s} outputShape= ${c}`);c[u]=g}const d=B(c);if(d!==a)throw new Error(`Input to reshape is a tensor with ${a} dense values, but the requested shape has ${d}. inputShape=${s} outputShape=${c}`);const p=s.length,h=[];if(p>0){h[p-1]=1;for(let g=p-2;g>=0;--g)h[g]=h[g+1]*s[g+1]}const f=[];if(i>0){f[i-1]=1;for(let g=i-2;g>=0;--g)f[g]=f[g+1]*c[g+1]}const m=ot(t,o*i);for(let g=0;g<o;++g){let y=0;for(let x=0;x<p;++x)y+=n[g*p+x]*h[x];for(let x=0;x<i;++x)m[g*i+x]=Math.trunc(y/f[x]),y%=f[x]}return[m,[o,i],c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qd(n,e,t,s,r,a=!1,o=0){const i=s.length;if(i!==r.length)throw new Error("segmentIds and indices should have same size.");const c=[e[0],n.length/e[0]],l=c[1],d=i>0?r[i-1]+1:0;if(d<0)throw new Error("segment ids must be >= 0");const p=e.slice();p[0]=d;const h=p.reduce((w,$)=>w*$,1),f=ot(t,h);if(i===0)return d>0&&f.fill(o),[f,p];if(d<=0)throw new Error("segment ids must be >= 0");let m=0,g=1,y=0,x=r[m];for(;;){let w=0;if(g<i){if(w=r[g],x===w){++g;continue}if(x>=w)throw new Error("segment ids are not increasing")}if(x<0||x>=d)throw new Error(`Segment id ${x} out of range [0, ${d}), possibly because segmentIds input is not sorted.`);x>y&&f.fill(o,y*l,x*l);for(let $=m;$<g;++$){const v=s[$];if(v<0||v>=c[0])throw new Error(`Bad: indices[${$}] == ${s[$]} out of range [0, ${c[0]})`);for(let k=0;k<l;k++)f[x*l+k]+=n[v*l+k]}if(a)for(let $=0;$<l;$++)f[x*l+$]/=g-m;if(m=g,++g,y=x+1,x=w,g>i)break}return y<d&&f.fill(o,y*l,d*l),[f,p]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pk=Hn(n=>Math.sqrt(n)),Lk=we(ha,n=>Math.sqrt(n)),Bk={kernelName:ha,backendName:"cpu",kernelFunc:Lk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gg=ze((n,e)=>{const t=n-e;return t*t}),Vk=Ke(fa,gg),Mk={kernelName:fa,backendName:"cpu",kernelFunc:Vk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yg(n,e,t,s){const r=ue(n,e.dtype);for(let a=0;a<r.size;a++){const o=r.indexToLoc(a),i=new Array(o.length);for(let c=0;c<i.length;c++)i[c]=o[c]*t[c]+s[c];r.set(e.get(...i),...o)}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wk{constructor(e,t,s,r,a,o){this.separator=Kt(e),this.nGramWidths=t,this.leftPad=Kt(s),this.rightPad=Kt(r),this.padWidth=a,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const s=this.getPadWidth(t);return Math.max(0,e+2*s-t+1)}createNGrams(e,t,s,r,a,o){for(let i=0;i<a;++i){const c=this.getPadWidth(o),l=Math.max(0,c-i),u=Math.max(0,c-(a-(i+1))),d=o-(l+u),p=t+(l>0?0:i-c);let h=0;h+=l*this.leftPad.length;for(let x=0;x<d;++x)h+=e[p+x].length;h+=u*this.rightPad.length,h+=(l+u+d-1)*this.separator.length,s[r+i]=new Uint8Array(h);const m=s[r+i];let g=0;const y=x=>x.forEach(w=>m[g++]=w);for(let x=0;x<l;++x)y(this.leftPad),y(this.separator);for(let x=0;x<d-1;++x)y(e[p+x]),y(this.separator);if(d>0){y(e[p+d-1]);for(let x=0;x<u;++x)y(this.separator),y(this.rightPad)}else{for(let x=0;x<u-1;++x)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(e,t){const s=e.length,r=t.length;if(r>0){let c=t[0];if(c!==0)throw new Error(`First split value must be 0, got ${c}`);for(let l=1;l<r;++l){let u=t[l]>=c;if(u=u&&t[l]<=s,!u)throw new Error(`Invalid split value ${t[l]}, must be in [${c}, ${s}]`);c=t[l]}if(c!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${c}`)}const a=r-1,o=ot("int32",r);if(s===0||r===0){const c=new Array(s);for(let l=0;l<=a;++l)o[l]=0;return[c,o]}o[0]=0;for(let c=1;c<=a;++c){const l=t[c]-t[c-1];let u=0;this.nGramWidths.forEach(d=>{u+=this.getNumNGrams(l,d)}),this.preserveShort&&l>0&&u===0&&(u=1),o[c]=o[c-1]+u}const i=new Array(o[a]);for(let c=0;c<a;++c){const l=t[c];let u=o[c];if(this.nGramWidths.forEach(d=>{const p=t[c+1]-t[c],h=this.getNumNGrams(p,d);this.createNGrams(e,l,i,u,h,d),u+=h}),this.preserveShort&&u===o[c]){const d=t[c+1]-t[c];if(d===0)continue;const p=d+2*this.padWidth,h=1;this.createNGrams(e,l,i,u,h,p)}}return[i,o]}}function xg(n,e,t,s,r,a,o,i){return new Wk(t,s,r,a,o,i).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zk(n,e,t,s){if(!n.length)return;if(e.length===0){for(let a=0;a<n.length;++a)s.push(n.subarray(a,a+1));return}if(e.length===1){const a=e[0];let o=n.indexOf(a);for(;o!==-1;){const i=n.subarray(0,o);(!t||i.length!==0)&&s.push(i),n=n.subarray(o+1),o=n.indexOf(a)}(!t||n.length!==0)&&s.push(n);return}let r=0;for(let a=0;a<n.length+1;a++)if(a===n.length||e.indexOf(n[a])!==-1){const o=n.subarray(r,a);(!t||o.length!==0)&&s.push(o),r=a+1}}function bg(n,e,t){const s=n.length,r=[];let a=0,o=0;const i=new Array(s);for(let p=0;p<s;++p){const h=r.length;zk(n[p],e,t,r);const f=r.length-h;i[p]=f,a+=f,o=Math.max(o,f)}const c=ot("int32",a*2),l=new Array(a),u=[s,o];let d=0;for(let p=0;p<s;++p)for(let h=0;h<i[p];++h)c[d*2]=p,c[d*2+1]=h,l[d]=r[d],++d;return[c,l,u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wg(n,e){const t=ot("int32",n.length);for(let s=0;s<n.length;++s)t[s]=fh(n[s]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $g=ze((n,e)=>n-e),Uk=zd((n,e,t,s)=>({real:n-t,imag:e-s})),jd=Ke(ma,$g,Uk),Gk={kernelName:ma,backendName:"cpu",kernelFunc:jd};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vg(n,e){const t=new Array(n.rank);for(let r=0;r<t.length;r++)t[r]=n.shape[r]*e[r];const s=ue(t,n.dtype);for(let r=0;r<s.values.length;++r){const a=s.indexToLoc(r),o=new Array(n.rank);for(let c=0;c<o.length;c++)o[c]=a[c]%n.shape[c];const i=n.locToIndex(o);s.values[r]=n.values[i]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ya=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function Cg(n,e,t=0,s=n.length-1){for(;s>t;){if(s-t>600){const i=s-t+1,c=e-t+1,l=Math.log(i),u=.5*Math.exp(2*l/3),d=.5*Math.sqrt(l*u*(i-u)/i)*Math.sign(c-i/2),p=Math.max(t,Math.floor(e-c*u/i+d)),h=Math.min(s,Math.floor(e+(i-c)*u/i+d));Cg(n,e,p,h)}const r=n[e];let a=t,o=s;for(cn(n,t,e),Ya(n[s],r)>0&&cn(n,t,s);a<o;){for(cn(n,a,o),a++,o--;Ya(n[a],r)<0;)a=a+1;for(;Ya(n[o],r)>0;)o=o-1}Ya(n[t],r)===0?cn(n,t,o):(o=o+1,cn(n,o,s)),o<=e&&(t=o+1),e<=o&&(s=o-1)}}function Ng(n,e,t,s,r){const a=e[e.length-1],[o,i]=[n.length/a,a],c=Ue(t,o*s),l=Ue("int32",o*s);for(let d=0;d<o;d++){const p=d*i,h=n.subarray(p,p+i);let f=new Array(h.length);h.forEach((x,w)=>f[w]={value:x,index:w}),s<f.length&&(Cg(f,s),f=f.slice(0,s)),r&&f.sort(Ya);const m=d*s,g=c.subarray(m,m+s),y=l.subarray(m,m+s);for(let x=0;x<s;x++)g[x]=f[x].value,y[x]=f[x].index}const u=e.slice();return u[u.length-1]=s,[ue(u,t,c),ue(u,"int32",l)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kg(n,e,t,s){const r=ge(e,t)[0],a=[1,t[0],1];for(let f=0;f<r;f++)a[0]*=t[f];a[1]=t[r];for(let f=r+1;f<t.length;f++)a[2]*=t[f];const o={},i=new Int32Array(t[r]),c=new Ge(a,s,n),l=[],u=a[0]===1&&a[2]===1;for(let f=0;f<t[r];f++){let m;if(u)m=n[f].toString();else{const g=[];for(let y=0;y<a[0];y++)for(let x=0;x<a[2];x++)g.push(c.get(y,f,x));m=g.join(",")}if(o[m]!==void 0)i[f]=o[m];else{const g=Object.keys(o).length;o[m]=g,i[f]=g,l.push(f)}}const d=a.slice();d[1]=Object.keys(o).length;const p=new Ge(d,s);l.forEach((f,m)=>{for(let g=0;g<a[0];g++)for(let y=0;y<a[2];y++)p.set(c.get(g,f,y),g,m,y)});const h=t.slice();return h[r]=d[1],{outputValues:p.values,outputShape:h,indices:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Hk=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",simpleAbsImpl:Vm,addImpl:Mm,bincountImpl:Ud,bincountReduceImpl:Wm,ceilImpl:zm,concatImpl:Um,equalImpl:Gm,expImpl:qm,expm1Impl:Km,floorImpl:Xm,gatherNdImpl:Ym,gatherV2Impl:Qm,greaterImpl:Zm,greaterEqualImpl:Jm,lessImpl:eg,lessEqualImpl:tg,linSpaceImpl:ng,logImpl:sg,maxImpl:rg,maximumImpl:ag,minimumImpl:og,multiplyImpl:Gd,negImpl:ig,notEqualImpl:cg,prodImpl:lg,rangeImpl:ug,rsqrtImpl:dg,sigmoidImpl:Dk,sliceImpl:hg,sparseFillEmptyRowsImpl:fg,sparseReshapeImpl:mg,sparseSegmentReductionImpl:qd,sqrtImpl:Pk,squaredDifferenceImpl:gg,stridedSliceImpl:yg,stringNGramsImpl:xg,stringSplitImpl:bg,stringToHashBucketFastImpl:wg,subImpl:$g,tileImpl:vg,topKImpl:Ng,transposeImpl:Hd,uniqueImpl:kg});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Bu("cpu",()=>new Uc,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ig=we(Rr,n=>n>=0?n:Math.exp(n)-1),qk={kernelName:Rr,backendName:"cpu",kernelFunc:Ig};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sg(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:a}=s;te([r],"leakyRelu");const o=B(r.shape),i=t.data.get(r.dataId).values,c=Ue("float32",o);for(let l=0;l<i.length;l++)c[l]=i[l]<0?a*i[l]:i[l];return t.makeTensorInfo(r.shape,"float32",c)}const jk={kernelName:oi,backendName:"cpu",kernelFunc:Sg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kk=ze((n,e)=>n<0?e*n:n);function Tg(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e;te([s,r],"prelu");const a=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,[i,c]=Kk(s.shape,r.shape,a,o,"float32");return t.makeTensorInfo(c,"float32",i)}const Xk={kernelName:ki,backendName:"cpu",kernelFunc:Tg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eg=we(sa,n=>Math.max(0,n)),Yk={kernelName:sa,backendName:"cpu",kernelFunc:Eg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rg=we(ra,n=>Math.min(Math.max(0,n),6)),Qk={kernelName:ra,backendName:"cpu",kernelFunc:Rg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kd(n,e,t,s,r){if(t==="linear")return sn({inputs:{x:e},backend:n});if(t==="relu")return Eg({inputs:{x:e},backend:n});if(t==="elu")return Ig({inputs:{x:e},backend:n});if(t==="relu6")return Rg({inputs:{x:e},backend:n});if(t==="prelu")return Tg({inputs:{x:e,alpha:s},backend:n});if(t==="leakyrelu")return Sg({inputs:{x:e},backend:n,attrs:{alpha:r}});if(t==="sigmoid")return pg({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fe(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:a}=s,o=B(r.shape),i=El(a,o),c=B(i);C(o===c,()=>`The new shape (${i}) has ${c} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),t.incRef(r.dataId);const l=t.data.get(r.dataId);if(l.complexTensorInfos!=null){const u=l.complexTensorInfos.real,d=l.complexTensorInfos.imag;u.shape=i,d.shape=i}return{dataId:r.dataId,shape:i,dtype:r.dtype}}const Zk={kernelName:Ei,backendName:"cpu",kernelFunc:Fe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _g(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:a}=e,{transposeA:o,transposeB:i}=s;te([r,a],"matMul");const c=r.shape.length,l=a.shape.length,u=o?r.shape[c-2]:r.shape[c-1],d=i?a.shape[l-1]:a.shape[l-2],p=o?r.shape[c-1]:r.shape[c-2],h=i?a.shape[l-2]:a.shape[l-1],f=r.shape.slice(0,-2),m=a.shape.slice(0,-2),g=B(f),y=B(m),x=g===y||g===1||y===1;C(c>=2&&l>=2&&x,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${f}) and (${m}).`);const $=(g>y?r.shape.slice(0,-2):a.shape.slice(0,-2)).concat([p,h]);C(u===d,()=>`Error in matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${r.shape} and ${a.shape} and transposeA=${o} and transposeB=${i} must match.`);const v=o?[g,u,p]:[g,p,u],k=i?[y,h,d]:[y,d,h],I=Fe({inputs:{x:r},backend:t,attrs:{shape:v}}),S=Fe({inputs:{x:a},backend:t,attrs:{shape:k}}),A=o?I.shape[1]:I.shape[2],R=o?I.shape[2]:I.shape[1],_=i?S.shape[1]:S.shape[2],D=Math.max(g,y),F=t.data.get(I.dataId).values,P=t.data.get(S.dataId).values,L=se(I.shape),O=se(S.shape),[z,V,U]=o?[L[0],1,L[1]]:[L[0],L[1],1],[G,H,j]=i?[1,O[1],O[0]]:[O[1],1,O[0]],q=R*_,X=ue([D,R,_],I.dtype),Y=X.values,J=t.blockSize;for(let ee=0;ee<D;ee++)for(let ae=0;ae<R;ae+=J)for(let oe=0;oe<_;oe+=J)for(let le=0;le<A;le+=J){const fe=Math.min(ae+J,R),be=Math.min(oe+J,_),Oe=Math.min(le+J,A);for(let Re=ae;Re<fe;Re++)for(let ke=oe;ke<be;ke++){let Ie=0;for(let _e=le;_e<Oe;_e++){const Be=Math.min(ee,g-1)*z,an=Math.min(ee,y-1)*j,Xe=F[Be+Re*V+_e*U],qt=P[_e*G+ke*H+an];Ie+=Xe*qt}Y[ee*q+(Re*_+ke)]+=Ie}}return t.disposeIntermediateTensorInfo(I),t.disposeIntermediateTensorInfo(S),t.makeTensorInfo($,X.dtype,X.values)}const Jk={kernelName:Eo,backendName:"cpu",kernelFunc:_g};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eI(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:a,bias:o,preluActivationWeights:i}=e,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:d}=s;let p,h,f;const m=[];p=_g({inputs:{a:r,b:a},attrs:{transposeA:c,transposeB:l},backend:t}),o&&(h=Xa({inputs:{a:p,b:o},backend:t}),m.push(p),p=h),u&&(f=Kd(t,p,u,i,d),m.push(p),p=f);for(const y of m)t.disposeIntermediateTensorInfo(y);return p}const tI={kernelName:wa,backendName:"cpu",kernelFunc:eI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nI=we(yr,n=>Math.acos(n)),sI={kernelName:yr,backendName:"cpu",kernelFunc:nI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rI=we(xr,n=>Math.acosh(n)),aI={kernelName:xr,backendName:"cpu",kernelFunc:rI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oI(n){const{inputs:e,backend:t}=n,s=e;te(e,"addN");const r=s.map(i=>t.data.get(i.dataId).values),a=ue(s[0].shape,s[0].dtype),o=a.values;for(let i=0;i<s.length;i++){const c=r[i];for(let l=0;l<o.length;l++)o[l]+=c[l]}return t.makeTensorInfo(a.shape,a.dtype,a.values)}const iI={kernelName:vo,backendName:"cpu",kernelFunc:oI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,keepDims:o}=s;te(r,"all");const i=ge(a,r.shape);let c=i;const l=Me(c,r.shape.length);let u=r;l!=null&&(u=Et({inputs:{x:r},backend:t,attrs:{perm:l}}),c=We(c.length,r.shape.length)),Je("all",c,u.shape.length);const[d,p]=Ze(u.shape,c),h=B(p),f=Qe(B(d),u.dtype),m=t.data.get(u.dataId).values;for(let y=0;y<f.length;++y){const x=y*h;let w=m[x];for(let $=0;$<h;++$){const v=m[x+$];w=w&&v}f[y]=w}l!=null&&t.disposeIntermediateTensorInfo(u);const g=t.makeTensorInfo(d,u.dtype,f);if(o){const y=He(d,i),x=Fe({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),x}return g}const lI={kernelName:Co,backendName:"cpu",kernelFunc:cI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,keepDims:o}=s;te(r,"any");const i=ge(a,r.shape);let c=i;const l=Me(c,r.shape.length);let u=r;l!=null&&(u=Et({inputs:{x:r},backend:t,attrs:{perm:l}}),c=We(c.length,r.shape.length)),Je("any",c,u.shape.length);const[d,p]=Ze(u.shape,c),h=B(p),f=Qe(B(d),u.dtype),m=t.data.get(u.dataId).values;for(let y=0;y<f.length;++y){const x=y*h;let w=m[x];for(let $=0;$<h;++$){const v=m[x+$];w=w||v}f[y]=w}l!=null&&t.disposeIntermediateTensorInfo(u);const g=t.makeTensorInfo(d,u.dtype,f);if(o){const y=He(d,i),x=Fe({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),x}return g}const dI={kernelName:No,backendName:"cpu",kernelFunc:uI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a}=s;te(r,"argMax");let o=ge(a,r.shape);const i=Me(o,r.shape.length);let c=r;const l=[];i!=null&&(c=Et({inputs:{x:r},backend:t,attrs:{perm:i}}),l.push(c),o=We(o.length,c.shape.length)),o=[o[0]],Je("argMax",o,c.shape.length);const[u,d]=Ze(c.shape,o),p=B(u),h=Qe(p,"int32"),f=B(d),m=t.data.get(c.dataId).values;for(let g=0;g<h.length;++g){const y=g*f;let x=m[y],w=0;for(let $=0;$<f;++$){const v=m[y+$];v>x&&(x=v,w=$)}h[g]=w}return l.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(u,"int32",h)}const hI={kernelName:ko,backendName:"cpu",kernelFunc:pI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a}=s;te(r,"argMin");let o=ge(a,r.shape);const i=Me(o,r.shape.length);let c=r;const l=[];i!=null&&(c=Et({inputs:{x:r},backend:t,attrs:{perm:i}}),l.push(c),o=We(o.length,c.shape.length)),o=[o[0]],Je("argMin",o,c.shape.length);const[u,d]=Ze(c.shape,o),p=B(u),h=Qe(p,"int32"),f=B(d),m=t.data.get(c.dataId).values;for(let g=0;g<h.length;++g){const y=g*f;let x=m[y],w=0;for(let $=0;$<f;++$){const v=m[y+$];v<x&&(x=v,w=$)}h[g]=w}return l.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(u,"int32",h)}const mI={kernelName:Io,backendName:"cpu",kernelFunc:fI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gI=we(br,n=>Math.asin(n)),yI={kernelName:br,backendName:"cpu",kernelFunc:gI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xI=we(wr,n=>Math.asinh(n)),bI={kernelName:wr,backendName:"cpu",kernelFunc:xI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wI=we($r,n=>Math.atan(n)),$I={kernelName:$r,backendName:"cpu",kernelFunc:wI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vI=ze((n,e)=>Math.atan2(n,e)),CI=Ke(Cr,vI),NI={kernelName:Cr,backendName:"cpu",kernelFunc:CI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kI=we(vr,n=>Math.atanh(n)),II={kernelName:vr,backendName:"cpu",kernelFunc:kI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xd(n,e,t,s,r,a){const o=r.strideHeight,i=r.strideWidth,c=r.dilationHeight,l=r.dilationWidth,u=r.effectiveFilterHeight,d=r.effectiveFilterWidth,p=r.padInfo.top,h=r.padInfo.left,f=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=ue(r.outShape,t),g=m.values,y=r.outShape[1]*r.outShape[2]*r.outShape[3],x=r.outShape[2]*r.outShape[3],w=r.outShape[3];for(let $=0;$<r.batchSize;++$){const v=$*y,k=$*s[0];for(let I=0;I<r.inChannels;++I)for(let S=0;S<r.outHeight;++S){const A=S*o-p,R=Math.max(0,A),_=Math.min(r.inHeight,u+A),D=v+S*x;for(let F=0;F<r.outWidth;++F){const P=F*i-h,L=Math.max(0,P),O=Math.min(r.inWidth,d+P);let z=f,V=0,U=0;for(let H=R;H<_;H+=c){const j=k+H*s[1];for(let q=L;q<O;q+=l){const X=j+q*s[2],Y=n[X+I];a==="max"&&Y>z?z=Y:a==="avg"&&(V+=Y,U++)}if(isNaN(z))break}const G=D+F*w+I;g[G]=a==="avg"?V/U:z}}}return m}function Ag(n,e,t,s,r=!1,a=!1){const o=ue(s.outShape,"int32"),i=s.strideHeight,c=s.strideWidth,l=s.dilationHeight,u=s.dilationWidth,d=s.effectiveFilterHeight,p=s.effectiveFilterWidth,h=s.padInfo.top,f=s.padInfo.left,m=ue(e,t,n);for(let g=0;g<s.batchSize;++g)for(let y=0;y<s.inChannels;++y)for(let x=0;x<s.outHeight;++x){const w=x*i-h;let $=w;for(;$<0;)$+=l;const v=Math.min(s.inHeight,d+w);for(let k=0;k<s.outWidth;++k){const I=k*c-f;let S=I;for(;S<0;)S+=u;const A=Math.min(s.inWidth,p+I);let R=Number.NEGATIVE_INFINITY,_=-1;for(let D=$;D<v;D+=l){const F=D-w;for(let P=S;P<A;P+=u){const L=P-I,O=m.get(g,D,P,y);O>R&&(R=O,r?_=a?((g*s.inHeight+D)*s.inWidth+P)*s.inChannels+y:(D*s.inWidth+P)*s.inChannels+y:_=F*p+L)}}o.set(_,g,x,k,y)}}return o}function Dg(n,e,t,s,r,a){const o=r.strideDepth,i=r.strideHeight,c=r.strideWidth,l=r.dilationDepth,u=r.dilationHeight,d=r.dilationWidth,p=r.effectiveFilterDepth,h=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,y=r.padInfo.left,x=a==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,w=ue(r.outShape,t),$=w.values,v=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[2]*r.outShape[3]*r.outShape[4],I=r.outShape[3]*r.outShape[4],S=r.outShape[4];for(let A=0;A<r.batchSize;++A){const R=A*v,_=A*s[0];for(let D=0;D<r.inChannels;++D)for(let F=0;F<r.outDepth;++F){const P=F*o-m;let L=P;for(;L<0;)L+=l;const O=Math.min(r.inDepth,p+P),z=R+F*k;for(let V=0;V<r.outHeight;++V){const U=V*i-g;let G=U;for(;G<0;)G+=u;const H=Math.min(r.inHeight,h+U),j=z+V*I;for(let q=0;q<r.outWidth;++q){const X=q*c-y;let Y=X;for(;Y<0;)Y+=d;const J=Math.min(r.inWidth,f+X),ee=j+q*S;let ae=x,oe=0,le=0;for(let be=L;be<O;be+=l){const Oe=_+be*s[1];for(let Re=G;Re<H;Re+=u){const ke=Oe+Re*s[2];for(let Ie=Y;Ie<J;Ie+=d){const _e=ke+Ie*s[3],Be=n[_e+D];if(a==="max"&&Be>ae?ae=Be:a==="avg"&&(oe+=Be,le++),isNaN(ae))break}if(isNaN(ae))break}if(isNaN(ae))break}const fe=ee+D;$[fe]=a==="avg"?oe/le:ae}}}}return w}function SI(n,e){const t=ue(e.outShape,"int32"),s=e.strideDepth,r=e.strideHeight,a=e.strideWidth,o=e.dilationDepth,i=e.dilationHeight,c=e.dilationWidth,l=e.effectiveFilterDepth,u=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=e.padInfo.front,h=e.padInfo.top,f=e.padInfo.left;for(let m=0;m<e.batchSize;++m)for(let g=0;g<e.inChannels;++g)for(let y=0;y<e.outDepth;++y){const x=y*s-p;let w=x;for(;w<0;)w+=o;const $=Math.min(e.inDepth,l+x);for(let v=0;v<e.outHeight;++v){const k=v*r-h;let I=k;for(;I<0;)I+=i;const S=Math.min(e.inHeight,u+k);for(let A=0;A<e.outWidth;++A){const R=A*a-f;let _=R;for(;_<0;)_+=c;const D=Math.min(e.inWidth,d+R);let F=Number.NEGATIVE_INFINITY,P=-1;for(let L=w;L<$;L+=o){const O=L-x;for(let z=I;z<S;z+=i){const V=z-k;for(let U=_;U<D;U+=c){const G=U-R,H=n.get(m,L,z,U,g);H>=F&&(F=H,P=O*u*d+V*u+G)}}}t.set(P,m,y,v,A,g)}}}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;te(r,"avgPool");const{filterSize:a,strides:o,pad:i,dimRoundingMode:c}=s,l=1;C(st(o,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const u=Pt(r.shape,a,o,l,i,c);let d;if(u.filterWidth===1&&u.filterHeight===1&&$e(u.inShape,u.outShape))d=sn({inputs:{x:r},backend:t});else{const p=t.data.get(r.dataId).values,h=se(r.shape),f=Xd(p,r.shape,r.dtype,h,u,"avg");d=t.makeTensorInfo(u.outShape,r.dtype,f.values)}return d}const EI={kernelName:So,backendName:"cpu",kernelFunc:TI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:a,strides:o,pad:i,dimRoundingMode:c,dataFormat:l}=s;te(r,"avgPool3d");const u=hn(r.shape,a,o,1,i,c,l),d=t.data.get(r.dataId).values,p=Dg(d,r.shape,r.dtype,se(r.shape),u,"avg");return t.makeTensorInfo(p.shape,"float32",p.values)}const _I={kernelName:To,backendName:"cpu",kernelFunc:RI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AI(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:a}=e,{filterSize:o,strides:i,pad:c,dimRoundingMode:l}=s;te([r,a],"avgPool3DGrad");const u=hn(a.shape,o,i,1,c,l),d=u.strideDepth,p=u.strideHeight,h=u.strideWidth,f=u.filterDepth,m=u.filterHeight,g=u.filterWidth,y=u.dilationDepth,x=u.dilationHeight,w=u.dilationWidth,$=u.effectiveFilterDepth,v=u.effectiveFilterHeight,k=u.effectiveFilterWidth,I=$-1-u.padInfo.front,S=k-1-u.padInfo.left,A=v-1-u.padInfo.top,R=ue(a.shape,"float32"),_=1/(f*m*g),D=t.bufferSync(r);for(let F=0;F<u.batchSize;++F)for(let P=0;P<u.inChannels;++P)for(let L=0;L<u.inDepth;++L)for(let O=0;O<u.inHeight;++O)for(let z=0;z<u.inWidth;++z){const V=L-I,U=O-A,G=z-S;let H=0;for(let j=0;j<$;j+=y){const q=(V+j)/d;if(!(q<0||q>=u.outDepth||Math.floor(q)!==q))for(let X=0;X<v;X+=x){const Y=(U+X)/p;if(!(Y<0||Y>=u.outHeight||Math.floor(Y)!==Y))for(let J=0;J<k;J+=w){const ee=(G+J)/h;if(ee<0||ee>=u.outWidth||Math.floor(ee)!==ee)continue;H+=D.get(F,q,Y,ee,P)}}}R.set(H*_,F,L,O,z,P)}return t.makeTensorInfo(R.shape,R.dtype,R.values)}const DI={kernelName:Bl,backendName:"cpu",kernelFunc:AI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FI(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:a}=e,o=a;te([r,a],"avgPoolGrad");const{filterSize:i,strides:c,pad:l}=s,u=Pt(o.shape,i,c,1,l),d=u.strideHeight,p=u.strideWidth,h=u.filterHeight,f=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,y=u.effectiveFilterHeight,x=u.effectiveFilterWidth,w=x-1-u.padInfo.left,$=y-1-u.padInfo.top,v=ue(o.shape,"float32"),k=1/(h*f),I=t.data.get(r.dataId).values,S=ue(r.shape,"float32",I);for(let A=0;A<u.batchSize;++A)for(let R=0;R<u.inChannels;++R)for(let _=0;_<u.inHeight;++_)for(let D=0;D<u.inWidth;++D){const F=_-$,P=D-w;let L=0;for(let O=0;O<y;O+=m){const z=(F+O)/d;if(!(z<0||z>=u.outHeight||Math.floor(z)!==z))for(let V=0;V<x;V+=g){const U=(P+V)/p;if(U<0||U>=u.outWidth||Math.floor(U)!==U)continue;L+=S.get(A,z,U,R)}}v.set(L*k,A,_,D,R)}return t.makeTensorInfo(v.shape,v.dtype,v.values)}const OI={kernelName:Ll,backendName:"cpu",kernelFunc:FI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,scale:a,offset:o,mean:i,variance:c}=e;C(i.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),C(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),C(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),te([r,i,c,a,o],"batchNorm");let{varianceEpsilon:l}=s;l==null&&(l=.001);const u=t.data.get(r.dataId).values,d=t.data.get(i.dataId).values,p=t.data.get(c.dataId).values,h=a?t.data.get(a.dataId).values:new Float32Array([1]),f=o?t.data.get(o.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=f.length,y=h.length,x=p.length,w=d.length;let $=0,v=0,k=0,I=0;for(let S=0;S<u.length;++S)m[S]=f[$++]+(u[S]-d[v++])*h[k++]/Math.sqrt(p[I++]+l),$>=g&&($=0),v>=w&&(v=0),k>=y&&(k=0),I>=x&&(I=0);return t.makeTensorInfo(r.shape,r.dtype,m)}const LI={kernelName:ti,backendName:"cpu",kernelFunc:PI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:a,crops:o}=s;te([r],"batchToSpaceND");const i=a.reduce((y,x)=>y*x),c=qa(r.shape,a,i),l=ja(c.length,a.length),u=Ka(r.shape,a,i),d=Cd(o,a.length),p=Nd(u,o,a.length),h=Fe({inputs:{x:r},backend:t,attrs:{shape:c}}),f=Et({inputs:{x:h},backend:t,attrs:{perm:l}}),m=Fe({inputs:{x:f},backend:t,attrs:{shape:u}}),g=ws({inputs:{x:m},backend:t,attrs:{begin:d,size:p}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),g}const VI={kernelName:Ro,backendName:"cpu",kernelFunc:BI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:a}=e,{size:o}=s,i=t.data.get(r.dataId).values,c=t.data.get(a.dataId).values,l=Ud(i,c,a.dtype,a.shape,o);return t.makeTensorInfo([o],a.dtype,l)}const WI={kernelName:_o,backendName:"cpu",kernelFunc:MI};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zI(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,a=t.data.get(s.dataId).values,o=t.data.get(r.dataId).values,i=ye(Array.from(a),Array.from(o));return t.makeTensorInfo([i.length],"int32",Int32Array.from(i))}const UI={kernelName:Ao,backendName:"cpu",kernelFunc:zI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GI=we(Ir,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),HI={kernelName:Ir,backendName:"cpu",kernelFunc:GI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qI=n=>{const{x:e}=n.inputs,t=n.backend,s=new Float32Array(B(e.shape)),r=t.data.get(e.dataId),a=r.complexTensorInfos.real,o=r.complexTensorInfos.imag,i=t.data.get(a.dataId).values,c=t.data.get(o.dataId).values;for(let l=0;l<i.length;l++){const u=i[l],d=c[l];s[l]=Math.hypot(u,d)}return t.makeOutput(s,e.shape,"float32")},jI={kernelName:Fo,backendName:"cpu",kernelFunc:qI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zs(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.data.get(s.dataId).complexTensorInfos.imag,a=t.data.get(r.dataId).values;return t.makeTensorInfo(r.shape,r.dtype,a)}const KI={kernelName:ai,backendName:"cpu",kernelFunc:Zs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Js(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,a=ge(r,e[0].shape)[0];let o=nn(e.map(m=>m.shape),a);if(B(o)===0)return t.makeTensorInfo(o,e[0].dtype,[]);const i=e.filter(m=>B(m.shape)>0);if(i.length===1)return sn({inputs:{x:i[0]},backend:t});const c=i.map(m=>m.shape);if(wd(c,a),i[0].dtype==="complex64"){const m=i.map($=>bs({inputs:{input:$},backend:t})),g=i.map($=>Zs({inputs:{input:$},backend:t})),y=Js({inputs:m,backend:t,attrs:{axis:a}}),x=Js({inputs:g,backend:t,attrs:{axis:a}}),w=vt({inputs:{real:y,imag:x},backend:t});return m.forEach($=>t.disposeIntermediateTensorInfo($)),g.forEach($=>t.disposeIntermediateTensorInfo($)),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(x),w}const l=i.map(m=>{const g=B(m.shape.slice(a));return Fe({inputs:{x:m},backend:t,attrs:{shape:[-1,g]}})}),u=l.map(m=>({vals:t.data.get(m.dataId).values,shape:m.shape}));o=nn(l.map(m=>m.shape),1);const d=l[0].shape[0]===1,p=Um(u,o,e[0].dtype,d),h=nn(i.map(m=>m.shape),a),f=t.makeTensorInfo(h,e[0].dtype,p);return l.forEach(m=>t.disposeIntermediateTensorInfo(m)),f}const XI={kernelName:Oo,backendName:"cpu",kernelFunc:Js};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fg(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:a}=e,{strides:o,pad:i,dataFormat:c,dilations:l,dimRoundingMode:u}=s;te([r,a],"conv2d");const d=fn(c),p=je(r.shape,a.shape,o,l,i,u,!1,d),h=p.filterHeight,f=p.filterWidth,m=p.dilationHeight,g=p.dilationWidth,y=p.padInfo.left,x=p.padInfo.top,w=p.dataFormat==="channelsLast",$=new Ge(p.outShape,r.dtype),v=se(r.shape),k=se(a.shape),I=v[0],S=w?v[1]:v[2],A=w?v[2]:1,R=w?1:v[1],_=$.strides[0],D=w?$.strides[1]:$.strides[2],F=w?$.strides[2]:1,P=w?1:$.strides[1],L=t.data.get(r.dataId).values,O=t.data.get(a.dataId).values,z=$.values;for(let V=0;V<p.batchSize;++V){const U=V*I,G=V*_;for(let H=0;H<p.outHeight;++H){const j=G+H*D,q=H*p.strideHeight-x;for(let X=0;X<h;++X){const Y=q+X*m;if(Y<0||Y>=p.inHeight)continue;const J=X*k[0],ee=U+Y*S;for(let ae=0;ae<p.outWidth;++ae){const oe=j+ae*F,le=ae*p.strideWidth-y;for(let fe=0;fe<f;++fe){const be=le+fe*g;if(be<0||be>=p.inWidth)continue;const Oe=J+fe*k[1],Re=ee+be*A;let ke=Oe;for(let Ie=0;Ie<p.inChannels;++Ie){const _e=L[Re+Ie*R];for(let Be=0;Be<p.outChannels;++Be)z[oe+Be*P]+=_e*O[ke+Be];ke+=p.outChannels}}}}}}return t.makeTensorInfo($.shape,$.dtype,z)}const YI={kernelName:Po,backendName:"cpu",kernelFunc:Fg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:a}=e,{strides:o,pad:i,dataFormat:c,dimRoundingMode:l,filterShape:u}=s;te([r,a],"conv2dBackpropFilter");const d=fn(c),p=je(r.shape,u,o,1,i,l,!1,d),{strideHeight:h,strideWidth:f,filterHeight:m,filterWidth:g}=p,y=p.dataFormat==="channelsLast",x=new Ge(p.filterShape,"float32"),w=p.padInfo.left,$=p.padInfo.top,v=t.data.get(r.dataId).values,k=t.data.get(a.dataId).values,I=new Ge(r.shape,r.dtype,v),S=new Ge(a.shape,a.dtype,k);for(let A=0;A<m;++A){const R=Math.max(0,Math.ceil(($-A)/h)),_=Math.min(p.outHeight,(p.inHeight+$-A)/h);for(let D=0;D<g;++D){const F=Math.max(0,Math.ceil((w-D)/f)),P=Math.min(p.outWidth,(p.inWidth+w-D)/f);for(let L=0;L<p.inChannels;++L)for(let O=0;O<p.outChannels;++O){let z=0;for(let V=0;V<p.batchSize;++V)for(let U=R;U<_;++U){const G=A+U*h-$;for(let H=F;H<P;++H){const j=D+H*f-w;y?z+=I.get(V,G,j,L)*S.get(V,U,H,O):z+=I.get(V,L,G,j)*S.get(V,O,U,H)}}x.set(z,A,D,L,O)}}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}const ZI={kernelName:Lo,backendName:"cpu",kernelFunc:QI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JI(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:a}=e,{inputShape:o,strides:i,pad:c,dataFormat:l,dimRoundingMode:u}=s;te([r,a],"conv2dBackpropInput");const d=se(a.shape),p=se(r.shape);let h=fn(l);const f=je(o,a.shape,i,1,c,u,!1,h),m=new Ge(f.inShape,"float32"),g=m.values,y=t.data.get(r.dataId).values,x=t.data.get(a.dataId).values,[w,$,v]=d,{batchSize:k,filterHeight:I,filterWidth:S,inChannels:A,inHeight:R,inWidth:_,outChannels:D,outHeight:F,outWidth:P,strideHeight:L,strideWidth:O}=f;h=f.dataFormat;const z=I-1-f.padInfo.top,V=S-1-f.padInfo.left,U=h==="channelsLast",G=m.strides[0],H=U?m.strides[1]:m.strides[2],j=U?m.strides[2]:1,q=U?1:m.strides[1],X=p[0],Y=U?p[1]:p[2],J=U?p[2]:1,ee=U?1:p[1];for(let ae=0;ae<k;++ae)for(let oe=0;oe<A;++oe)for(let le=0;le<R;++le){const fe=le-z,be=Math.max(0,Math.ceil(fe/L)),Oe=Math.min(F,(I+fe)/L);for(let Re=0;Re<_;++Re){const ke=Re-V,Ie=Math.max(0,Math.ceil(ke/O)),_e=Math.min(P,(S+ke)/O);let Be=0;for(let Xe=be;Xe<Oe;++Xe){const qt=Xe*L-fe;for(let kt=Ie;kt<_e;++kt){const Kn=kt*O-ke,Mt=X*ae+Y*Xe+J*kt,on=w*(I-1-qt)+$*(S-1-Kn)+v*oe;for(let vn=0;vn<D;++vn){const Cn=y[Mt+ee*vn],Nn=x[on+vn];Be+=Cn*Nn}}}const an=G*ae+H*le+j*Re+q*oe;g[an]=Be}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}const eS={kernelName:Bo,backendName:"cpu",kernelFunc:JI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tS(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:a}=e,{strides:o,pad:i,dilations:c}=s;te([r,a],"conv3d");const l=Pn(r.shape,a.shape,o,c,i),{filterDepth:u,filterHeight:d,filterWidth:p,dilationDepth:h,dilationHeight:f,dilationWidth:m,padInfo:g}=l,y=g.front,x=g.left,w=g.top,$=new Ge(l.outShape,r.dtype),v=t.data.get(r.dataId).values,k=t.data.get(a.dataId).values,I=$.values,S=se(r.shape),A=se(a.shape);for(let R=0;R<l.batchSize;++R){const _=R*S[0],D=R*$.strides[0];for(let F=0;F<l.outDepth;++F){const P=D+F*$.strides[1],L=F*l.strideDepth-y;for(let O=0;O<u;++O){const z=L+O*h;if(z<0||z>=l.inDepth)continue;const V=O*A[0],U=_+z*S[1];for(let G=0;G<l.outHeight;++G){const H=P+G*$.strides[2],j=G*l.strideHeight-w;for(let q=0;q<d;++q){const X=j+q*f;if(X<0||X>=l.inHeight)continue;const Y=V+q*A[1],J=U+X*S[2];for(let ee=0;ee<l.outWidth;++ee){const ae=H+ee*l.outChannels,oe=ee*l.strideWidth-x;for(let le=0;le<p;++le){const fe=oe+le*m;if(fe<0||fe>=l.inWidth)continue;const be=Y+le*A[2],Oe=J+fe*l.inChannels;let Re=be;for(let ke=0;ke<l.inChannels;++ke){const Ie=v[Oe+ke];for(let _e=0;_e<l.outChannels;++_e)I[ae+_e]+=Ie*k[Re+_e];Re+=l.outChannels}}}}}}}}return t.makeTensorInfo($.shape,$.dtype,$.values)}const nS={kernelName:Vo,backendName:"cpu",kernelFunc:tS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sS(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:a}=e,{strides:o,pad:i,filterShape:c}=s;te([r,a],"conv3dBackpropFilterV2");const l=se(r.shape),u=se(a.shape),d=Pn(r.shape,c,o,1,i),p=d.strideDepth,h=d.strideHeight,f=d.strideWidth,m=d.filterDepth,g=d.filterHeight,y=d.filterWidth,x=new Ge(d.filterShape,"float32"),w=x.values,[$,v,k,I]=x.strides,S=t.data.get(a.dataId).values,[A,R,_,D]=u,F=t.data.get(r.dataId).values,[P,L,O,z]=l,V=d.padInfo.front,U=d.padInfo.left,G=d.padInfo.top;for(let H=0;H<m;++H){const j=Math.max(0,Math.ceil((V-H)/p)),q=Math.min(d.outDepth,(d.inDepth+V-H)/p),X=H*$;for(let Y=0;Y<g;++Y){const J=Math.max(0,Math.ceil((G-Y)/h)),ee=Math.min(d.outHeight,(d.inHeight+G-Y)/h),ae=Y*v+X;for(let oe=0;oe<y;++oe){const le=Math.max(0,Math.ceil((U-oe)/f)),fe=Math.min(d.outWidth,(d.inWidth+U-oe)/f),be=oe*k+ae;for(let Oe=0;Oe<d.inChannels;++Oe){const Re=Oe*I+be;for(let ke=0;ke<d.outChannels;++ke){let Ie=0;for(let _e=0;_e<d.batchSize;++_e){const Be=_e*P,an=_e*A;for(let Xe=j;Xe<q;++Xe){const kt=(H+Xe*p-V)*L+Be,Kn=Xe*R+an;for(let Mt=J;Mt<ee;++Mt){const vn=(Y+Mt*h-G)*O+kt,Cn=Mt*_+Kn;for(let Nn=le;Nn<fe;++Nn){const yl=(oe+Nn*f-U)*z+vn,xl=Nn*D+Cn;Ie+=F[yl+Oe]*S[xl+ke]}}}}w[Re+ke]=Ie}}}}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}const rS={kernelName:Vl,backendName:"cpu",kernelFunc:sS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aS(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:a}=e,{pad:o,strides:i,inputShape:c}=s;te([r],"conv3dBackpropInputV2");const l=se(r.shape),u=se(a.shape),d=Pn(c,a.shape,i,1,o),p=new Ge(d.inShape,"float32"),h=p.values,[f,m,g,y]=p.strides,x=t.data.get(r.dataId).values,[w,$,v,k]=l,I=t.data.get(a.dataId).values,[S,A,R,_]=u,{batchSize:D,filterDepth:F,filterHeight:P,filterWidth:L,inChannels:O,inDepth:z,inHeight:V,inWidth:U,outChannels:G,outDepth:H,outHeight:j,outWidth:q,strideDepth:X,strideHeight:Y,strideWidth:J}=d,ee=F-1-d.padInfo.front,ae=P-1-d.padInfo.top,oe=L-1-d.padInfo.left;for(let le=0;le<D;++le)for(let fe=0;fe<O;++fe)for(let be=0;be<z;++be){const Oe=be-ee,Re=Math.max(0,Math.ceil(Oe/X)),ke=Math.min(H,(F+Oe)/X);for(let Ie=0;Ie<V;++Ie){const _e=Ie-ae,Be=Math.max(0,Math.ceil(_e/Y)),an=Math.min(j,(P+_e)/Y);for(let Xe=0;Xe<U;++Xe){const qt=Xe-oe,kt=Math.max(0,Math.ceil(qt/J)),Kn=Math.min(q,(L+qt)/J);let Mt=0;for(let on=Re;on<ke;++on){const vn=on*X-Oe;for(let Cn=Be;Cn<an;++Cn){const Nn=Cn*Y-_e;for(let hr=kt;hr<Kn;++hr){const yl=hr*J-qt,xl=w*le+$*on+v*Cn+k*hr,kx=S*(F-1-vn)+A*(P-1-Nn)+R*(L-1-yl)+_*fe;for(let co=0;co<G;++co){const Ix=x[xl+co],Sx=I[kx+co];Mt+=Ix*Sx}}}}h[f*le+m*be+g*Ie+y*Xe+fe]=Mt}}}return t.makeTensorInfo(p.shape,p.dtype,p.values)}const oS={kernelName:Mo,backendName:"cpu",kernelFunc:aS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iS=we(Sr,n=>Math.cos(n)),cS={kernelName:Sr,backendName:"cpu",kernelFunc:iS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lS=we(Tr,n=>Math.cosh(n)),uS={kernelName:Tr,backendName:"cpu",kernelFunc:lS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dS(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:a,boxInd:o}=e,{cropSize:i,method:c,extrapolationValue:l}=s,[u,d,p,h]=r.shape,f=a.shape[0],[m,g]=i,y=ue([f,m,g,h],"float32"),x=t.data.get(a.dataId).values,w=t.data.get(o.dataId).values,$=t.data.get(r.dataId).values,v=se(r.shape),k=se(y.shape);for(let I=0;I<f;I++){const S=I*4,A=x[S],R=x[S+1],_=x[S+2],D=x[S+3],F=w[I];if(F>=u)continue;const P=m>1?(_-A)*(d-1)/(m-1):0,L=g>1?(D-R)*(p-1)/(g-1):0;for(let O=0;O<m;O++){const z=m>1?A*(d-1)+O*P:.5*(A+_)*(d-1);if(z<0||z>d-1){for(let V=0;V<g;V++)for(let U=0;U<h;U++){const G=U+V*k[2]+O*k[1]+I*k[0];y.values[G]=l}continue}if(c==="bilinear"){const V=Math.floor(z),U=Math.ceil(z),G=z-V;for(let H=0;H<g;H++){const j=g>1?R*(p-1)+H*L:.5*(R+D)*(p-1);if(j<0||j>p-1){for(let J=0;J<h;J++){const ee=J+H*k[2]+O*k[1]+I*k[0];y.values[ee]=l}continue}const q=Math.floor(j),X=Math.ceil(j),Y=j-q;for(let J=0;J<h;J++){let ee=J+q*v[2]+V*v[1]+F*v[0];const ae=$[ee];ee=J+X*v[2]+V*v[1]+F*v[0];const oe=$[ee];ee=J+q*v[2]+U*v[1]+F*v[0];const le=$[ee];ee=J+X*v[2]+U*v[1]+F*v[0];const fe=$[ee],be=ae+(oe-ae)*Y,Oe=le+(fe-le)*Y;ee=J+H*k[2]+O*k[1]+I*k[0],y.values[ee]=be+(Oe-be)*G}}}else for(let V=0;V<g;++V){const U=g>1?R*(p-1)+V*L:.5*(R+D)*(p-1);if(U<0||U>p-1){for(let j=0;j<h;j++){const q=j+V*k[2]+O*k[1]+I*k[0];y.values[q]=l}continue}const G=Math.round(U),H=Math.round(z);for(let j=0;j<h;j++){const q=j+G*v[2]+H*v[1]+F*v[0],X=j+V*k[2]+O*k[1]+I*k[0];y.values[X]=$[q]}}}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}const pS={kernelName:zo,backendName:"cpu",kernelFunc:dS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hS(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,exclusive:o,reverse:i}=s;te(r,"cumsum");const c=Me([a],r.shape.length);let l=r;c!=null&&(l=Et({inputs:{x:r},backend:t,attrs:{perm:c}}));const u=We(1,r.shape.length)[0];if(u!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${u}`);const d=xt(l.dtype,"int32"),p=Qe(B(l.shape),d),h=t.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=i?(y,x)=>y+f-x-1:(y,x)=>y+x;for(let y=0;y<h.length;y+=f)for(let x=0;x<f;x++){const w=m(y,x);if(x===0)p[w]=o?0:h[w];else{const $=m(y,x-1);p[w]=o?h[$]+p[$]:h[w]+p[$]}}const g=t.makeTensorInfo(l.shape,d,p);if(c!=null){const y=vc(c),x=Et({inputs:{x:g},backend:t,attrs:{perm:y}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(l),x}return g}const fS={kernelName:Wo,backendName:"cpu",kernelFunc:hS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mS(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:a}=e,{size:o,binaryOutput:i}=s;if(r.shape.length===1){const c=t.data.get(r.dataId).values,l=t.data.get(a.dataId).values,u=Ud(c,l,a.dtype,a.shape,o);return t.makeTensorInfo([o],a.dtype,u)}else if(r.shape.length===2){const c=t.bufferSync(r),l=t.bufferSync(a),u=Wm(c,l,o,i);return t.makeTensorInfo(u.shape,a.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const gS={kernelName:Uo,backendName:"cpu",kernelFunc:mS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yS(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:a,dataFormat:o}=s;C(o==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${o}`);const i=r.shape[0],c=r.shape[1],l=r.shape[2],u=r.shape[3],d=c*a,p=l*a,h=u/(a*a),f=t.data.get(r.dataId).values,m=new Float32Array(i*d*p*h);let g=0;for(let y=0;y<i;++y)for(let x=0;x<d;++x){const w=Math.floor(x/a),$=x%a;for(let v=0;v<p;++v){const k=Math.floor(v/a),I=v%a,S=($*a+I)*h;for(let A=0;A<h;++A){const _=A+S+u*(k+l*(w+c*y));m[g++]=f[_]}}}return t.makeTensorInfo([i,d,p,h],r.dtype,m)}const xS={kernelName:Go,backendName:"cpu",kernelFunc:yS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Og(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:a}=e,{strides:o,pad:i,dilations:c,dimRoundingMode:l}=s;te([r,a],"depthwiseConv2DNative");const u=se(r.shape),d=se(a.shape);let p=c;p==null&&(p=[1,1]),C(st(o,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${p}'`);const h=je(r.shape,a.shape,o,p,i,l,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:x}=h,w=x.left,$=x.top,v=h.outChannels/h.inChannels,k=new Ge(h.outShape,r.dtype),I=t.data.get(r.dataId).values,S=t.data.get(a.dataId).values,A=k.values;for(let R=0;R<h.batchSize;++R){const _=R*u[0],D=R*k.strides[0];for(let F=0;F<h.outHeight;++F){const P=D+F*k.strides[1],L=F*h.strideHeight-$;for(let O=0;O<f;++O){const z=L+O*g;if(z<0||z>=h.inHeight)continue;const V=O*d[0],U=_+z*u[1];for(let G=0;G<h.outWidth;++G){const H=P+G*k.strides[2],j=G*h.strideWidth-w;for(let q=0;q<m;++q){const X=j+q*y;if(X<0||X>=h.inWidth)continue;const Y=V+q*d[1],J=U+X*h.inChannels;let ee=H,ae=Y;for(let oe=0;oe<h.inChannels;++oe){const le=I[J+oe];for(let fe=0;fe<v;++fe)A[ee+fe]+=le*S[ae+fe];ee+=v,ae+=v}}}}}}return t.makeTensorInfo(k.shape,k.dtype,k.values)}const bS={kernelName:Ho,backendName:"cpu",kernelFunc:Og};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wS(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:a}=e,{strides:o,dilations:i,pad:c,dimRoundingMode:l,filterShape:u}=s;te([r,a],"depthwiseConv2dNativeBackpropFilter");const d=je(r.shape,u,o,i,c,l,!0),{strideHeight:p,strideWidth:h,filterHeight:f,filterWidth:m}=d,g=new Ge(d.filterShape,"float32"),y=d.padInfo.left,x=d.padInfo.top,w=d.outChannels/d.inChannels,$=t.data.get(r.dataId).values,v=new Ge(r.shape,r.dtype,$),k=t.data.get(a.dataId).values,I=new Ge(a.shape,a.dtype,k);for(let S=0;S<f;++S){const A=Math.max(0,Math.ceil((x-S)/p)),R=Math.min(d.outHeight,(d.inHeight+x-S)/p);for(let _=0;_<m;++_){const D=Math.max(0,Math.ceil((y-_)/h)),F=Math.min(d.outWidth,(d.inWidth+y-_)/h);for(let P=0;P<d.outChannels;++P){const L=Math.trunc(P/w),O=P%w;let z=0;for(let V=0;V<d.batchSize;++V)for(let U=A;U<R;++U){const G=S+U*p-x;for(let H=D;H<F;++H){const j=_+H*h-y;z+=v.get(V,G,j,L)*I.get(V,U,H,P)}}g.set(z,S,_,L,O)}}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}const $S={kernelName:qo,backendName:"cpu",kernelFunc:wS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vS(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:a}=e,{strides:o,dilations:i,pad:c,dimRoundingMode:l,inputShape:u}=s;te([r,a],"depthwiseConv2DNativeBackpropInput");const d=se(r.shape),p=se(a.shape),h=je(u,a.shape,o,i,c,l,!0),f=new Ge(h.inShape,"float32"),m=f.values,[g,y,x]=f.strides,w=t.data.get(r.dataId).values,[$,v,k]=d,I=t.data.get(a.dataId).values,[S,A,R]=p,{batchSize:_,filterHeight:D,filterWidth:F,inChannels:P,inHeight:L,inWidth:O,outChannels:z,outHeight:V,outWidth:U,strideHeight:G,strideWidth:H}=h,j=D-1-h.padInfo.top,q=F-1-h.padInfo.left,X=z/P;for(let Y=0;Y<_;++Y)for(let J=0;J<P;++J)for(let ee=0;ee<L;++ee){const ae=ee-j,oe=Math.max(0,Math.ceil(ae/G)),le=Math.min(V,(D+ae)/G);for(let fe=0;fe<O;++fe){const be=fe-q,Oe=Math.max(0,Math.ceil(be/H)),Re=Math.min(U,(F+be)/H);let ke=0;for(let Ie=oe;Ie<le;++Ie){const _e=Ie*G-ae;for(let Be=Oe;Be<Re;++Be){const an=Be*H-be,Xe=$*Y+v*Ie+k*Be,qt=S*(D-1-_e)+A*(F-1-an)+R*J;for(let kt=0;kt<X;++kt){const Kn=J*X+kt,Mt=w[Xe+Kn],on=I[qt+kt];ke+=Mt*on}}}m[g*Y+y*ee+x*fe+J]=ke}}return t.makeTensorInfo(f.shape,f.dtype,f.values)}const CS={kernelName:jo,backendName:"cpu",kernelFunc:vS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NS(n){const{inputs:e,backend:t}=n,{x:s}=e,r=B(s.shape),a=t.data.get(s.dataId).values,o=ue([r,r],s.dtype),i=o.values;for(let l=0;l<a.length;l++)i[l*r+l]=a[l];const c=[...s.shape,...s.shape];return t.makeTensorInfo(c,o.dtype,o.values)}const kS={kernelName:Ko,backendName:"cpu",kernelFunc:NS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IS={kernelName:Xo,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r}=n,{strides:a,pad:o,dilations:i}=t,c=e,l=c.data.get(s.dataId).values,u=s.shape.length,d=c.data.get(r.dataId).values,p=r.shape.length,{batchSize:h,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:x,padInfo:w,strideHeight:$,strideWidth:v,filterHeight:k,filterWidth:I,dilationHeight:S,dilationWidth:A,outShape:R}=Aa(s.shape,r.shape,a,o,"NHWC",i),_=B(R),D=R.length,F=ot(s.dtype,_);for(let L=0;L<h;++L)for(let O=0;O<y;++O){const z=O*$-w.top;for(let V=0;V<x;++V){const U=V*v-w.left;for(let G=0;G<g;++G){let H=Number.MIN_SAFE_INTEGER;for(let q=0;q<k;++q){const X=z+q*S;if(X>=0&&X<f)for(let Y=0;Y<I;++Y){const J=U+Y*A;if(J>=0&&J<m){const ee=Wt([L,X,J,G],u,se(s.shape)),ae=Wt([q,Y,G],p,se(r.shape)),oe=l[ee]+d[ae];oe>H&&(H=oe)}}}const j=Wt([L,O,V,G],D,se(R));F[j]=H}}}return{dataId:c.write(Tn(F,s.dtype),R,s.dtype),shape:R,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SS={kernelName:Wl,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:a}=n,{strides:o,pad:i,dilations:c}=t,l=e,u=St(s.shape,l.data.get(s.dataId).values),d=St(r.shape,l.data.get(r.dataId).values),{batchSize:p,inHeight:h,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:x,strideHeight:w,strideWidth:$,filterHeight:v,filterWidth:k,dilationHeight:I,dilationWidth:S,outShape:A}=Aa(s.shape,r.shape,o,i,"NHWC",c);C(a.rank===A.length,()=>`Error in ${Wl}, dy must have the same rank as output ${A.length}, but got ${a.rank}`);const R=St(A,l.data.get(a.dataId).values),_=Al(r.shape,r.dtype);for(let F=0;F<p;++F)for(let P=0;P<g;++P){const L=P*w-x.top;for(let O=0;O<y;++O){const z=O*$-x.left;for(let V=0;V<m;++V){let U=Number.MIN_SAFE_INTEGER,G=0,H=0;for(let j=0;j<v;++j){const q=L+j*I;if(q>=0&&q<h)for(let X=0;X<k;++X){const Y=z+X*S;if(Y>=0&&Y<f){const J=u[F][q][Y][V]+d[j][X][V];J>U&&(U=J,G=j,H=X)}}}_[G][H][V]+=R[F][P][O][V]}}}return{dataId:l.write(Tn(_,s.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TS={kernelName:Ml,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:r,dy:a}=n,{strides:o,pad:i,dilations:c}=t,l=e,u=St(s.shape,l.data.get(s.dataId).values),d=St(r.shape,l.data.get(r.dataId).values),{batchSize:p,inHeight:h,inWidth:f,inChannels:m,outHeight:g,outWidth:y,padInfo:x,strideHeight:w,strideWidth:$,filterHeight:v,filterWidth:k,dilationHeight:I,dilationWidth:S,outShape:A}=Aa(s.shape,r.shape,o,i,"NHWC",c);C(a.rank===A.length,()=>`Error in ${Ml}, dy must have the same rank as output ${A.length}, but got ${a.rank}`);const R=St(A,l.data.get(a.dataId).values),_=Al(s.shape,s.dtype);for(let F=0;F<p;++F)for(let P=0;P<g;++P){const L=P*w-x.top;for(let O=0;O<y;++O){const z=O*$-x.left;for(let V=0;V<m;++V){let U=Number.MIN_SAFE_INTEGER,G=L<0?0:L,H=z<0?0:z;for(let j=0;j<v;++j){const q=L+j*I;if(q>=0&&q<h)for(let X=0;X<k;++X){const Y=z+X*S;if(Y>=0&&Y<f){const J=u[F][q][Y][V]+d[j][X][V];J>U&&(U=J,G=q,H=Y)}}}_[F][G][H][V]+=R[F][P][O][V]}}}return{dataId:l.write(Tn(_,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qa(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,keepDims:o}=s;te(r,"sum");let i;r.dtype==="bool"?i=Gn({inputs:{x:r},backend:t,attrs:{dtype:"int32"}}):i=sn({inputs:{x:r},backend:t});const c=i.shape.length,l=ge(a,i.shape),u=Me(l,c);let d=l,p=i;u!=null&&(p=Et({inputs:{x:i},backend:t,attrs:{perm:u}}),d=We(d.length,c)),Je("sum",d,p.shape.length);const[h,f]=Ze(p.shape,d),m=xt(p.dtype,"int32");let g=Gc(t,h,m);const y=B(f),x=t.data.get(g.dataId).values,w=t.data.get(p.dataId).values;for(let $=0;$<x.length;++$){const v=$*y;let k=0;for(let I=0;I<y;++I)k+=w[v+I];x[$]=k}if(o){const $=He(g.shape,l),v=g;g=Fe({inputs:{x:g},backend:t,attrs:{shape:$}}),t.disposeIntermediateTensorInfo(v)}return t.disposeIntermediateTensorInfo(i),u!=null&&t.disposeIntermediateTensorInfo(p),g}const ES={kernelName:Pi,backendName:"cpu",kernelFunc:Qa};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RS(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,a=e,{allDims:o,summedDims:i,idDims:c}=Od(r,a.length);Ld(o.length,c,a);const{path:l,steps:u}=Bd(i,c),d=u.length;let p=null,h=o.length;const f=[];for(let m=0;m<d;++m){for(const g of u[m]){const{permutationIndices:y,expandDims:x}=Pd(h,c[g]);let w;Vd(y)?w=a[g]:(w=Et({inputs:{x:a[g]},backend:t,attrs:{perm:y}}),f.push(w));const $=w.shape.slice();for(let v=0;v<x.length;++v)$.splice(x[v],0,1);$e(w.shape,$)||(w=Fe({inputs:{x:w},backend:t,attrs:{shape:$}}),f.push(w)),p===null?p=w:(p=Hc({inputs:{a:w,b:p},backend:t}),f.push(p))}m<d-1&&(l[m]>=0&&(p=Qa({inputs:{x:p},backend:t,attrs:{axis:l[m]-(o.length-h),keepDims:!1}}),f.push(p)),h--)}for(const m of f)m!==p&&t.disposeIntermediateTensorInfo(m);return p}const _S={kernelName:Yo,backendName:"cpu",kernelFunc:RS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AS(n){const{inputs:e,backend:t}=n,{dy:s,y:r}=e;te([s,r],"eluGrad");const a=new Float32Array(B(r.shape)),o=t.data.get(r.dataId).values,i=t.data.get(s.dataId).values;for(let c=0;c<o.length;++c){const l=o[c];l>=1?a[c]=i[c]:a[c]=i[c]*(l+1)}return t.makeTensorInfo(r.shape,"float32",a)}const DS={kernelName:zl,backendName:"cpu",kernelFunc:AS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FS=Sd,OS=Td,PS=Ed,LS=Rd,BS=_d,VS=Ad,MS=we(_r,n=>{const e=Math.sign(n),t=Math.abs(n),s=1/(1+FS*t);return e*(1-((((VS*s+BS)*s+LS)*s+PS)*s+OS)*s*Math.exp(-t*t))}),WS={kernelName:_r,backendName:"cpu",kernelFunc:MS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qc(n){const{inputs:e,backend:t,attrs:s}=n,{input:r}=e,{dim:a}=s,o=r.shape.length,i=r.shape.slice();let c=a;return a<0&&(C(-(o+1)<=a,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),c=o+a+1),i.splice(c,0,1),Fe({inputs:{x:r},backend:t,attrs:{shape:i}})}const zS={kernelName:Qo,backendName:"cpu",kernelFunc:qc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const US=ze((n,e)=>n/e),Yd=Ke(Er,US),Qd={kernelName:Er,backendName:"cpu",kernelFunc:Yd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pg(n,e,t){const s=n.shape,r=s[0],a=s[1],o=t.data.get(n.dataId),i=o.complexTensorInfos.real,c=o.complexTensorInfos.imag,l=[r,a],u=B(l),d=Ue("float32",u),p=Ue("float32",u);for(let g=0;g<r;g++){const y=ws({inputs:{x:i},backend:t,attrs:{begin:[g,0],size:[1,a]}}),x=ws({inputs:{x:c},backend:t,attrs:{begin:[g,0],size:[1,a]}}),w=vt({inputs:{real:y,imag:x},backend:t}),{real:$,imag:v}=GS(w,e,t),k=xn($,v);for(let I=0;I<a;I++){const S=Dd(k,I);d[g*a+I]=S.real,p[g*a+I]=S.imag}t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(w)}const h=t.makeTensorInfo(l,"float32",d),f=t.makeTensorInfo(l,"float32",p),m=vt({inputs:{real:h,imag:f},backend:t});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),m}function GS(n,e,t){const s=B(n.shape),r=t.data.get(n.dataId),a=t.data.get(r.complexTensorInfos.real.dataId).values,o=t.data.get(r.complexTensorInfos.imag.dataId).values;if(HS(s)){const i=Zd(a,o,s,e,t),c=[n.shape[0],n.shape[1]];if(e){const l=t.makeTensorInfo(c,"float32",i.real),u=t.makeTensorInfo(c,"float32",i.imag),d=t.makeTensorInfo([],"float32",dn(s,"float32")),p=sn({inputs:{x:d},backend:t}),h=Qd.kernelFunc({inputs:{a:l,b:d},backend:t}),f=Qd.kernelFunc({inputs:{a:u,b:p},backend:t}),m=t.data.get(h.dataId).values,g=t.data.get(f.dataId).values;return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),{real:m,imag:g}}return i}else{const i=xn(a,o),c=qS(i,s,e);return Sm(c)}}function HS(n){return(n&n-1)==0}function Zd(n,e,t,s,r){if(t===1)return{real:n,imag:e};const a=xn(n,e),o=t/2,i=Tm(a),c=i.real,l=i.imag,u=[c.length],d=r.makeTensorInfo(u,"float32",c),p=r.makeTensorInfo(u,"float32",l),h=vt({inputs:{real:d,imag:p},backend:r}),f=Em(a),m=f.real,g=f.imag,y=[m.length],x=r.makeTensorInfo(y,"float32",m),w=r.makeTensorInfo(y,"float32",g),$=vt({inputs:{real:x,imag:w},backend:r}),v=Zd(c,l,o,s,r),k=v.real,I=v.imag,S=[k.length],A=r.makeTensorInfo(S,"float32",k),R=r.makeTensorInfo(S,"float32",I),_=vt({inputs:{real:A,imag:R},backend:r}),D=Zd(m,g,o,s,r),F=D.real,P=D.imag,L=[F.length],O=r.makeTensorInfo(L,"float32",F),z=r.makeTensorInfo(L,"float32",P),V=vt({inputs:{real:O,imag:z},backend:r}),U=_m(t,s),G=[U.real.length],H=r.makeTensorInfo(G,"float32",U.real),j=r.makeTensorInfo(G,"float32",U.imag),q=vt({inputs:{real:H,imag:j},backend:r}),X=Hc({inputs:{a:q,b:V},backend:r}),Y=Xa({inputs:{a:_,b:X},backend:r}),J=jd({inputs:{a:_,b:X},backend:r}),ee=bs({inputs:{input:Y},backend:r}),ae=bs({inputs:{input:J},backend:r}),oe=Zs({inputs:{input:Y},backend:r}),le=Zs({inputs:{input:J},backend:r}),fe=Js({inputs:[ee,ae],backend:r,attrs:{axis:0}}),be=Js({inputs:[oe,le],backend:r,attrs:{axis:0}}),Oe=r.data.get(fe.dataId).values,Re=r.data.get(be.dataId).values;return r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(w),r.disposeIntermediateTensorInfo($),r.disposeIntermediateTensorInfo(A),r.disposeIntermediateTensorInfo(R),r.disposeIntermediateTensorInfo(_),r.disposeIntermediateTensorInfo(O),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(X),r.disposeIntermediateTensorInfo(Y),r.disposeIntermediateTensorInfo(J),r.disposeIntermediateTensorInfo(ee),r.disposeIntermediateTensorInfo(oe),r.disposeIntermediateTensorInfo(ae),r.disposeIntermediateTensorInfo(le),r.disposeIntermediateTensorInfo(fe),r.disposeIntermediateTensorInfo(be),{real:Oe,imag:Re}}function qS(n,e,t){const s=new Float32Array(e*2);for(let r=0;r<e;r++){let a=0,o=0;for(let i=0;i<e;i++){const c=Am(r*i,e,t),l=Dd(n,i);a+=l.real*c.real-l.imag*c.imag,o+=l.real*c.imag+l.imag*c.real}t&&(a/=e,o/=e),Rm(s,a,o,r)}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jS(n){const{inputs:e,backend:t}=n,{input:s}=e,r=B(s.shape),a=s.shape[s.shape.length-1],o=r/a,i=Fe({inputs:{x:s},backend:t,attrs:{shape:[o,a]}}),c=Pg(i,!1,t),l=Fe({inputs:{x:c},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(c),l}const KS={kernelName:Zo,backendName:"cpu",kernelFunc:jS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jd(n){const{backend:e,attrs:t}=n,{shape:s,value:r,dtype:a}=t,o=a||Ts(r),i=ot(o,B(s));return YS(i,r,o),e.makeTensorInfo(s,o,i)}const XS={kernelName:Jo,backendName:"cpu",kernelFunc:Jd};function YS(n,e,t){n.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QS={kernelName:ei,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,r=t,a=Ue(s.dtype,B(s.shape)),[o,i,c,l]=s.shape,u=r.data.get(s.dataId).values;for(let p=0;p<o;p++){const h=p*c*i*l;for(let f=0;f<i;f++){const m=f*(c*l);for(let g=0;g<c;g++){const y=g*l;for(let x=0;x<l;x++){const w=Math.round(c-g-1),$=h+m+y+x;let v=u[$];if(w>=0&&w<c){const k=w*l,I=h+m+k+x;v=u[I]}a[$]=v}}}}return{dataId:r.write(a,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZS=ze((n,e)=>Math.floor(n/e)),JS=Ke(Pr,ZS,null,"int32"),eT={kernelName:Pr,backendName:"cpu",kernelFunc:JS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tT(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:a,bias:o,preluActivationWeights:i}=e,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=s;let m=Fg({inputs:{x:r,filter:a},backend:t,attrs:{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:p}});if(o){const g=m;m=Xa({inputs:{a:m,b:o},backend:t}),t.disposeIntermediateTensorInfo(g)}if(h){const g=m;m=Kd(t,m,h,i,f),t.disposeIntermediateTensorInfo(g)}return m}const nT={kernelName:$a,backendName:"cpu",kernelFunc:tT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sT(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:a,bias:o,preluActivationWeights:i}=e,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=s;let m=Og({inputs:{x:r,filter:a},backend:t,attrs:{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:p}});if(o){const g=m;m=Xa({inputs:{a:m,b:o},backend:t}),t.disposeIntermediateTensorInfo(g)}if(h){const g=m;m=Kd(t,m,h,i,f),t.disposeIntermediateTensorInfo(g)}return m}const rT={kernelName:va,backendName:"cpu",kernelFunc:sT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aT(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,a=B(s.shape),o=r.shape,i=o[o.length-1],[c,l,u,d]=fc(s,r);if(l===0)return t.makeTensorInfo(c,s.dtype,[]);const p=t.data.get(r.dataId).values,h=t.bufferSync(s),f=Ym(p,h,s.dtype,l,i,u,d,s.shape,a);return t.makeTensorInfo(c,s.dtype,f.values)}const oT={kernelName:si,backendName:"cpu",kernelFunc:aT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iT(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:a}=e,{axis:o,batchDims:i}=s;te([r,a],"gatherV2");const c=ge(o,r.shape)[0],l=t.data.get(a.dataId).values,u=r.shape[c];for(let $=0;$<l.length;++$){const v=l[$];C(v<=u-1&&v>=0,()=>`GatherV2: the index value ${v} is not in [0, ${u-1}]`)}let d=i;i==null&&(d=0);const p=B(a.shape),h=Wd(r,a,c,d),f=Fe({inputs:{x:r},backend:t,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),m=Fe({inputs:{x:a},backend:t,attrs:{shape:[h.batchSize,p/h.batchSize]}}),g=[h.batchSize,h.outerSize,p/h.batchSize,h.sliceSize],y=t.bufferSync(m),x=t.bufferSync(f),w=Qm(x,y,g);return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),t.makeTensorInfo(h.outputShape,w.dtype,w.values)}const cT={kernelName:ni,backendName:"cpu",kernelFunc:iT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lT(n){const{inputs:e,backend:t}=n,{input:s}=e,r=B(s.shape),a=s.shape[s.shape.length-1],o=r/a,i=Fe({inputs:{x:s},backend:t,attrs:{shape:[o,a]}}),c=Pg(i,!0,t),l=Fe({inputs:{x:c},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(c),l}const uT={kernelName:ri,backendName:"cpu",kernelFunc:lT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dT=we(Mr,n=>Number.isFinite(n)?1:0,"bool"),pT={kernelName:Mr,backendName:"cpu",kernelFunc:dT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hT=we(Wr,n=>Math.abs(n)===1/0?1:0,"bool"),fT={kernelName:Wr,backendName:"cpu",kernelFunc:hT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mT=we(zr,n=>Number.isNaN(n)?1:0,"bool"),gT={kernelName:zr,backendName:"cpu",kernelFunc:mT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yT(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:a}=t,o=ng(s,r,a);return e.makeTensorInfo([o.length],"float32",o)}const xT={kernelName:ii,backendName:"cpu",kernelFunc:yT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bT=we(qr,n=>Math.log1p(n)),wT={kernelName:qr,backendName:"cpu",kernelFunc:bT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $T=ze((n,e)=>n&&e),vT=Ke(jr,$T,null,"bool"),CT={kernelName:jr,backendName:"cpu",kernelFunc:vT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NT=we(Kr,n=>n?0:1,"bool"),kT={kernelName:Kr,backendName:"cpu",kernelFunc:NT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IT=ze((n,e)=>n||e),ST=Ke(Xr,IT,null,"bool"),TT={kernelName:Xr,backendName:"cpu",kernelFunc:ST};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ET(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:a,bias:o,alpha:i,beta:c}=s;te(r,"LRN");const l=r.shape[3],u=l-1,d=t.data.get(r.dataId).values,p=B(r.shape),h=new Float32Array(p);function f(m){const g=m%l;let y=m-g+Math.max(0,g-a);const x=m-g+Math.min(g+a,u);let w=0;for(;y<=x;y++){const $=d[y];w+=$*$}return w}for(let m=0;m<p;m++){const g=f(m),y=d[m]*Math.pow(o+i*g,-c);h[m]=y}return t.makeTensorInfo(r.shape,r.dtype,h)}const RT={kernelName:ci,backendName:"cpu",kernelFunc:ET};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _T(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,y:a,dy:o}=e,{depthRadius:i,bias:c,alpha:l,beta:u}=s;te(o,"LRNGrad");const d=B(o.shape),p=o.shape[3],h=t.data.get(o.dataId).values,f=t.data.get(r.dataId).values,m=t.data.get(a.dataId).values,g=new Float32Array(d),y=d;for(let x=0;x<y;x++){const w=x%p,$=x-w+Math.max(0,w-i),v=x-w+Math.min(p,w+i+1);let k=0;for(let I=$;I<v;I++)k+=Math.pow(f[I],2);k=l*k+c;for(let I=$;I<v;I++){let S=-2*l*u*f[I]*m[x]/k;x===I&&(S+=Math.pow(k,-u)),S*=h[x],g[I]+=S}}return t.makeTensorInfo(o.shape,r.dtype,g)}const AT={kernelName:Ul,backendName:"cpu",kernelFunc:_T};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lg(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:a,keepDims:o}=s,i=t;let c=r.shape;const l=c.length,u=ge(a,c);let d=u;const p=Me(d,l);let h=i.data.get(r.dataId).values;if(p!=null){const $=new Array(l);for(let v=0;v<$.length;v++)$[v]=c[p[v]];h=Hd(h,c,r.dtype,p,$),d=We(d.length,l),c=$}te(r,"max"),Je("max",d,l);const[f,m]=Ze(c,d),g=B(m),y=rg(h,g,f,r.dtype),x=i.write(y,f,r.dtype);let w=f;return o&&(w=He(f,u)),{dataId:x,shape:w,dtype:r.dtype}}const DT={kernelName:li,backendName:"cpu",kernelFunc:Lg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FT(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;te(r,"maxPool");const{filterSize:a,strides:o,pad:i,dimRoundingMode:c}=s,l=1;C(st(o,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const u=Pt(r.shape,a,o,l,i,c);let d;if(u.filterWidth===1&&u.filterHeight===1&&$e(u.inShape,u.outShape))d=sn({inputs:{x:r},backend:t});else{const p=t.data.get(r.dataId).values,h=se(r.shape),f=Xd(p,r.shape,r.dtype,h,u,"max");d=t.makeTensorInfo(u.outShape,r.dtype,f.values)}return d}const OT={kernelName:ui,backendName:"cpu",kernelFunc:FT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PT(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:a,strides:o,pad:i,dimRoundingMode:c,dataFormat:l}=s;te(r,"maxPool3d");const u=hn(r.shape,a,o,1,i,c,l),d=t.data.get(r.dataId).values,p=Dg(d,r.shape,r.dtype,se(r.shape),u,"max");return t.makeTensorInfo(p.shape,"float32",p.values)}const LT={kernelName:di,backendName:"cpu",kernelFunc:PT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BT(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:a}=e,{filterSize:o,strides:i,pad:c,dimRoundingMode:l}=s;te([r,a],"maxPool3DGrad");const u=hn(a.shape,o,i,1,c,l),d=t.bufferSync(a),p=SI(d,u),h=u.strideDepth,f=u.strideHeight,m=u.strideWidth,g=u.dilationDepth,y=u.dilationHeight,x=u.dilationWidth,w=u.effectiveFilterDepth,$=u.effectiveFilterHeight,v=u.effectiveFilterWidth,k=w-1-u.padInfo.front,I=v-1-u.padInfo.left,S=$-1-u.padInfo.top,A=ue(a.shape,"float32"),R=t.bufferSync(r);for(let _=0;_<u.batchSize;++_)for(let D=0;D<u.inChannels;++D)for(let F=0;F<u.inDepth;++F)for(let P=0;P<u.inHeight;++P)for(let L=0;L<u.inWidth;++L){const O=F-k,z=P-S,V=L-I;let U=0;for(let G=0;G<w;G+=g){const H=(O+G)/h;if(!(H<0||H>=u.outDepth||Math.floor(H)!==H))for(let j=0;j<$;j+=y){const q=(z+j)/f;if(!(q<0||q>=u.outHeight||Math.floor(q)!==q))for(let X=0;X<v;X+=x){const Y=(V+X)/m;if(Y<0||Y>=u.outWidth||Math.floor(Y)!==Y)continue;const J=w*$*v-1-p.get(_,H,q,Y,D),ee=G*$*v+j*v+X,ae=J===ee?1:0;if(ae===0)continue;U+=R.get(_,H,q,Y,D)*ae}}}A.set(U,_,F,P,L,D)}return t.makeTensorInfo(A.shape,A.dtype,A.values)}const VT={kernelName:Hl,backendName:"cpu",kernelFunc:BT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MT(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:a,output:o}=e,i=a;te([a,o],"maxPoolGrad");const{filterSize:c,strides:l,pad:u,dimRoundingMode:d}=s,p=Pt(i.shape,c,l,1,u,d),h=t.data.get(i.dataId).values,f=ue(p.outShape,i.dtype,Ag(h,i.shape,i.dtype,p).values),m=p.strideHeight,g=p.strideWidth,y=p.dilationHeight,x=p.dilationWidth,w=p.effectiveFilterHeight,$=p.effectiveFilterWidth,v=$-1-p.padInfo.left,k=w-1-p.padInfo.top,I=ue(i.shape,"float32"),S=t.data.get(r.dataId).values,A=ue(r.shape,"float32",S);for(let R=0;R<p.batchSize;++R)for(let _=0;_<p.inChannels;++_)for(let D=0;D<p.inHeight;++D)for(let F=0;F<p.inWidth;++F){const P=D-k,L=F-v;let O=0;for(let z=0;z<w;z+=y){const V=(P+z)/m;if(!(V<0||V>=p.outHeight||Math.floor(V)!==V))for(let U=0;U<$;U+=x){const G=(L+U)/g;if(G<0||G>=p.outWidth||Math.floor(G)!==G)continue;const H=w*$-1-f.get(R,V,G,_),j=z*$+U,q=H===j?1:0;if(q===0)continue;O+=A.get(R,V,G,_)*q}}I.set(O,R,D,F,_)}return t.makeTensorInfo(I.shape,I.dtype,I.values)}const WT={kernelName:Gl,backendName:"cpu",kernelFunc:MT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zT(n,e,t,s,r){const a=se(e),o=Xd(n,e,t,a,r,"max"),i=Ag(n,e,t,r,!0,s);return[o.values,i.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UT={kernelName:pi,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:a,pad:o,includeBatchInIndex:i}=e,c=t;te(s,"MaxPoolWithArgmax");const l=c.data.get(s.dataId).values,u=Pt(s.shape,r,a,[1,1],o),[d,p]=zT(l,s.shape,s.dtype,i,u),h=c.write(d,u.outShape,s.dtype),f=c.write(p,u.outShape,s.dtype);return[{dataId:h,shape:u.outShape,dtype:s.dtype},{dataId:f,shape:u.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GT(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,keepDims:o}=s,i=ge(a,r.shape),l=Ze(r.shape,i)[1],u=B(l),d=[],p=t.makeTensorInfo([],"float32",new Float32Array([u]));d.push(p);const h=Gn({inputs:{x:r},backend:t,attrs:{dtype:"float32"}});d.push(h);const f=Yd({inputs:{a:h,b:p},backend:t});d.push(f);const m=Qa({inputs:{x:f},backend:t,attrs:{axis:a,keepDims:o}});return d.forEach(g=>t.disposeIntermediateTensorInfo(g)),m}const HT={kernelName:hi,backendName:"cpu",kernelFunc:GT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qT(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,keepDims:o}=s;te(r,"min");const i=ge(a,r.shape);let c=i;const l=Me(c,r.shape.length);let u=r;l!=null&&(u=Et({inputs:{x:r},backend:t,attrs:{perm:l}}),c=We(c.length,r.shape.length)),Je("min",c,u.shape.length);const[d,p]=Ze(u.shape,c),h=B(p),f=Qe(B(d),u.dtype),m=t.data.get(u.dataId).values;for(let y=0;y<f.length;++y){const x=y*h;let w=m[x];for(let $=0;$<h;++$){const v=m[x+$];(Number.isNaN(v)||v<w)&&(w=v)}f[y]=w}l!=null&&t.disposeIntermediateTensorInfo(u);const g=t.makeTensorInfo(d,u.dtype,f);if(o){const y=He(d,i),x=Fe({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),x}return g}const jT={kernelName:fi,backendName:"cpu",kernelFunc:qT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KT(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:a,mode:o}=s;te(r,"mirrorPad");const i=a.map((w,$)=>w[0]+r.shape[$]+w[1]),c=a.map(w=>w[0]),l=a.map((w,$)=>w[0]+r.shape[$]),u=o==="reflect"?0:1,d=t.data.get(r.dataId).values,p=r.shape.length,h=se(r.shape),f=B(i),m=i.length,g=se(i),y=Ue(r.dtype,f);for(let w=0;w<f;w++){let $=Es(w,m,g);for(let k=0;k<m;k++)$[k]<c[k]?$[k]=c[k]*2-$[k]-u:$[k]>=l[k]&&($[k]=(l[k]-1)*2-$[k]+u);$=$.map((k,I)=>k-c[I]);const v=Wt($,p,h);y[w]=d[v]}return{dataId:t.write(y,i,r.dtype),shape:i,dtype:r.dtype}}const XT={kernelName:mi,backendName:"cpu",kernelFunc:KT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YT=ze((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e}),QT=Ke(Zr,YT),ZT={kernelName:Zr,backendName:"cpu",kernelFunc:QT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bg(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:a}=s,o=r.shape.length;let i=a;if(i===-1&&(i=o-1),i!==o-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${o} and dim was ${i}`);const c=ge([i],r.shape),l=Lg({inputs:{x:r},backend:t,attrs:{reductionIndices:c,keepDims:!1}}),u=He(l.shape,c),d=Fe({inputs:{x:l},backend:t,attrs:{shape:u}}),p=jd({inputs:{a:r,b:d},backend:t}),h=jm({inputs:{x:p},backend:t}),f=Qa({inputs:{x:h},backend:t,attrs:{axis:c,keepDims:!1}}),m=Fe({inputs:{x:f},backend:t,attrs:{shape:u}}),g=Yd({inputs:{a:h,b:m},backend:t});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(m),g}const JT={kernelName:Vi,backendName:"cpu",kernelFunc:Bg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eE(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:a,seed:o,normalized:i}=s;te(r,"multinomial");const c=i?r:Bg({inputs:{logits:r},backend:t,attrs:{dim:-1}}),l=c.shape[0],u=c.shape[1],d=t.data.get(c.dataId).values,p=[l,a],h=Qe(B(p),"int32");for(let f=0;f<l;++f){const m=f*u,g=new Float32Array(u-1);g[0]=d[m];for(let w=1;w<g.length;++w)g[w]=g[w-1]+d[m+w];const y=Nc.alea(o.toString()),x=f*a;for(let w=0;w<a;++w){const $=y();h[x+w]=g.length;for(let v=0;v<g.length;v++)if($<g[v]){h[x+w]=v;break}}}return i||t.disposeIntermediateTensorInfo(c),t.makeTensorInfo(p,"int32",h)}const tE={kernelName:gi,backendName:"cpu",kernelFunc:eE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nE=Ac;function sE(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:a}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:c}=s;te(r,"NonMaxSuppression");const l=t.data.get(r.dataId).values,u=t.data.get(a.dataId).values,{selectedIndices:d}=nE(l,u,o,i,c);return t.makeTensorInfo([d.length],"int32",new Int32Array(d))}const rE={kernelName:xi,backendName:"cpu",kernelFunc:sE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aE=Dc;function oE(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:a}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:c,padToMaxOutputSize:l}=s;te(r,"NonMaxSuppressionPadded");const u=t.data.get(r.dataId).values,d=t.data.get(a.dataId).values,{selectedIndices:p,validOutputs:h}=aE(u,d,o,i,c,l);return[t.makeTensorInfo([p.length],"int32",new Int32Array(p)),t.makeTensorInfo([],"int32",new Int32Array([h]))]}const iE={kernelName:bi,backendName:"cpu",kernelFunc:oE};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cE=Fc;function lE(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:a}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:c,softNmsSigma:l}=s;te(r,"NonMaxSuppressionWithScore");const u=t.data.get(r.dataId).values,d=t.data.get(a.dataId).values,p=o,h=i,f=c,m=l,{selectedIndices:g,selectedScores:y}=cE(u,d,p,h,f,m);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const uE={kernelName:wi,backendName:"cpu",kernelFunc:lE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dE(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{depth:a,onValue:o,offValue:i}=s;te(r,"oneHot");const c=B(r.shape),l=new Float32Array(c*a);l.fill(i);const u=t.data.get(r.dataId).values;for(let d=0;d<c;++d)u[d]>=0&&u[d]<a&&(l[d*a+u[d]]=o);return t.makeTensorInfo([...r.shape,a],"int32",l)}const pE={kernelName:vi,backendName:"cpu",kernelFunc:dE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jc(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const r=bs({inputs:{input:s},backend:t}),a=jc({inputs:{x:r},backend:t}),o=Zs({inputs:{input:s},backend:t}),i=jc({inputs:{x:o},backend:t}),c=vt({inputs:{real:a,imag:i},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),c}else return Jd({backend:t,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const hE={kernelName:tc,backendName:"cpu",kernelFunc:jc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vg(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const r=bs({inputs:{input:s},backend:t}),a=Vg({inputs:{x:r},backend:t}),o=Zs({inputs:{input:s},backend:t}),i=jc({inputs:{x:o},backend:t}),c=vt({inputs:{real:a,imag:i},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),c}else return Jd({backend:t,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const fE={kernelName:$i,backendName:"cpu",kernelFunc:Vg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mg(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return qc({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const a=e[0].shape,o=e[0].dtype;e.forEach(u=>{Ye(a,u.shape,"All tensors passed to stack must have matching shapes"),C(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const i=[],c=e.map(u=>{const d=qc({inputs:{input:u},backend:t,attrs:{dim:r}});return i.push(d),d}),l=Js({inputs:c,backend:t,attrs:{axis:r}});return i.forEach(u=>t.disposeIntermediateTensorInfo(u)),l}const mE={kernelName:Ci,backendName:"cpu",kernelFunc:Mg};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gE(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:a,constantValue:o}=s;te(r,"pad");const i=a.map((x,w)=>x[0]+r.shape[w]+x[1]),c=a.map(x=>x[0]),l=t.data.get(r.dataId).values,u=B(r.shape),d=r.shape.length,p=se(r.shape),h=B(i),f=i.length,m=se(i),g=Ue(r.dtype,h);o!==0&&g.fill(o);for(let x=0;x<u;x++){const $=Es(x,d,p).map((k,I)=>k+c[I]),v=Wt($,f,m);g[v]=l[x]}return{dataId:t.write(g,i,r.dtype),shape:i,dtype:r.dtype}}const Wg={kernelName:Ni,backendName:"cpu",kernelFunc:gE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yE=ze((n,e)=>Math.pow(n,e)),xE=Ke(ta,yE),bE={kernelName:ta,backendName:"cpu",kernelFunc:xE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wE(n){const{backend:e,attrs:t}=n,{start:s,stop:r,dtype:a,step:o}=t,i=ug(s,r,o,a);return e.makeTensorInfo([i.length],a,i)}const $E={kernelName:Si,backendName:"cpu",kernelFunc:wE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vE=we(na,n=>1/n),CE={kernelName:na,backendName:"cpu",kernelFunc:vE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NE(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:a,halfPixelCenters:o,size:i}=s;te(r,"resizeBilinear");const c=se(r.shape),[l,u]=i,[d,p,h,f]=r.shape,m=t.data.get(r.dataId).values,g=new Float32Array(B([d,l,u,f])),y=[a&&l>1?p-1:p,a&&u>1?h-1:h],x=[a&&l>1?l-1:l,a&&u>1?u-1:u];let w=0;const $=y[0]/x[0],v=y[1]/x[1];for(let k=0;k<d;k++)for(let I=0;I<l;I++){let S;o?S=$*(I+.5)-.5:S=$*I;const A=Math.max(0,Math.floor(S)),R=S-A,_=Math.min(p-1,Math.ceil(S)),D=k*c[0]+A*c[1],F=k*c[0]+_*c[1];for(let P=0;P<u;P++){let L;o?L=v*(P+.5)-.5:L=v*P;const O=Math.max(0,Math.floor(L)),z=L-O,V=Math.min(h-1,Math.ceil(L)),U=D+O*c[2],G=F+O*c[2],H=D+V*c[2],j=F+V*c[2];for(let q=0;q<f;q++){const X=m[U+q],Y=m[G+q],J=m[H+q],ee=m[j+q],ae=X+(J-X)*z,oe=Y+(ee-Y)*z,le=ae+(oe-ae)*R;g[w++]=le}}}return t.makeTensorInfo([d,l,u,f],"float32",g)}const kE={kernelName:_i,backendName:"cpu",kernelFunc:NE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IE(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:a}=e,{alignCorners:o}=s;te([a,r],"resizeBilinearGrad");const i=se(r.shape),[c,l,u,d]=r.shape,[,p,h]=a.shape,f=new Float32Array(c*l*u*d),m=[o&&p>1?l-1:l,o&&h>1?u-1:u],g=[o&&p>1?p-1:p,o&&h>1?h-1:h],y=m[0]/g[0],x=m[1]/g[1],w=t.data.get(a.dataId).values;let $=0;for(let v=0;v<c;v++){const k=v*i[0];for(let I=0;I<p;I++){const S=I*y,A=Math.floor(S),R=Math.min(Math.ceil(S),l-1),_=k+A*i[1],D=k+R*i[1],F=S-A,P=1-F;for(let L=0;L<h;L++){const O=L*x,z=Math.floor(O),V=Math.min(Math.ceil(O),u-1),U=O-z,G=1-U,H=_+z*i[2],j=_+V*i[2],q=D+z*i[2],X=D+V*i[2],Y=P*G,J=P*U,ee=F*G,ae=F*U;for(let oe=0;oe<d;oe++){const le=w[$++];f[H+oe]+=le*Y,f[j+oe]+=le*J,f[q+oe]+=le*ee,f[X+oe]+=le*ae}}}}return t.makeTensorInfo([c,u,l,d],"float32",f)}const SE={kernelName:jl,backendName:"cpu",kernelFunc:IE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TE(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:a,halfPixelCenters:o,size:i}=s;te(r,"resizeNearestNeighbor");const c=se(r.shape),[l,u]=i,[d,p,h,f]=r.shape,m=t.data.get(r.dataId).values,g=new Float32Array(d*l*u*f),y=[a&&l>1?p-1:p,a&&u>1?h-1:h],x=[a&&l>1?l-1:l,a&&u>1?u-1:u],w=y[0]/x[0],$=y[1]/x[1];let v=0;for(let k=0;k<d;k++){const I=k*c[0];for(let S=0;S<l;S++){const A=o?w*(S+.5):w*S;let R=Math.min(p-1,a?Math.round(A):Math.floor(A));o&&(R=Math.max(0,R));const _=I+R*c[1];for(let D=0;D<u;D++){const F=o?$*(D+.5):$*D;let P=Math.min(h-1,a?Math.round(F):Math.floor(F));o&&(P=Math.max(0,P));const L=_+P*c[2];for(let O=0;O<f;O++){const z=m[L+O];g[v++]=z}}}}return t.makeTensorInfo([d,l,u,f],r.dtype,g)}const EE={kernelName:Ri,backendName:"cpu",kernelFunc:TE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RE(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:a}=e,{alignCorners:o}=s;te([a,r],"resizeNearestNeighborGrad");const i=se(r.shape),c=se(a.shape),[l,u,d,p]=r.shape,[,h,f]=a.shape,m=new Float32Array(l*u*d*p),g=t.data.get(a.dataId).values,y=[o&&h>1?u-1:u,o&&f>1?d-1:d],x=[o&&h>1?h-1:h,o&&f>1?f-1:f],w=y[0]/x[0],$=y[1]/x[1],v=1/w,k=1/$,I=Math.ceil(v)*2+2,S=Math.ceil(k)*2+2;for(let A=0;A<l;A++){const R=A*i[0];for(let _=0;_<u;_++){const D=R+_*i[1],F=Math.floor(_*v),P=Math.floor(F-I/2);for(let L=0;L<d;L++){const O=D+L*i[2],z=Math.floor(L*k),V=Math.floor(z-S/2);for(let U=0;U<p;U++){let G=0;for(let H=0;H<I;H++){const j=H+P;if(j<0||j>=h)continue;const q=R+j*c[1],X=j*w,Y=Math.min(u-1,o?Math.round(X):Math.floor(X));if(_===Y)for(let J=0;J<S;J++){const ee=J+V;if(ee<0||ee>=f)continue;const ae=q+ee*c[2],oe=ee*$,le=Math.min(d-1,o?Math.round(oe):Math.floor(oe));L===le&&(G+=g[ae+U])}}m[O+U]=G}}}}return t.makeTensorInfo(r.shape,r.dtype,m)}const _E={kernelName:ql,backendName:"cpu",kernelFunc:RE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AE(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:a}=s;te(r,"reverse");const o=r.shape.length,i=ge(a,r.shape);if(o===0)return sn({inputs:{x:r},backend:t});const c=new Ge(r.shape,r.dtype),l=t.bufferSync(r);for(let u=0;u<c.size;u++){const d=c.indexToLoc(u),p=d.slice();i.forEach(h=>p[h]=r.shape[h]-1-p[h]),c.set(l.get(...p),...d)}return t.makeTensorInfo(c.shape,c.dtype,c.values)}const DE={kernelName:Ai,backendName:"cpu",kernelFunc:AE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FE={kernelName:sc,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:a,center:o}=e,i=t,c=Ue(s.dtype,B(s.shape)),[l,u,d,p]=s.shape,[h,f]=vd(o,u,d),m=255,g=Math.sin(r),y=Math.cos(r),x=i.data.get(s.dataId).values;for(let $=0;$<l;$++){const v=$*d*u*p;for(let k=0;k<u;k++){const I=k*(d*p);for(let S=0;S<d;S++){const A=S*p;for(let R=0;R<p;R++){const _=[l,k,S,R],D=_[2],F=_[1];let P=(D-h)*y-(F-f)*g,L=(D-h)*g+(F-f)*y;P=Math.round(P+h),L=Math.round(L+f);let O=a;if(typeof a!="number"&&(R===3?O=m:O=a[R]),P>=0&&P<d&&L>=0&&L<u){const V=L*(d*p),U=P*p,G=v+V+U+R;O=x[G]}const z=v+I+A+R;c[z]=O}}}}return{dataId:i.write(c,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OE=we(aa,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2==0?e:e+1}),PE={kernelName:aa,backendName:"cpu",kernelFunc:OE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zg(n,e,t,s,r,a,o,i,c,l){const u=[s/r,r],d=n.values,p=e.values;if(s===0)return ue(t,e.dtype);const h=ue(u,e.dtype);h.values.fill(c);for(let f=0;f<a;f++){const m=[];let g=0;for(let y=0;y<o;y++){const x=d[f*o+y];m.push(x),g+=x*i[y]}if(g<0||g>=s/r)throw new Error(`Invalid indices: ${m} does not index into ${t}`);for(let y=0;y<r;y++)l?h.values[g*r+y]+=p[f*r+y]:h.values[g*r+y]=e.rank===0?p[0]:p[f*r+y]}return h}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LE(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:a}=e,{shape:o}=s,{sliceRank:i,numUpdates:c,sliceSize:l,strides:u,outputSize:d}=Vs(a,r,o),p=!0,h=t.bufferSync(r),f=t.bufferSync(a),m=zg(h,f,o,d,l,c,i,u,0,p);return t.makeTensorInfo(o,m.dtype,m.values)}const BE={kernelName:Di,backendName:"cpu",kernelFunc:LE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VE(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:a}=e;te([s,r,a],"select");const o=s.shape.length,i=t.data.get(s.dataId).values,c=t.data.get(r.dataId).values,l=t.data.get(a.dataId).values,u=xt(r.dtype,a.dtype),d=Qe(B(r.shape),u);let p=0;const h=o===0||o>1||r.shape.length===1?1:B(r.shape.slice(1));for(let f=0;f<i.length;f++)for(let m=0;m<h;m++)i[f]===1?d[p++]=c[f]:d[p++]=l[f];return t.makeTensorInfo(r.shape,u,d)}const ME={kernelName:Fi,backendName:"cpu",kernelFunc:VE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WE=kd,zE=Id,UE=we(ia,n=>n>=0?zE*n:WE*(Math.exp(n)-1)),GE={kernelName:ia,backendName:"cpu",kernelFunc:UE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HE=we(ua,n=>n<0?-1:n>0?1:0),qE={kernelName:ua,backendName:"cpu",kernelFunc:HE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jE=we(ca,n=>Math.sin(n)),KE={kernelName:ca,backendName:"cpu",kernelFunc:jE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XE=we(la,n=>Math.sinh(n)),YE={kernelName:la,backendName:"cpu",kernelFunc:XE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QE=11920928955078125e-23,Ug=Math.log(QE)+2,ZE=we(pa,n=>{const e=n>-Ug,t=n<Ug,s=Math.exp(n);let r;return t?r=s:e?r=n:r=Math.log(1+s),r}),JE={kernelName:pa,backendName:"cpu",kernelFunc:ZE};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eR(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:a,paddings:o}=s;te([r],"spaceToBatchND");const i=B(a),c=[[0,0]];c.push(...o);for(let k=1+a.length;k<r.shape.length;++k)c.push([0,0]);const l=Wg.kernelFunc({inputs:{x:r},backend:t,attrs:{paddings:c,constantValue:0}}),u=qa(l.shape,a,i,!1),d=ja(u.length,a.length,!1),p=Ka(l.shape,a,i,!1),m=Fe({inputs:{x:l},backend:t,attrs:{shape:u}}),x=Et({inputs:{x:m},backend:t,attrs:{perm:d}}),v=Fe({inputs:{x},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(x),v}const tR={kernelName:Li,backendName:"cpu",kernelFunc:eR};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nR(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:a,defaultValue:o}=e;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${a.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const i=t.data.get(s.dataId).values,c=t.data.get(r.dataId).values,l=t.data.get(a.dataId).values,u=t.data.get(o.dataId).values[0],[d,p,h,f,m]=fg(i,s.shape,s.dtype,c,r.dtype,l,u);return[t.makeTensorInfo(p,s.dtype,d),t.makeTensorInfo([p[0]],r.dtype,h),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),t.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}const sR={kernelName:Mi,backendName:"cpu",kernelFunc:nR};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rR(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:a}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const o=Array.from(t.data.get(r.dataId).values),i=t.data.get(s.dataId).values,c=Array.from(t.data.get(a.dataId).values),[l,u,d]=mg(i,s.shape,s.dtype,o,c);return[t.makeTensorInfo(u,s.dtype,l),t.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}const aR={kernelName:Wi,backendName:"cpu",kernelFunc:rR};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oR(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:a}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${r.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${a.shape}`);const o=t.data.get(s.dataId).values,i=t.data.get(r.dataId).values,c=t.data.get(a.dataId).values,[l,u]=qd(o,s.shape,s.dtype,i,c,!0);return t.makeTensorInfo(u,s.dtype,l)}const iR={kernelName:zi,backendName:"cpu",kernelFunc:oR};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cR(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:a}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${r.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${a.shape}`);const o=t.data.get(s.dataId).values,i=t.data.get(r.dataId).values,c=t.data.get(a.dataId).values,[l,u]=qd(o,s.shape,s.dtype,i,c);return t.makeTensorInfo(u,s.dtype,l)}const lR={kernelName:Ui,backendName:"cpu",kernelFunc:cR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uR(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:a,defaultValue:o}=e,{outputShape:i}=s,{sliceRank:c,numUpdates:l,sliceSize:u,strides:d,outputSize:p}=Vs(a,r,i),h=!1,f=t.bufferSync(r),m=t.bufferSync(a),g=t.data.get(o.dataId).values[0],y=zg(f,m,i,p,u,l,c,d,g,h);return t.makeTensorInfo(i,y.dtype,y.values)}const dR={kernelName:Gi,backendName:"cpu",kernelFunc:uR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pR(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:a,axis:o}=s,i=ge(o,r.shape)[0],c=Md(r,a,i),l=new Array(r.shape.length).fill(0),u=r.shape.slice();return c.map(d=>{const p=[...u];p[i]=d;const h=ws({inputs:{x:r},backend:t,attrs:{begin:l,size:p}});return l[i]+=d,h})}const hR={kernelName:Bi,backendName:"cpu",kernelFunc:pR};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fR={kernelName:Kl,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e;te(t,"square");const r=s.data.get(t.dataId).values,a=new Float32Array(r.length);for(let i=0;i<r.length;++i){const c=r[i];a[i]=c*c}return{dataId:s.write(a,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mR=we(ba,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),gR={kernelName:ba,backendName:"cpu",kernelFunc:mR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yR(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:a,end:o,strides:i,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:p}=s;te(r,"stridedSlice");const{finalShapeSparse:h,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:x,end:w,strides:$}=Fu(r.shape,a,o,i,c,l,u,d,p);let v;if(m)v=Fe({inputs:{x:r},backend:t,attrs:{shape:f}});else if(g||y){C(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const k=Ru(x,w,$),I=ws({inputs:{x:r},backend:t,attrs:{begin:x,size:k}});v=Fe({inputs:{x:I},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(I)}else{const k=t.bufferSync(r),I=yg(h,k,$,x);v=t.makeTensorInfo(f,I.dtype,I.values)}return v}const xR={kernelName:Hi,backendName:"cpu",kernelFunc:yR};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bR(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:a,leftPad:o,rightPad:i,padWidth:c,preserveShortSequences:l}=s,{data:u,dataSplits:d}=e,p=t.data.get(u.dataId).values,h=t.data.get(d.dataId).values,[f,m]=xg(p,h,r,a,o,i,c,l);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(d.shape,"int32",m)]}const wR={kernelName:qi,backendName:"cpu",kernelFunc:bR};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $R(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:a,delimiter:o}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const i=t.data.get(a.dataId).values,c=t.data.get(o.dataId).values[0],[l,u,d]=bg(i,c,r),p=u.length;return[t.makeTensorInfo([p,2],"int32",l),t.makeTensorInfo([p],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(d))]}const vR={kernelName:ji,backendName:"cpu",kernelFunc:$R};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CR(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:a}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=t.data.get(a.dataId).values,i=wg(o,r);return t.makeTensorInfo(a.shape,"int32",i)}const NR={kernelName:Ki,backendName:"cpu",kernelFunc:CR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kR=we(ga,n=>Math.tan(n)),IR={kernelName:ga,backendName:"cpu",kernelFunc:kR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SR=we(ya,n=>Math.tanh(n)),TR={kernelName:ya,backendName:"cpu",kernelFunc:SR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ER(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:a}=s;te(r,"tile");const o=vg(t.bufferSync(r),a);return t.makeTensorInfo(o.shape,o.dtype,o.values)}const RR={kernelName:xa,backendName:"cpu",kernelFunc:ER};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _R(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:a,sorted:o}=s;te(r,"topk");const i=t.data.get(r.dataId).values,[c,l]=Ng(i,r.shape,r.dtype,a,o);return[t.makeTensorInfo(c.shape,c.dtype,c.values),t.makeTensorInfo(l.shape,l.dtype,l.values)]}const AR={kernelName:Xi,backendName:"cpu",kernelFunc:_R};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DR(n){const{inputs:e,attrs:t,backend:s}=n,{image:r,transforms:a}=e,{interpolation:o,fillMode:i,fillValue:c,outputShape:l}=t,[u,d,p,h]=r.shape,[f,m]=l!=null?l:[d,p],g=[u,f,m,h],y=se(r.shape),x=y[0],w=y[1],$=y[2],v=Ue(r.dtype,B(g));v.fill(c);const k=s.data.get(r.dataId).values,I=s.data.get(a.dataId).values;for(let A=0;A<u;++A){const R=a.shape[0]===1?I:I.subarray(A*8,A*8+8);for(let _=0;_<f;++_)for(let D=0;D<m;++D)for(let F=0;F<h;++F){let P;const L=R[6]*D+R[7]*_+1;if(L===0)continue;const O=(R[0]*D+R[1]*_+R[2])/L,z=(R[3]*D+R[4]*_+R[5])/L,V=Gg(O,p,i),U=Gg(z,d,i);switch(o){case"nearest":P=VR(k,d,p,x,w,$,A,U,V,F,c);break;case"bilinear":P=MR(k,d,p,x,w,$,A,U,V,F,c);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${o}`)}const G=A*x+_*w+D*$+F;v[G]=P}return s.makeTensorInfo(g,r.dtype,v)}return{dataId:s.write(v,g,r.dtype),shape:r.shape,dtype:r.dtype}}const FR={kernelName:Yi,backendName:"cpu",kernelFunc:DR};function Gg(n,e,t){switch(t){case"reflect":return OR(n,e);case"wrap":return PR(n,e);case"nearest":return BR(n,e);case"constant":default:return LR(n)}}function OR(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=2*e;t<s&&(t=s*Math.trunc(-t/s)+t),t=t<-e?t+s:-t-1}else if(t>e-1)if(e<=1)t=0;else{const s=2*e;t-=s*Math.trunc(t/s),t>=e&&(t=s-t-1)}return kn(0,t,e-1)}function PR(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=e-1;t+=e*(Math.trunc(-t/s)+1)}else if(t>e-1)if(e<=1)t=0;else{const s=e-1;t-=e*Math.trunc(t/s)}return kn(0,t,e-1)}function LR(n,e){return n}function BR(n,e){return kn(0,n,e-1)}function Za(n,e,t,s,r,a,o,i,c,l,u){const d=o*s+i*r+c*a+l;return 0<=i&&i<e&&0<=c&&c<t?n[d]:u}function VR(n,e,t,s,r,a,o,i,c,l,u){const d=Math.round(i),p=Math.round(c);return Za(n,e,t,s,r,a,o,d,p,l,u)}function MR(n,e,t,s,r,a,o,i,c,l,u){const d=Math.floor(i),p=Math.floor(c),h=d+1,f=p+1,m=(f-c)*Za(n,e,t,s,r,a,o,d,p,l,u)+(c-p)*Za(n,e,t,s,r,a,o,d,f,l,u),g=(f-c)*Za(n,e,t,s,r,a,o,h,p,l,u)+(c-p)*Za(n,e,t,s,r,a,o,h,f,l,u);return(h-i)*m+(i-d)*g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WR(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:a}=e;te(a,"unique");const o=s.data.get(a.dataId).values,{outputValues:i,outputShape:c,indices:l}=kg(o,r,a.shape,a.dtype);return[s.makeTensorInfo(c,a.dtype,i),s.makeTensorInfo([l.length],"int32",l)]}const zR={kernelName:Zi,backendName:"cpu",kernelFunc:WR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UR(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:a}=s;a<0&&(a+=r.shape.length);const o=r.shape.length,i=r.shape[a],c=new Array(o-1);let l=0;for(let h=0;h<o;h++)h!==a&&(c[l++]=r.shape[h]);const u=new Array(o).fill(0),d=r.shape.slice();d[a]=1;const p=new Array(i);for(let h=0;h<p.length;h++){u[a]=h;const f=ws({inputs:{x:r},backend:t,attrs:{begin:u,size:d}});p[h]=Fe({inputs:{x:f},backend:t,attrs:{shape:c}}),t.disposeIntermediateTensorInfo(f)}return p}const GR={kernelName:Ji,backendName:"cpu",kernelFunc:UR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HR(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:a}=e,{numSegments:o}=s;te(r,"unsortedSegmentSum");const i=r.shape.length,c=a.shape.length,l=[],u=[],d=i-c;let p=a;for(let f=0;f<d;++f){const m=qc({inputs:{input:p},backend:t,attrs:{dim:f+1}});p=m,u.push(m)}for(let f=0;f<o;++f){const m=dn(f,"int32"),g=t.makeTensorInfo([],"int32",m),y=Hm({inputs:{a:g,b:p},backend:t}),x=Gn({inputs:{x:y},backend:t,attrs:{dtype:"float32"}}),w=Hc({inputs:{a:x,b:r},backend:t}),$=Qa({inputs:{x:w},backend:t,attrs:{axis:0,keepDims:!1}});l.push($),u.push(g),u.push(y),u.push(x),u.push(w),u.push($)}const h=Mg({inputs:l,backend:t,attrs:{axis:0}});return u.forEach(f=>t.disposeIntermediateTensorInfo(f)),h}const qR={kernelName:ec,backendName:"cpu",kernelFunc:HR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jR=[tI,jN,sI,aI,JN,iI,lI,dI,hI,mI,yI,bI,$I,NI,II,EI,_I,DI,OI,Jk,LI,VI,WI,UI,QN,tk,HI,KN,jI,XI,ZI,eS,YI,rS,oS,nS,cS,uS,pS,fS,gS,xS,bS,$S,CS,kS,IS,TS,SS,Qd,_S,qk,DS,nk,WS,sk,zS,ak,KS,XS,QS,ik,eT,nT,rT,oT,cT,lk,dk,XN,uT,KI,pT,fT,gT,jk,hk,mk,xT,yk,wT,CT,kT,TT,RT,AT,bk,OT,LT,VT,WT,UT,DT,HT,jT,$k,XT,ZT,tE,Ck,kk,rE,iE,uE,Sk,pE,fE,mE,Wg,bE,Xk,Rk,$E,YN,CE,Yk,Qk,Zk,kE,SE,EE,_E,DE,FE,PE,Ak,BE,ME,GE,Fk,qE,KE,YE,Ok,JT,JE,tR,sR,aR,iR,lR,dR,hR,Bk,fR,Mk,gR,xR,wR,vR,NR,Gk,ES,IR,TR,RR,AR,Tk,FR,zR,GR,qR,hE];for(const n of jR)oc(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $s={},ep={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function KR(n,e){$s[n]=e}function rn(n){if(!(n in $s)){const t=YR(n);if(t!==null)$s[n]=t;else return console.log("Could not get context for WebGL version",n),null}const e=$s[n];return e.isContextLost()?(delete $s[n],rn(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),$s[n])}function XR(n){if(typeof OffscreenCanvas!="undefined"&&n===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function YR(n){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=XR(n);return e.addEventListener("webglcontextlost",t=>{t.preventDefault(),delete $s[n]},!1),n===1?e.getContext("webgl",ep)||e.getContext("experimental-webgl",ep):e.getContext("webgl2",ep)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ja;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(Ja||(Ja={}));var Rt;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(Rt||(Rt={}));var et;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(et||(et={}));function eo(n,e){return[e,n]}function QR(n,e){return n*e}function Kc(n){const e=B(n),t=Math.ceil(e/4);return xo(t)}function er(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function ZR(n,e){const[t,s]=er(n,e);return t*s*4}function tp(n,e){const t=n;let s,r,a,o,i,c,l,u,d,p;return M().getNumber("WEBGL_VERSION")===2?(s=t.R32F,r=t.R16F,a=t.RGBA16F,o=t.RGBA32F,i=t.RED,l=4,u=1,d=t.HALF_FLOAT,p=t.FLOAT):(s=n.RGBA,r=n.RGBA,a=n.RGBA,o=t.RGBA,i=n.RGBA,l=4,u=4,d=e!=null?e.HALF_FLOAT_OES:null,p=n.FLOAT),c=n.RGBA,{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:a,internalFormatPackedFloat:o,textureFormatFloat:i,downloadTextureFormat:c,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:d,textureTypeFloat:p}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ne(n,e){const t=e();return M().getBool("DEBUG")&&JR(n),t}function JR(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+s_(n,e))}const e_=596e-10,t_=65504;function n_(n){return!!(M().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||e_<Math.abs(n)&&Math.abs(n)<t_)}function s_(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Xc(n,e){return bn(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function r_(n,e){const t=bn(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ne(n,()=>n.shaderSource(t,e)),ne(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function a_(n,e){const t=bn(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ne(n,()=>n.shaderSource(t,e)),ne(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw i_(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const o_=/ERROR: [0-9]+:([0-9]+):/g;function i_(n,e){const t=o_.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const s=+t[1],r=n.split(`
`),a=r.length.toString().length+2,o=r.map((d,p)=>es((p+1).toString(),a)+d);let i=0;for(let d=0;d<o.length;d++)i=Math.max(o[d].length,i);const c=o.slice(0,s-1),l=o.slice(s-1,s),u=o.slice(s);console.log(c.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${es(l[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function c_(n){return bn(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function l_(n,e){if(ne(n,()=>n.linkProgram(e)),n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function np(n,e){if(ne(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function u_(n,e){const t=bn(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ne(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),ne(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function d_(n,e){const t=bn(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return ne(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),ne(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function p_(n){return bn(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function h_(n,e){const t=M().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const s=`[${n}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>t||e>t){const s=`[${n}x${e}]`,r=`[${t}x${t}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function f_(n){return bn(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Hg(n,e,t,s,r,a,o){const i=n.getAttribLocation(e,t);return i===-1?!1:(ne(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),ne(n,()=>n.vertexAttribPointer(i,r,n.FLOAT,!1,a,o)),ne(n,()=>n.enableVertexAttribArray(i)),!0)}function m_(n,e,t){w_(n,t),ne(n,()=>n.activeTexture(n.TEXTURE0+t)),ne(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function g_(n,e,t){return bn(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function y_(n,e,t){return n.getUniformLocation(e,t)}function x_(n,e,t,s){ne(n,()=>m_(n,e,s)),ne(n,()=>n.uniform1i(t,s))}function sp(n,e,t){ne(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),ne(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function qg(n,e){ne(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),ne(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Yc(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+b_(n,e))}function b_(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function bn(n,e,t){const s=ne(n,()=>e());if(s==null)throw new Error(t);return s}function w_(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+n.TEXTURE0;if(s<n.TEXTURE0||s>t){const r=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${r}.`)}}function tr(n,e=2){return B(n.slice(0,n.length-e))}function nr(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function rp(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[tr(n),...nr(n)]),e}function $_(n,e=!1){let t=M().getNumber("WEBGL_MAX_TEXTURE_SIZE");e&&(t=t*2,n=n.map((r,a)=>a>=n.length-2?Sl(n[a]):n[a]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=un(n).newShape);let s=B(n);if(n.length<=1&&s<=t)return[1,s];if(n.length===2&&n[0]<=t&&n[1]<=t)return n;if(n.length===3&&n[0]*n[1]<=t&&n[2]<=t)return[n[0]*n[1],n[2]];if(n.length===3&&n[0]<=t&&n[1]*n[2]<=t)return[n[0],n[1]*n[2]];if(n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t)return[n[0]*n[1]*n[2],n[3]];if(n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t)return[n[0],n[1]*n[2]*n[3]];if(e){const r=tr(n);let a=2,o=2;return n.length&&([a,o]=nr(n)),s=r*(a/2)*(o/2),xo(s).map(i=>i*2)}return xo(s)}function Qc(n){return n%2==0}function Zc(n,e){if(n=n.slice(-2),e=e.slice(-2),$e(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n.slice(-1)[0],s=e.slice(-1)[0];if(t===s||Qc(t)&&Qc(s)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&Qc(n[0])&&Qc(e[0])}let ap,op;function v_(n){if(ap==null){const e=rn(n);ap=e.getParameter(e.MAX_TEXTURE_SIZE)}return ap}function C_(n){if(op==null){const e=rn(n);op=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,op)}function N_(n){if(n===0)return 0;let e;const t=rn(n);return Bt(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:Bt(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function Bt(n,e){return n.getExtension(e)!=null}function jg(n){try{if(rn(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function k_(n){if(n===0)return!1;const e=rn(n);if(n===1){if(!Bt(e,"OES_texture_float"))return!1}else if(!Bt(e,"EXT_color_buffer_float"))return!1;return ip(e)}function I_(n){if(n===0)return!1;const e=rn(n);if(n===1){if(!Bt(e,"OES_texture_float")||!Bt(e,"WEBGL_color_buffer_float"))return!1}else{if(Bt(e,"EXT_color_buffer_float"))return ip(e);const s="EXT_color_buffer_half_float";if(Bt(e,s)){const r=e.getExtension(s);return S_(e,r)}return!1}return ip(e)}function ip(n){const e=tp(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t);const s=1,r=1;n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,s,r,0,e.textureFormatFloat,e.textureTypeFloat,null);const a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(a),o}function S_(n,e){const t=tp(n,e),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s);const r=1,a=1;n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,r,a,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const i=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(o),i}function T_(n){return n!==2?!1:rn(n).fenceSync!=null}function to(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&C(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const re=M();re.registerFlag("HAS_WEBGL",()=>re.getNumber("WEBGL_VERSION")>0);re.registerFlag("WEBGL_VERSION",()=>jg(2)?2:jg(1)?1:0);re.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);re.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>re.get("WEBGL_VERSION")===2);re.registerFlag("WEBGL_CPU_FORWARD",()=>!0);re.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);re.registerFlag("WEBGL_PACK",()=>re.getBool("HAS_WEBGL"));re.registerFlag("WEBGL_PACK_NORMALIZATION",()=>re.getBool("WEBGL_PACK"));re.registerFlag("WEBGL_PACK_CLIP",()=>re.getBool("WEBGL_PACK"));re.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>re.getBool("WEBGL_PACK"));re.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>re.getBool("WEBGL_PACK"));re.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>re.getBool("WEBGL_PACK"));re.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>re.getBool("WEBGL_PACK"));re.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>re.getBool("WEBGL_PACK"));re.registerFlag("WEBGL_PACK_REDUCE",()=>re.getBool("WEBGL_PACK"));re.registerFlag("WEBGL_LAZILY_UNPACK",()=>re.getBool("WEBGL_PACK"));re.registerFlag("WEBGL_CONV_IM2COL",()=>re.getBool("WEBGL_PACK"));re.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>v_(re.getNumber("WEBGL_VERSION")));re.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>C_(re.getNumber("WEBGL_VERSION")));re.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=re.getNumber("WEBGL_VERSION");return n===0?0:N_(n)});re.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>re.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!uu());re.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>k_(re.getNumber("WEBGL_VERSION")));re.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>re.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:re.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));re.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>I_(re.getNumber("WEBGL_VERSION")));re.registerFlag("WEBGL_FENCE_API_ENABLED",()=>T_(re.getNumber("WEBGL_VERSION")));re.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>re.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);re.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});re.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>uu()?1:-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});re.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);re.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);re.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);re.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lt(){let n,e,t,s,r,a,o,i,c,l;return M().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",s="in",r="texture",a="outputColor",o="out vec4 outputColor;",i=`
      bool isnan_custom(float val) {
        return (val > 0.0 || val < 0.0) ? false : val != 0.0;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,c="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",s="varying",r="texture2D",a="gl_FragColor",o="",i=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,c=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:s,texture2D:r,output:a,defineOutput:o,defineSpecialNaN:i,defineSpecialInf:c,defineRound:l}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vs(n,e,t="index"){const s=se(e);return s.map((r,a)=>{const o=`int ${n[a]} = ${t} / ${r}`,i=a===s.length-1?`int ${n[a+1]} = ${t} - ${n[a]} * ${r}`:`index -= ${n[a]} * ${r}`;return`${o}; ${i};`}).join("")}function Jc(n,e,t="index"){const s=se(e);return s.map((r,a)=>{const o=`int ${n[a]} = ${t} / outShapeStrides[${a}]`,i=a===s.length-1?`int ${n[a+1]} = ${t} - ${n[a]} * outShapeStrides[${a}]`:`index -= ${n[a]} * outShapeStrides[${a}]`;return`${o}; ${i};`}).join("")}function E_(n,e){const t=n.length,s=n.map(a=>`${e}[${a}]`),r=new Array(t-1);r[t-2]=s[t-1];for(let a=t-3;a>=0;--a)r[a]=`(${r[a+1]} * ${s[a+1]})`;return r}function R_(n,e,t="index"){const s=n.map((a,o)=>o),r=E_(s,e);return r.map((a,o)=>{const i=`int ${n[o]} = ${t} / ${r[o]}`,c=o===r.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${r[o]}`:`index -= ${n[o]} * ${r[o]}`;return`${i}; ${c};`}).join("")}function cp(n){const e=se(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function lp(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const Kg=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:Xg}=Bm;function __(n,e,t){const s=[];if(n.forEach(h=>{const f=B(h.shapeInfo.logicalShape);if(h.shapeInfo.isUniform?s.push(`uniform float ${h.name}${f>1?`[${f}]`:""};`):(s.push(`uniform sampler2D ${h.name};`),s.push(`uniform int offset${h.name};`)),t.enableShapeUniforms){const{uniformShape:m}=up(t.packedInputs,h.shapeInfo.logicalShape,h.shapeInfo.texShape);switch(m.length){case 1:s.push(`uniform int ${h.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${h.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${h.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${h.name}Shape;`);break}s.push(`uniform ivec2 ${h.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(h=>{s.push(`uniform ${h.type} ${h.name}${h.arrayIndex?`[${h.arrayIndex}]`:""};`)});const r=s.join(`
`),a=n.map(h=>A_(h,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),o=e.texShape,i=lt(),c=O_(i);let l,u,d=B_(i);return e.isPacked?(l=D_(e.logicalShape,o,t.enableShapeUniforms),u=L_(i)):(l=F_(e.logicalShape,o,t.enableShapeUniforms),u=P_(i)),t.packedInputs&&(d+=z_),[d,c,u,r,l,a,t.userCode].join(`
`)}function sr(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return eA(n,e);case 1:return nA(n,e);case 2:return rA(n,e);case 3:return oA(n,e);case 4:return cA(n,e);case 5:return lA(n);case 6:return uA(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function Yg(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return J_(n);case 1:return tA(n,e);case 2:return sA(n,e);case 3:return aA(n,e);default:return iA(n,e)}}function A_(n,e,t=!1,s){let r="";t?r+=Yg(n,s):r+=sr(n,s);const a=n.shapeInfo.logicalShape,o=e.logicalShape;return a.length<=o.length&&(t?r+=dA(n,e):r+=pA(n,e)),r}function D_(n,e,t){switch(n.length){case 0:return Qg();case 1:return U_(n,e,t);case 2:return Q_(n,e,t);case 3:return H_(n,e,t);default:return j_(n,e,t)}}function F_(n,e,t){switch(n.length){case 0:return Qg();case 1:return G_(n,e,t);case 2:return Z_(n,e,t);case 3:return q_(n,e,t);case 4:return K_(n,e,t);case 5:return X_(n,e);case 6:return Y_(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function O_(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function P_(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function L_(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function B_(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${V_}
    ${M_}
    ${W_}
  `}const V_=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,M_=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,W_=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,z_=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function Qg(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function U_(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function G_(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function H_(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[2]/2),a=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function q_(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Jc(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=vs(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function j_(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[n.length-1]/2),a=r*Math.ceil(n[n.length-2]/2);let o=a,i="",c="b, r, c";for(let l=2;l<n.length-1;l++)o*=n[n.length-l-1],i=`
      int b${l} = index / ${o};
      index -= b${l} * ${o};
    `+i,c=`b${l}, `+c;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${i}

      int b = index / ${a};
      index -= b * ${a};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${c});
    }
  `}function K_(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Jc(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=vs(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function X_(n,e){const t=vs(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Y_(n,e){const t=vs(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Q_(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if($e(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function Z_(n,e,t){return $e(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function Cs(n){return`offset${n}`}function J_(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),s=lt();return`
    vec4 ${t}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function eA(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${t};}`;const[r,a]=n.shapeInfo.texShape;if(r===1&&a===1)return`
      float ${s}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=Cs(t);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${o});
      return sampleTexture(${t}, uv);
    }
  `;const[i,c]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${i}, ${c}, ${o});
      return sampleTexture(${t}, uv);
    }
  `}function tA(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n.shapeInfo.texShape,a=lt();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${a.texture2D}(${t}, uv);
    }
  `;const o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${a.texture2D}(${t}, uv);
    }
  `}function nA(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${rr(n)}
      }
    `;const r=n.shapeInfo.texShape,a=r[0],o=r[1];if(o===1&&a===1)return`
      float ${s}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const i=Cs(t);return o===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${a}.0);
        return sampleTexture(${t}, uv);
      }
    `:a===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${i});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${a}, ${o}, index + ${i});
      return sampleTexture(${t}, uv);
    }
  `}function sA(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=n.shapeInfo.texShape,o=a[0],i=a[1],c=lt();if(a!=null&&$e(t,a))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${c.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${o}.0);

        return ${c.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${c.texture2D}(${s}, uv);
    }
  `;const l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],u=Math.ceil(t[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${l[0]}, ${l[1]}, row, col);
      return ${c.texture2D}(${s}, uv);
    }
  `}function rA(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=n.shapeInfo.texShape;if(a!=null&&$e(t,a)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const p=a[0],h=a[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${h}.0, ${p}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:o,keptDims:i}=un(t),c=o;if(c.length<t.length){const p=ar(n,c),h=["row","col"];return`
      ${sr(p,e)}
      float ${r}(int row, int col) {
        return ${r}(${or(h,i)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${rr(n)}
      }
    `;const l=a[0],u=a[1],d=Cs(s);return u===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${s}, uv);
    }
  `:l===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${d};
    vec2 uv = uvFromFlat(${l}, ${u}, index);
    return sampleTexture(${s}, uv);
  }
`}function aA(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=n.shapeInfo.texShape,o=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)];if(t[0]===1){const p=t.slice(1),h=[1,2],f=ar(n,p),m=["b","row","col"];return`
        ${Yg(f,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${or(m,h)});
        }
      `}const i=lt();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${i.texture2D}(${s}, uv);
    }
  `;const c=o[0],l=o[1],u=Math.ceil(t[2]/2),d=u*Math.ceil(t[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${c}, ${l}, ${d}, ${u}, b, row, col);
      return ${i.texture2D}(${s}, uv);
    }
  `}function oA(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=t[1]*t[2],o=t[2],{newShape:i,keptDims:c}=un(t),l=i;if(l.length<t.length){const m=ar(n,l),g=["row","col","depth"];return`
        ${sr(m,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${or(g,c)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${a}, ${o}, 1)));
        ${rr(n)}
      }
    `;const u=n.shapeInfo.texShape,d=u[0],p=u[1],h=n.shapeInfo.flatOffset;if(p===a&&h==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${p}.0, ${d}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(p===o&&h==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}.0, ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `;const f=Cs(s);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * ${a} + col * ${o} + depth + ${f};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${a} + col * ${o} + depth + ${f};
        vec2 uv = uvFromFlat(${d}, ${p}, index);
        return sampleTexture(${s}, uv);
      }
  `}function iA(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=lt();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${t}, uv);
    }
  `;const a=n.shapeInfo.logicalShape,o=a.length,i=n.shapeInfo.texShape,c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],l=c[0],u=c[1],d=Math.ceil(a[o-1]/2);let p=d*Math.ceil(a[o-2]/2),h="int b, int row, int col",f=`b * ${p} + (row / 2) * ${d} + (col / 2)`;for(let m=2;m<o-1;m++)h=`int b${m}, `+h,p*=a[o-m-1],f=`b${m} * ${p} + `+f;return`
    vec4 ${s}(${h}) {
      int index = ${f};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${l});
      return ${r.texture2D}(${t}, uv);
    }
  `}function cA(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),a=t[3],o=t[2]*a,i=t[1]*o,{newShape:c,keptDims:l}=un(t);if(c.length<t.length){const x=ar(n,c),w=["row","col","depth","depth2"];return`
      ${sr(x,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${or(w,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${i}, ${o}, ${a}, 1)));
        ${rr(n)}
      }
    `;const u=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,p=d[0],h=d[1],f=`int stride2 = ${s}Shape[3];`,m=`int stride1 = ${s}Shape[2] * stride2;`,g=`int stride0 = ${s}Shape[1] * stride1;`;if(h===i&&u==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${f}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${a}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${p}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(h===a&&u==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${p}.0);
        return sampleTexture(${s}, uv);
      }
    `;const y=Cs(s);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${m}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${y});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${o} +
          depth * ${a} + depth2;
      vec2 uv = uvFromFlat(${p}, ${h}, index + ${y});
      return sampleTexture(${s}, uv);
    }
  `}function lA(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e[4],a=e[3]*r,o=e[2]*a,i=e[1]*o,{newShape:c,keptDims:l}=un(e);if(c.length<e.length){const m=ar(n,c),g=["row","col","depth","depth2","depth3"];return`
      ${sr(m)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${or(g,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${i}, ${o}, ${a}, ${r})) +
          depth3;
        ${rr(n)}
      }
    `;const u=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,p=d[0],h=d[1];if(h===i&&u==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${a}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(h===r&&u==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;const f=Cs(t);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${o} + depth * ${a} +
          depth2 * ${r} + depth3 + ${f};
      vec2 uv = uvFromFlat(${p}, ${h}, index);
      return sampleTexture(${t}, uv);
    }
  `}function uA(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:r,keptDims:a}=un(e);if(r.length<e.length){const g=ar(n,r),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${sr(g)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${or(y,a)});
      }
    `}const o=e[5],i=e[4]*o,c=e[3]*i,l=e[2]*c,u=e[1]*l;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${l}, ${c}, ${i})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${rr(n)}
      }
    `;const d=n.shapeInfo.flatOffset,p=n.shapeInfo.texShape,h=p[0],f=p[1];if(f===u&&d==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${c}, ${i}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${h}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===o&&d==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${h}.0);
        return sampleTexture(${t}, uv);
      }
    `;const m=Cs(t);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${l} + depth * ${c} +
          depth2 * ${i} + depth3 * ${o} + depth4 + ${m};
      vec2 uv = uvFromFlat(${h}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function rr(n){const e=n.name,t=B(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function dA(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",a=n.shapeInfo.logicalShape.length,o=e.logicalShape.length,i=Xg(n.shapeInfo.logicalShape,e.logicalShape),c=Ne(o),l=o-a;let u;const d=["x","y","z","w","u","v"];a===0?u="":o<2&&i.length>=1?u="coords = 0;":u=i.map(x=>`coords.${d[x+l]} = 0;`).join(`
`);let p="";o<2&&a>0?p="coords":p=n.shapeInfo.logicalShape.map((x,w)=>`coords.${d[w+l]}`).join(", ");let h="return outputValue;";const m=B(n.shapeInfo.logicalShape)===1,y=B(e.logicalShape)===1;if(a===1&&!m&&!y)h=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!y)o===1?h=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:h=`
        return vec4(outputValue.x);
      `;else if(i.length){const x=a-2,w=a-1;i.indexOf(x)>-1&&i.indexOf(w)>-1?h="return vec4(outputValue.x);":i.indexOf(x)>-1?h="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(w)>-1&&(h="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${c} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${s}(${p});
      ${h}
    }
  `}function pA(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",a=e.texShape,o=n.shapeInfo.texShape,i=n.shapeInfo.logicalShape.length,c=e.logicalShape.length;if(!n.shapeInfo.isUniform&&i===c&&n.shapeInfo.flatOffset==null&&$e(o,a))return`
      float ${r}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const l=Ne(c),u=Xg(n.shapeInfo.logicalShape,e.logicalShape),d=c-i;let p;const h=["x","y","z","w","u","v"];i===0?p="":c<2&&u.length>=1?p="coords = 0;":p=u.map(m=>`coords.${h[m+d]} = 0;`).join(`
`);let f="";return c<2&&i>0?f="coords":f=n.shapeInfo.logicalShape.map((m,g)=>`coords.${h[g+d]}`).join(", "),`
    float ${r}() {
      ${l} coords = getOutputCoords();
      ${p}
      return get${s}(${f});
    }
  `}function Ne(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function up(n,e,t){const{newShape:s,keptDims:r}=un(e),a=e.length,o=n&&a===3&&e[0]===1,i=o?e.slice(1):s,c=!n&&a>1&&!$e(e,t)&&s.length<a||o;return{useSqueezeShape:c,uniformShape:c?i:e,keptDims:r}}function ar(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function or(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hA(n,e,t,s){const r=t.map((w,$)=>{const v={logicalShape:w.shape,texShape:w.isUniform?null:w.texData.texShape,isUniform:w.isUniform,isPacked:w.isUniform?!1:w.texData.isPacked,flatOffset:null};return w.texData!=null&&w.texData.slice!=null&&w.texData.slice.flatOffset>0&&(v.flatOffset=w.texData.slice.flatOffset),{name:e.variableNames[$],shapeInfo:v}}),a=r.map(w=>w.shapeInfo),o={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},i=__(r,o,e),c=n.createProgram(i);let l=null;const u=n.getUniformLocation(c,"NAN",!1);M().getNumber("WEBGL_VERSION")===1&&(l=n.getUniformLocation(c,"INFINITY",!1));const d=!1,p={},h={},f={};for(let w=0;w<e.variableNames.length;w++){const $=e.variableNames[w];p[$]=n.getUniformLocation(c,$,d),p[`offset${$}`]=n.getUniformLocation(c,`offset${$}`,d),e.enableShapeUniforms&&(h[`${$}Shape`]=n.getUniformLocation(c,`${$}Shape`,d),f[`${$}TexShape`]=n.getUniformLocation(c,`${$}TexShape`,d))}let m,g,y;e.enableShapeUniforms&&(m=n.getUniformLocation(c,"outShape",d),y=n.getUniformLocation(c,"outShapeStrides",d),g=n.getUniformLocation(c,"outTexShape",d));const x=[];return e.customUniforms&&e.customUniforms.forEach((w,$)=>{x[$]=n.getUniformLocation(c,w.name,d)}),{program:e,source:i,webGLProgram:c,uniformLocations:p,customUniformLocations:x,inShapeInfos:a,outShapeInfo:o,infLoc:l,nanLoc:u,inShapesLocations:h,inTexShapesLocations:f,outShapeLocation:m,outShapeStridesLocation:y,outTexShapeLocation:g}}function Zg(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,s)=>{const r=t.logicalShape,a=e[s],o=a.shape;if(!$e(r,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${o} must match`);if(t.isUniform&&a.isUniform)return;const i=t.texShape,c=a.isUniform?null:a.texData.texShape;if(!$e(i,c))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${c} must match`)})}function fA(n,e,t,s,r){e.program.enableShapeUniforms||(Zg(e.inShapeInfos,t),Zg([e.outShapeInfo],[s]));const a=s.texData.texture,o=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(a,o[0],o[1]):n.setOutputMatrixTexture(a,o[0],o[1]),n.setProgram(e.webGLProgram),M().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN),t.forEach((c,l)=>{const u=e.program.variableNames[l],d=e.uniformLocations[u],p=e.uniformLocations[`offset${u}`],h=e.inShapesLocations[`${u}Shape`],f=e.inTexShapesLocations[`${u}TexShape`];if(h){const{uniformShape:m}=up(e.program.packedInputs,c.shape,c.texData.texShape);switch(m.length){case 1:n.gl.uniform1iv(h,new Int32Array(m));break;case 2:n.gl.uniform2iv(h,new Int32Array(m));break;case 3:n.gl.uniform3iv(h,new Int32Array(m));break;case 4:n.gl.uniform4iv(h,new Int32Array(m));break}}if(f&&n.gl.uniform2i(f,c.texData.texShape[0],c.texData.texShape[1]),d!=null){if(c.isUniform){if(B(c.shape)<2)n.gl.uniform1f(d,c.uniformValues[0]);else{let m=c.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),n.gl.uniform1fv(d,m)}return}c.texData.slice!=null&&p!=null&&n.gl.uniform1i(p,c.texData.slice.flatOffset),n.setInputMatrixTexture(c.texData.texture,d,l)}});const i=e.outShapeLocation;if(i)switch(s.shape.length){case 1:n.gl.uniform1iv(i,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(i,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(i,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(i,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const c=se(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(c));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(c));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(c));break}}e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&r&&e.program.customUniforms.forEach((c,l)=>{const u=e.customUniformLocations[l],d=r[l];if(c.type==="float")n.gl.uniform1fv(u,d);else if(c.type==="vec2")n.gl.uniform2fv(u,d);else if(c.type==="vec3")n.gl.uniform3fv(u,d);else if(c.type==="vec4")n.gl.uniform4fv(u,d);else if(c.type==="int")n.gl.uniform1iv(u,d);else if(c.type==="ivec2")n.gl.uniform2iv(u,d);else if(c.type==="ivec3")n.gl.uniform3iv(u,d);else if(c.type==="ivec4")n.gl.uniform4iv(u,d);else throw Error(`uniform type ${c.type} is not supported yet.`)}),n.executeProgram()}function mA(n,e,t){let s="";e.concat(t).forEach(o=>{const i=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const c=o.texData.texShape,{useSqueezeShape:l,uniformShape:u,keptDims:d}=up(n.packedInputs,o.shape,c);let p="",h="",f="";if(u.length===1&&n.packedInputs){const v=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)];p=`${v[0]>1}_${v[1]>1}`}else if(u.length===2&&!n.packedInputs)h=`${u[0]>1}_${u[1]>1}`;else if(u.length>2&&!n.packedInputs){const v=se(u);f=`${v[0]===c[1]}_${v[v.length-1]===c[1]}`}const m=o.shape.length,g=u.length===2&&$e(o.shape,c),y=B(o.shape)===1,x=zs(o.shape,t.shape),w=!n.packedInputs&&m===t.shape.length&&$e(c,t.texData.texShape),$=n.packedInputs||u.length>2?"":`${c[0]>1}_${c[1]>1}`;s+=`${m}_${w}_${l?d:""}_${u.length}_${y}_${x}_${g}_${p}_${h}_${f}_${$}_${i}`}else{const c=o.isUniform?"uniform":o.texData.texShape;s+=`${o.shape}_${c}_${i}`}});const r=n.userCode;let a=n.constructor.name;return a+="_"+s+"_"+r+`${M().getNumber("WEBGL_VERSION")}`,a}function _t(n){return M().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gA{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Ja.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=lt();this.outputShape=e,this.enableShapeUniforms=_t(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Jc(["r","c","d"],e):vs(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yA{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Ja.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=lt();this.outputShape=e,this.enableShapeUniforms=_t(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Jc(["r","c","d"],e):vs(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xA{constructor(e){this.variableNames=["A"],this.outTexUsage=Rt.DOWNLOAD;const t=lt();this.outputShape=e,this.userCode=`
      ${Kg}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bA{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Rt.DOWNLOAD;const t=lt();this.outputShape=e,this.userCode=`
      ${Kg}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wA{constructor(e,t=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=lt();this.outputShape=e,this.enableShapeUniforms=_t(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?lp():cp(e)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${s.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${s.output} = vec4(${r}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $A{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=lt();this.outputShape=e,this.enableShapeUniforms=_t(this.outputShape.length);let r="",a="result";t&&(a="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let i=0;i<=1;i++){const c=o*2+i;r+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${c}] = values[0];
            } else if (offset == 1) {
              result[${c}] = values[1];
            } else if (offset == 2) {
              result[${c}] = values[2];
            } else {
              result[${c}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?lp():cp(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${a};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vA(n){const e=lt(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return r_(n,t)}function CA(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return u_(n,e)}function NA(n){const e=new Uint16Array([0,1,2,2,1,3]);return d_(n,e)}function no(n,e,t,s,r,a){h_(e,t);const o=p_(n),i=n.TEXTURE_2D;return ne(n,()=>n.bindTexture(i,o)),ne(n,()=>n.texParameteri(i,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),ne(n,()=>n.texParameteri(i,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),ne(n,()=>n.texParameteri(i,n.TEXTURE_MIN_FILTER,n.NEAREST)),ne(n,()=>n.texParameteri(i,n.TEXTURE_MAG_FILTER,n.NEAREST)),ne(n,()=>n.texImage2D(i,0,s,e,t,0,r,a,null)),ne(n,()=>n.bindTexture(n.TEXTURE_2D,null)),o}function Jg(n){return n.internalFormatFloat}function kA(n,e,t,s){const[r,a]=eo(e,t);return no(n,r,a,Jg(s),s.textureFormatFloat,n.FLOAT)}function ey(n){return n.internalFormatHalfFloat}function IA(n,e,t,s){const[r,a]=eo(e,t);return no(n,r,a,ey(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function ty(n){return n.downloadTextureFormat}function SA(n,e,t,s){const[r,a]=eo(e,t);return no(n,r,a,ty(s),n.RGBA,n.UNSIGNED_BYTE)}function ny(n){return n.internalFormatPackedFloat}function TA(n,e,t,s){const[r,a]=er(e,t);return no(n,r,a,ny(s),n.RGBA,n.FLOAT)}function sy(n){return n.internalFormatPackedHalfFloat}function EA(n,e,t,s){const[r,a]=er(e,t);return no(n,r,a,sy(s),n.RGBA,s.textureTypeHalfFloat)}function RA(n,e,t){const s=0,r=3*4,a=3*4+2*4;return ne(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Hg(n,e,"clipSpacePos",t,3,a,s)&&Hg(n,e,"uv",t,2,a,r)}function _A(n,e,t,s,r,a){ne(n,()=>n.bindTexture(n.TEXTURE_2D,e));let o,i,c;r instanceof Uint8Array?(o=new Uint8Array(t*s*4),i=n.UNSIGNED_BYTE,c=n.RGBA):(o=new Float32Array(t*s*4),i=n.FLOAT,c=a.internalFormatPackedFloat),o.set(r),ne(n,()=>n.texImage2D(n.TEXTURE_2D,0,c,t,s,0,n.RGBA,i,o)),ne(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function AA(n,e,t){ne(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?ne(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):ne(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),ne(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function DA(n,e,t,s){const r=n.createBuffer();ne(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const i=4*4*e*t;return ne(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,i,n.STREAM_READ)),ne(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),ne(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function FA(n,e,t){const s=n,r=new Float32Array(t);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function OA(n,e,t,s){const[r,a]=eo(e,t),o=4,i=new Uint8Array(QR(e*t,o));return ne(n,()=>n.readPixels(0,0,r,a,s.downloadTextureFormat,n.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function PA(n,e,t,s,r,a,o,i){const c=n,l=new Float32Array(ZR(a,o));return c.bindBuffer(c.PIXEL_PACK_BUFFER,e),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,l),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),l}function LA(n,e,t){const s=new Float32Array(e*t*4);return ne(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,s)),s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BA{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=M().getNumber("WEBGL_VERSION");e!=null?(this.gl=e,KR(t,e)):this.gl=rn(t);let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(M().getNumber("WEBGL_VERSION")===1){const a="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=Xc(this.gl,a),Bt(this.gl,o))this.textureHalfFloatExtension=Xc(this.gl,o);else if(M().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),Bt(this.gl,r))this.colorBufferHalfFloatExtension=Xc(this.gl,r);else if(M().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",Bt(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(Bt(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=CA(this.gl),this.indexBuffer=NA(this.gl),this.framebuffer=f_(this.gl),this.textureConfig=tp(this.gl,this.textureHalfFloatExtension)}get debug(){return M().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;ne(e,()=>e.finish()),ne(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),ne(e,()=>e.deleteFramebuffer(this.framebuffer)),ne(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),ne(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),ne(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),kA(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),IA(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),SA(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),AA(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,s,r){this.throwIfDisposed(),_A(this.gl,e,t,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),EA(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),TA(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(qg(this.gl,this.framebuffer),this.outputTexture=null),ne(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,s){return this.downloadMatrixDriver(e,()=>OA(this.gl,t,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,s,r,a,o){return PA(this.gl,e,t,s,r,a,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return FA(this.gl,e,t)}createBufferFromTexture(e,t,s){this.bindTextureToFrameBuffer(e);const r=DA(this.gl,t,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,s;if(M().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,a=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const o=r.clientWaitSync(a,0,0);return o===r.ALREADY_SIGNALED||o===r.CONDITION_SATISFIED},t=a}else M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(t,M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:t,isFencePassed:s}}downloadMatrixFromPackedTexture(e,t,s){return this.downloadMatrixDriver(e,()=>LA(this.gl,t,s))}createProgram(e){this.throwIfDisposed();const t=this.gl,s=a_(t,e);this.vertexShader==null&&(this.vertexShader=vA(t));const r=c_(t);return ne(t,()=>t.attachShader(r,this.vertexShader)),ne(t,()=>t.attachShader(r,s)),l_(t,r),this.debug&&np(t,r),this.vertexAttrsAreBound||(this.setProgram(r),this.vertexAttrsAreBound=RA(t,this.program,this.vertexBuffer)),r}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&ne(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&np(this.gl,this.program),ne(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,s=!0){return this.throwIfDisposed(),s?g_(this.gl,e,t):y_(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),ne(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,s){this.throwIfDisposed(),this.throwIfNoProgram(),x_(this.gl,e,t,s)}setOutputMatrixTexture(e,t,s){this.setOutputMatrixTextureDriver(e,s,t)}setOutputPackedMatrixTexture(e,t,s){this.throwIfDisposed();const[r,a]=er(t,s);this.setOutputMatrixTextureDriver(e,r,a)}setOutputMatrixWriteRegion(e,t,s,r){this.setOutputMatrixWriteRegionDriver(s,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&np(this.gl,this.program),Yc(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),ne(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ne(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Xc(this.gl,M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,a),a}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,s=this.getQueryTimerExtensionWebGL2();t.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Tl(()=>this.disposed||this.isQueryAvailable(e,M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),a=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),a&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=VA(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:s}=this.itemsToPoll[t];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),!(this.itemsToPoll.length>1)&&Tl(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),sp(this.gl,e,this.framebuffer),this.debug&&Yc(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(sp(this.gl,this.outputTexture,this.framebuffer),this.debug&&Yc(this.gl)):qg(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const s=t();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,t,s){this.throwIfDisposed();const r=this.gl;sp(r,e,this.framebuffer),this.debug&&Yc(r),this.outputTexture=e,ne(r,()=>r.viewport(0,0,t,s)),ne(r,()=>r.scissor(0,0,t,s))}setOutputMatrixWriteRegionDriver(e,t,s,r){this.throwIfDisposed(),ne(this.gl,()=>this.gl.scissor(e,t,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function VA(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:MA,bincountImpl:ry,bincountReduceImpl:WA,ceilImpl:zA,concatImpl:UA,equalImpl:GA,expImpl:HA,expm1Impl:qA,floorImpl:jA,gatherNdImpl:KA,gatherV2Impl:XA,greaterImpl:YA,greaterEqualImpl:QA,lessImpl:ZA,lessEqualImpl:JA,linSpaceImpl:eD,logImpl:tD,maxImpl:nD,maximumImpl:sD,minimumImpl:rD,multiplyImpl:aD,negImpl:oD,notEqualImpl:iD,prodImpl:cD,rangeImpl:lD,rsqrtImpl:uD,sigmoidImpl:dD,simpleAbsImpl:ay,sliceImpl:pD,sparseFillEmptyRowsImpl:hD,sparseReshapeImpl:fD,sparseSegmentReductionImpl:oy,sqrtImpl:mD,stridedSliceImpl:gD,stringNGramsImpl:yD,stringSplitImpl:xD,stringToHashBucketFastImpl:bD,subImpl:wD,tileImpl:$D,topKImpl:vD,transposeImpl:dp,uniqueImpl:CD}=Hk;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iy(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function ut(n,e){return e===1?[n]:iy(n,e)}function ND(n,e){if(n===1)return"rc";let t="";for(let s=0;s<n;s++)t+=e[s],s<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kD{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e;const t=e.length;if(t===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const s=ut("rc",t),r=Ne(t),a=SD(t,e,s),o=TD(t,e[e.length-1],e[e.length-2],s),i=ED(e,s);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${a}) {
            setOutput(vec4(0));
          } else {
            ${o}

            setOutput(vec4(${i}));
          }
        }
      `}}}function ID(n,e){const t=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let a=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let o=2;o<n;o++)a=`${e[e.length-1-o]},`+a;t.push(a)}return t}function SD(n,e,t){if(n===1)return`rc > ${e[0]}`;let s="";for(let r=n-2;r<n;r++)s+=`${t[r]} >= ${e[r]}`,r<n-1&&(s+="||");return s}function TD(n,e,t,s){if(n===1)return"";const r=s.slice(-2);return`
    int r = ${r[0]};
    int c = ${r[1]};
    int rp1 = r + 1;
    int cp1 = c + 1;

    bool cEdge = cp1 >= ${e};
    bool rEdge = rp1 >= ${t};
  `}function ED(n,e){const t=n.length,s=ID(t,e);return t===1?`getA(rc),
            rc + 1 >= ${n[0]} ? 0. : getA(rc + 1),
            0, 0`:`getA(${s[0]}),
          cEdge ? 0. : getA(${s[1]}),
          rEdge ? 0. : getA(${s[2]}),
          rEdge || cEdge ? 0. : getA(${s[3]})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cy{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=_t(this.outputShape.length);let s="";for(let r=0;r<4;r++){let a="thisRC = rc;";r%2==1&&(a+="thisRC.z += 1;"),r>1&&(a+="thisRC.y += 1;"),s+=`
        ${a}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${RD(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?lp():cp(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function RD(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?R_(["r","c","d"],"inputShape"):vs(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _D{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,s){const r=uy(t,s),a=dy(e,r,s);a in this.freeTextures||(this.freeTextures[a]=[]),a in this.usedTextures||(this.usedTextures[a]=[]);const o=ly(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[a].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const c=this.freeTextures[a].shift();return this.usedTextures[a].push(c),c}let i;return r===et.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===et.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===et.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===et.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===et.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[a].push(i),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),i}releaseTexture(e,t,s,r){if(this.freeTextures==null)return;const a=uy(s,r),o=dy(t,a,r);o in this.freeTextures||(this.freeTextures[o]=[]);const i=ly(t,a,this.gpgpu.gl,this.gpgpu.textureConfig,r),c=M().get("WEBGL_DELETE_TEXTURE_THRESHOLD");c!==-1&&this._numBytesAllocated>c?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=i):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;const l=this.usedTextures[o],u=l.indexOf(e);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(u,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function AD(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;throw new Error(`Unknown internal format ${e}`)}function ly(n,e,t,s,r){const a=DD(e,s);let o;if(r){const[c,l]=er(n[0],n[1]);o=c*l}else{const[c,l]=eo(n[0],n[1]);o=c*l}const i=AD(t,a);return o*i}function DD(n,e){switch(n){case et.PACKED_2X2_FLOAT32:return ny(e);case et.PACKED_2X2_FLOAT16:return sy(e);case et.UNPACKED_FLOAT32:return Jg(e);case et.UNPACKED_FLOAT16:return ey(e);case et.PACKED_4X1_UNSIGNED_BYTE:return ty(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function FD(n){return M().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?et.PACKED_2X2_FLOAT32:et.UNPACKED_FLOAT32:n?et.PACKED_2X2_FLOAT16:et.UNPACKED_FLOAT16}function uy(n,e){if(n===Rt.UPLOAD)return et.PACKED_2X2_FLOAT32;if(n===Rt.RENDER||n==null)return FD(e);if(n===Rt.DOWNLOAD||n===Rt.PIXELS)return et.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function dy(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qn{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=_t(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Gt="if (isnan(x)) return x;",OD="return x;",py="return abs(x);",PD="return (x >= 0.0) ? x : (exp(x) - 1.0);",LD=Gt+`
  return (x < 0.0) ? 0.0 : x;
`,BD=Gt+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,el="return x;",VD="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MD="return x;",WD=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,zD=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,UD=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,GD="return 1.0 / (1.0 + exp(-1.0 * x));";class ir{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=_t(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HD{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e;const t=e.length,s=ut("rc",t),r=Ne(t),a=ND(t,s),o=s.slice(-2),i=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${a});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qD=Sc,jD=1e-7,KD=1e-4,tl={};function XD(n){return n in tl||(tl[n]={}),tl[n]}const YD=M().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),QD=600;function ZD(){return M().global.screen==null?1024:M().global.screen.height*M().global.screen.width*window.devicePixelRatio*QD/1024/1024}class nl extends yo{constructor(e){super();if(this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!M().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(e==null){const t=rn(M().getNumber("WEBGL_VERSION"));this.binaryCache=XD(M().getNumber("WEBGL_VERSION")),this.gpgpu=new BA(t),this.canvas=t.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;this.textureManager=new _D(this.gpgpu),this.numMBBeforeWarning=ZD(),this.texData=new Il(this,On())}nextDataId(){return nl.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,s){if((M().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||M().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:s,values:e,usage:Rt.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,s,r,a){if(M().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:r,values:t,usage:Rt.UPLOAD,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:s,dtype:r,complexTensorInfos:a,slice:o,shape:i,isPacked:c}=t;if(o!=null){let p;c?p=new ir(i,el):p=new qn(i,el);const h=this.runWebGLProgram(p,[{dataId:e,shape:i,dtype:r}],r),f=this.readSync(h.dataId);return this.disposeIntermediateTensorInfo(h),f}if(s!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return s;const l=this.activeTimers!=null;let u;l&&(u=yt());let d;if(r==="complex64"){const p=this.readSync(a.real.dataId),h=this.readSync(a.imag.dataId);d=xn(p,h)}else d=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=yt()-u),this.convertAndCacheOnCPU(e,d)}async read(e){if(this.pendingRead.has(e)){const f=this.pendingRead.get(e);return new Promise(m=>f.push(m))}const t=this.texData.get(e),{values:s,shape:r,slice:a,dtype:o,complexTensorInfos:i,isPacked:c}=t;if(a!=null){let f;c?f=new ir(r,el):f=new qn(r,el);const m=this.runWebGLProgram(f,[{dataId:e,shape:r,dtype:o}],o),g=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(s!=null)return this.convertAndCacheOnCPU(e);if(!M().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&M().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l=null,u;if(o!=="complex64"&&M().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);const f=this.texData.get(u.dataId);l=this.gpgpu.createBufferFromTexture(f.texture,...Kc(r))}this.pendingRead.set(e,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(o==="complex64"){const f=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),m=f[0],g=f[1];d=xn(m,g)}else if(l==null)d=this.getValuesFromTexture(e);else{const f=B(r);d=this.gpgpu.downloadFloat32MatrixFromBuffer(l,f)}if(u!=null&&this.disposeIntermediateTensorInfo(u),l!=null){const f=this.gpgpu.gl;ne(f,()=>f.deleteBuffer(l))}const p=this.convertAndCacheOnCPU(e,d),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach(f=>f(p)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&On().removeDataId(e,this),this.pendingDeletes--),p}bufferSync(e){const t=this.readSync(e.dataId);let s=t;if(e.dtype==="string")try{s=t.map(r=>os(r))}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ue(e.shape,e.dtype,s)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const s=e[t];if(!n_(s))throw M().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:s,isPacked:r}=this.texData.get(e),a=B(t);if(M().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const p=this.decode(e),h=this.texData.get(p.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(h.texture,...Kc(t)).subarray(0,a);return this.disposeIntermediateTensorInfo(p),f}const o=M().getBool("WEBGL_PACK")&&r===!0,i=o?rp(t):t,c=o?new bA(i):new xA(i),l=this.runWebGLProgram(c,[{shape:i,dtype:s,dataId:e}],"float32"),u=this.texData.get(l.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture,u.texShape[0],u.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),d}timerAvailable(){return M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}async time(e){const t=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const a=ln(this.activeTimers.map(c=>c.query)).filter(c=>c!=null),o=ln(this.activeTimers.map(c=>c.name)).filter(c=>c!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const c=await Promise.all(a);i.kernelMs=Hp(c),i.getExtraProfileInfo=()=>c.map((l,u)=>({name:o[u],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:yt(),endMs:null}}endTimer(e){return M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=yt(),e)}async getQueryTime(e){if(M().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:s,texShape:r,usage:a,isPacked:o,slice:i}=this.texData.get(e),c=i&&i.origDataId||e,l=this.dataRefCount.get(c);l>1?this.dataRefCount.set(c,l-1):(this.dataRefCount.delete(c),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(t,r,a,o)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=YD){return M().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&B(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){ht("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return qD(e.shape,t)}packedUnaryOp(e,t,s){const r=new ir(e.shape,t),a=this.compileAndRun(r,[e],s);return On().makeTensorFromDataId(a.dataId,a.shape,a.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=ay(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(M().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,py,e.dtype);const t=new qn(e.shape,py),s=this.compileAndRun(t,[e]);return On().makeTensorFromDataId(s.dataId,s.shape,s.dtype)}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&jt(s[0])){const a=s.map(o=>Kt(o));r=this.write(a,e,t)}else r=this.write(s,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,s){const{dataId:r}=this.makeTensorInfo(e,t,s);return On().makeTensorFromDataId(r,e,t,this)}unpackTensor(e){const t=new HD(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new kD(e.shape),s=!0;return this.runWebGLProgram(t,[e],e.dtype,null,s)}packedReshape(e,t){const s=[tr(e.shape),...nr(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},a=[tr(t),...nr(t)],o=new cy(a,s),i=!0,c=[s],l=this.runWebGLProgram(o,[r],e.dtype,c,i);return{dataId:l.dataId,shape:t,dtype:l.dtype}}decode(e){const t=this.texData.get(e),{isPacked:s,shape:r,dtype:a}=t,o=rp(r);let i;const c=Kc(o);s?i=new yA(o):i=new gA(o);const l=!0,u=[c],d=this.runWebGLProgram(i,[{shape:o,dtype:a,dataId:e}],a,u,l);return{dtype:a,shape:r,dataId:d.dataId}}runWebGLProgram(e,t,s,r,a=!1){const o=this.makeTensorInfo(e.outputShape,s),i=this.texData.get(o.dataId);if(e.packedOutput&&(i.isPacked=!0),e.outPackingScheme===Ja.DENSE){const g=Kc(e.outputShape);i.texShape=g.map(y=>y*2)}if(e.outTexUsage!=null&&(i.usage=e.outTexUsage),B(o.shape)===0)return i.values=Ue(o.dtype,0),o;const c=[],l=t.map(g=>{if(g.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let y=this.texData.get(g.dataId);if(y.texture==null){if(!e.packedInputs&&B(g.shape)<=M().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:g.shape,texData:null,isUniform:!0,uniformValues:y.values};e.packedInputs&&(y.isPacked=!0,y.shape=g.shape)}else if(!!y.isPacked!=!!e.packedInputs)g=y.isPacked?this.unpackTensor(g):this.packTensor(g),c.push(g),y=this.texData.get(g.dataId);else if(y.isPacked&&!Zc(y.shape,g.shape)){const x=g,w=g.shape;g.shape=y.shape,g=this.packedReshape(g,w),c.push(g),y=this.texData.get(g.dataId),x.shape=w}return this.uploadToGPU(g.dataId),{shape:g.shape,texData:y,isUniform:!1}});this.uploadToGPU(o.dataId);const u={shape:o.shape,texData:i,isUniform:!1},d=mA(e,l,u),p=this.getAndSaveBinary(d,()=>hA(this.gpgpu,e,l,u)),h=this.activeTimers!=null;let f;h&&(f=this.startTimer()),fA(this.gpgpu,p,l,u,r),c.forEach(g=>this.disposeIntermediateTensorInfo(g)),h&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=M().get("WEBGL_FLUSH_THRESHOLD");if(m>0){const g=yt();g-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=g)}if(!M().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&a===!1){const g=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),g}return o}compileAndRun(e,t,s,r,a=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,r,a)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(M().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=ce(()=>{if(!M().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=M().getBool("DEBUG");M().set("DEBUG",!1);const t=this.abs(pe(1e-8)).dataSync()[0];if(M().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?jD:KD}uploadToGPU(e){const t=this.texData.get(e),{shape:s,dtype:r,values:a,texture:o,usage:i,isPacked:c}=t;if(o!=null)return;const l=this.activeTimers!=null;let u;l&&(u=yt());let d=t.texShape;if(d==null&&(d=$_(s,c),t.texShape=d),a!=null){const p=rp(s);let h,f=d[1],m=d[0];const g=a instanceof Uint8Array||a instanceof Uint8ClampedArray;c?([f,m]=er(d[0],d[1]),h=new $A(p,g)):h=new wA(p,g);const y=this.makeTensorInfo([m,f],r);g?this.texData.get(y.dataId).usage=Rt.PIXELS:this.texData.get(y.dataId).usage=Rt.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(y.dataId),f,m,a);const x=[[m,f]],w=!0,$=this.runWebGLProgram(h,[y],r,x,w),v=this.texData.get($.dataId);t.texture=v.texture,t.texShape=v.texShape,t.isPacked=v.isPacked,t.usage=v.usage,this.disposeIntermediateTensorInfo(y),this.texData.delete($.dataId),t.values=null,l&&(this.uploadWaitMs+=yt()-u)}else{const p=this.acquireTexture(d,i,r,c);t.texture=p}}convertAndCacheOnCPU(e,t){const s=this.texData.get(e),{dtype:r}=s;return this.releaseGPUData(e),t!=null&&(s.values=JD(t,r)),s.values}acquireTexture(e,t,s,r){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const a=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${a} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*bo(t)}}nl.nextDataId=0;function JD(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<t.length;++s)t[s]=Math.round(n[s]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */du()&&Bu("webgl",()=>new nl,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hy=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class cr{constructor(e,t,s){this.variableNames=["A","B"],this.outputShape=ye(t,s),this.enableShapeUniforms=_t(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sl=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;class so{constructor(e,t,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=ye(t,s);const a=this.outputShape.length;this.enableShapeUniforms=_t(a);let o="";if(r)if(a===0||B(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${Ne(a)} coords = getOutputCoords();
        `,a===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const c=ut("coords",a);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${c[a-2]} + 1) >= outShape[${a} - 2];
            bool nextColOutOfBounds =
              (${c[a-1]} + 1) >= outShape[${a} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${c[a-2]} + 1) >= ${this.outputShape[a-2]};
            bool nextColOutOfBounds =
              (${c[a-1]} + 1) >= ${this.outputShape[a-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ct(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const eF={kernelName:Vr,backendName:"webgl",kernelFunc:Ct};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jn(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,a=t.makeTensorInfo(s.shape,"complex64"),o=t.texData.get(a.dataId),i=Ct({inputs:{x:s},backend:t}),c=Ct({inputs:{x:r},backend:t});return o.complexTensorInfos={real:i,imag:c},a}const tF={kernelName:Do,backendName:"webgl",kernelFunc:jn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fy="return (a < 0.) ? b * a : a;",my=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function nF(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:a}=s,o=t.makeTensorInfo([],"float32",dn(a,"float32")),i=M().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new so(my,r.shape,o.shape):new cr(fy,r.shape,o.shape),c=t.runWebGLProgram(i,[r,o],"float32");return t.disposeIntermediateTensorInfo(o),c}const sF={kernelName:oi,backendName:"webgl",kernelFunc:nF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gy="return (a < 0.) ? b * a : a;",yy=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function rF(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e,a=M().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new so(yy,s.shape,r.shape):new cr(gy,s.shape,r.shape);return t.runWebGLProgram(a,[s,r],"float32")}const aF={kernelName:ki,backendName:"webgl",kernelFunc:rF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xy="if (isnan(x)) return x;",oF=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,iF=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;function me({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:s}){return({inputs:r,backend:a})=>{const{x:o}=r,i=a,c=s||o.dtype;if(i.shouldExecuteOnCPU([o])&&t!=null){const d=i.texData.get(o.dataId),p=t(d.values,c);return i.makeTensorInfo(o.shape,c,p)}const l=M().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let u;return l?u=new ir(o.shape,e):u=new qn(o.shape,n),i.runWebGLProgram(u,[o],c)}}function tt({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:a}){return({inputs:o,backend:i})=>{const{a:c,b:l}=o,u=i;if(s&&c.dtype==="complex64"){const f=u.texData.get(c.dataId),m=u.texData.get(l.dataId),[g,y]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(w=>{const[$,v]=w,k={dataId:$.dataId,dtype:$.dtype,shape:c.shape},I={dataId:v.dataId,dtype:v.dtype,shape:l.shape},S=new cr(n,c.shape,l.shape);return u.runWebGLProgram(S,[k,I],xt($.dtype,v.dtype))}),x=jn({inputs:{real:g,imag:y},backend:u});return u.disposeIntermediateTensorInfo(g),u.disposeIntermediateTensorInfo(y),x}const d=a||xt(c.dtype,l.dtype);if((c.dtype==="string"||l.dtype==="string"||u.shouldExecuteOnCPU([c,l]))&&r!=null){const f=u.texData.get(c.dataId).values,m=u.texData.get(l.dataId).values,g=c.dtype==="string"?xs(f):f,y=c.dtype==="string"?xs(m):m,[x,w]=r(c.shape,l.shape,g,y,d),$=u.makeTensorInfo(w,d),v=u.texData.get($.dataId);return v.values=x,$}const p=M().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let h;return p?h=new so(e,c.shape,l.shape,t):h=new cr(n,c.shape,l.shape),u.runWebGLProgram(h,[c,l],d)}}function rl(n,e=!1){if(n==="linear")return e?MD:OD;if(n==="relu")return e?zD:LD;if(n==="elu")return e?WD:PD;if(n==="relu6")return e?UD:BD;if(n==="prelu")return e?yy:gy;if(n==="leakyrelu")return e?my:fy;if(n==="sigmoid")return e?GD:VD;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class by{constructor(e,t,s,r=!1,a=!1,o=!1,i=null,c=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=_t(this.outputShape.length);const u=r?e[1]:e[2],d=Math.ceil(u/2),p=r?"i * 2, rc.y":"rc.y, i * 2",h=a?"rc.z, i * 2":"i * 2, rc.z",f=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=a?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",y="";i&&(c?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:l?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:g=`vec4 activation(vec4 x) {
          ${i}
        }`,y="result = activation(result);");const x=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let w="rc.x",$="rc.x";e[0]<t[0]?w=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&($=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${d}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${d}; i++) {
          int batchA = ${w};
          int batchB = ${$};
          vec4 a = getMatrixA(batchA, ${p});
          vec4 b = getMatrixB(batchB, ${h});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${m[0]});
          result += (${f[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${x}

        ${y}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wy={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class $y{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=ye(t,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vy="return a * b;";function pp(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,a=xt(s.dtype,r.dtype);if(s.dtype==="complex64"){const i=t.texData.get(s.dataId),c=t.texData.get(r.dataId),l=new $y(wy.REAL,s.shape,r.shape),u=new $y(wy.IMAG,s.shape,r.shape),d=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:s.shape},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:c.complexTensorInfos.real.dataId,dtype:c.complexTensorInfos.real.dtype,shape:r.shape},{dataId:c.complexTensorInfos.imag.dataId,dtype:c.complexTensorInfos.imag.dtype,shape:r.shape}],p=t.runWebGLProgram(l,d,"float32"),h=t.runWebGLProgram(u,d,"float32"),f=jn({inputs:{real:p,imag:h},backend:t});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(h),f}if(t.shouldExecuteOnCPU([s,r])){const i=t.texData.get(s.dataId),c=t.texData.get(r.dataId),[l,u]=aD(s.shape,r.shape,i.values,c.values,a),d=t.makeTensorInfo(u,a),p=t.texData.get(d.dataId);return p.values=l,d}let o;return M().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new so(vy,s.shape,r.shape):o=new cr(vy,s.shape,r.shape),t.runWebGLProgram(o,[s,r],a)}const cF={kernelName:Jr,backendName:"webgl",kernelFunc:pp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lF(n,e,t){const s=[tr(n.shape),...nr(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},a=[tr(e),...nr(e)],o=new cy(a,s),i=!0,c=[s],l=t.runWebGLProgram(o,[r],n.dtype,c,i);return{dataId:l.dataId,shape:e,dtype:l.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:a}=s,o=t,i=B(r.shape),c=El(a,i),l=B(c);C(i===l,()=>`The new shape (${c}) has ${l} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);const u=o.texData.get(r.dataId);return u.isPacked&&!Zc(r.shape,c)&&!(u.texture!==null&&Zc(u.shape,c))?lF(r,c,o):(o.incRef(r.dataId),{dataId:r.dataId,shape:c,dtype:r.dtype})}const uF={kernelName:Ei,backendName:"webgl",kernelFunc:Z};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cy{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:a,outSize:o}=e;this.outputShape=[r,o];const i=Math.floor(s/4)*4,c=s%4;let l="sumValue += dot(values, ones);";if(t!=null){const d=1/t;l=`sumValue += dot(values * ${at(d)?d.toPrecision(2):d}, ones);`}let u="";a%s>0&&(u=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${i};
        if (${c===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dF{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:a,outSize:o}=e;this.outputShape=[r,o];let i="0.0",c="";t==="prod"?i="1.0":t==="min"?(i="1.0 / 1e-20",c="min"):t==="max"&&(i="-1.0 / 1e-20",c="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");const u=Math.floor(s/4)*4,d=s%4;let p=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${c}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${c}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,h="vec4";t==="all"?(i="1.0",p=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,h="bvec4"):t==="any"&&(i="0.0",p=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,h="bvec4");let f="";a%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p}
        }

        int inIdx = inOffset + ${u};
        if (${d===1}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${d===2}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${p}
        } else if (${d===3}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${p}
        }
        setOutput(${l});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pF(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],s=zc(t);e.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return e}function Ns(n,e,t,s){const r=pF(n.shape);let a=n;for(let o=0;o<r.length;o++){const{inSize:i,windowSize:c,outSize:l}=r[o];let u,d;t==="mean"?u=o===0?new Cy({windowSize:c,inSize:i,batchSize:n.shape[0],outSize:l},i):new Cy({windowSize:c,inSize:i,batchSize:n.shape[0],outSize:l}):u=new dF({windowSize:c,inSize:i,batchSize:n.shape[0],outSize:l},t),d=a,a=s.runWebGLProgram(u,[a],e),d.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(d)}return a}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hF{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let o=0;o<s.length;o++)s[o]=e[t[o]];this.outputShape=s,this.rank=s.length;const r=Ne(this.rank),a=fF(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${a}));
    }
    `}}function fF(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<n.length;r++)s[n[r]]=t[r];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mF{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let u=0;u<s.length;u++)s[u]=e[t[u]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Ne(this.rank),a=iy("rc",this.rank),o=new Array(this.rank);for(let u=0;u<t.length;u++)o[t[u]]=a[u];const i=`vec2(${o.slice(-2).join()})`,c=`++${a[this.rank-1]} < ${s[this.rank-1]}`,l=`getChannel(getA(${o.join()}), ${i})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${c}) {
        result[1] = ${l};
      }
      --${a[this.rank-1]};
      if(++${a[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${l};
        if(${c}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function al(n,e,t){const s=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new mF(n.shape,e):new hF(n.shape,e);return t.runWebGLProgram(s,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gF(n,e,t,s){const r=e,a=n.shape.length,o=ge(r,n.shape);let i=o;const c=Me(i,a),l=c!=null;let u=n;l&&(u=al(n,c,s),i=We(i.length,a)),Je("sum",i,a);const[d,p]=Ze(u.shape,i);let h=d;t&&(h=He(d,o));const f=B(p),g=B(n.shape)/f,y=Z({inputs:{x:u},attrs:{shape:[g,f]},backend:s}),x=uc(n.dtype),w=Ns(y,x,"sum",s),$=Z({inputs:{x:w},attrs:{shape:h},backend:s});return s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(w),l&&s.disposeIntermediateTensorInfo(u),$}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ol(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,keepDims:o}=s;return gF(r,a,o,t)}const yF={kernelName:Pi,backendName:"webgl",kernelFunc:ol};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dt(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{perm:a}=s,o=t,i=r.shape.length,c=new Array(i);for(let u=0;u<c.length;u++)c[u]=r.shape[a[u]];let l;if(o.shouldExecuteOnCPU([r])){const d=o.texData.get(r.dataId).values,p=dp(d,r.shape,r.dtype,a,c);l=o.makeTensorInfo(c,r.dtype);const h=o.texData.get(l.dataId);h.values=p}else l=al(r,a,o);return l}const xF={kernelName:Qi,backendName:"webgl",kernelFunc:dt};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ny=1e3;function il({a:n,b:e,transposeA:t,transposeB:s,backend:r,bias:a=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:c=null}){const l=n.shape.length,u=e.shape.length,d=t?n.shape[l-2]:n.shape[l-1],p=s?e.shape[u-1]:e.shape[u-2],h=t?n.shape[l-1]:n.shape[l-2],f=s?e.shape[u-2]:e.shape[u-1],m=n.shape.slice(0,-2),g=e.shape.slice(0,-2),y=B(m),x=B(g),w=y===x||y===1||x===1;C(l>=2&&u>=2&&w,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${m}) and (${g}).`);const v=(y>x?n.shape.slice(0,-2):e.shape.slice(0,-2)).concat([h,f]);C(d===p,()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const k=t?[y,d,h]:[y,h,d],I=s?[x,f,p]:[x,p,f],S=Z({inputs:{x:n},backend:r,attrs:{shape:k}}),A=Z({inputs:{x:e},backend:r,attrs:{shape:I}}),R=[S,A],_=Math.max(y,x),D=t?S.shape[1]:S.shape[2],F=a!=null,P=o!=null,L=c==="leakyrelu",O=c!=null?rl(c,!0):null,z=F||P||L||O!=null;let V;if((h===1||f===1)&&D>Ny&&z===!1){let G=S,H=A;t&&(G=dt({inputs:{x:S},backend:r,attrs:{perm:[0,2,1]}}),R.push(G)),s&&(H=dt({inputs:{x:A},backend:r,attrs:{perm:[0,2,1]}}),R.push(H));const j=f!==1,q=f===1;let X=G;j&&(X=Z({inputs:{x:G},backend:r,attrs:{shape:[_,D,1]}}),R.push(X));const Y=f===1?2:1;let J=H;q&&(J=Z({inputs:{x:H},backend:r,attrs:{shape:[_,1,D]}}),R.push(J));const ee=pp({inputs:{a:X,b:J},backend:r});V=ol({inputs:{x:ee},backend:r,attrs:{axis:Y,keepDims:!0}}),R.push(ee)}else{const G=xt(n.dtype,e.dtype),H=new by(k,I,[_,h,f],t,s,F,O,P,L),j=[S,A];if(a!=null&&j.push(a),P&&j.push(o),L){const q=r.makeTensorInfo([],"float32",dn(i,"float32"));j.push(q),R.push(q)}V=r.runWebGLProgram(H,j,G)}const U=Z({inputs:{x:V},backend:r,attrs:{shape:v}});R.push(V);for(const G of R)r.disposeIntermediateTensorInfo(G);return U}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bF(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:a,bias:o,preluActivationWeights:i}=e,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:d}=s;return il({a:r,b:a,transposeA:c,transposeB:l,backend:t,bias:o,preluActivationWeights:i,leakyreluAlpha:d,activation:u})}const wF={kernelName:wa,backendName:"webgl",kernelFunc:bF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ky="return abs(x);";function $F(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const a=t.texData.get(s.dataId),o=ay(a.values);return t.makeTensorInfo(s.shape,s.dtype,o)}let r;return M().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new ir(s.shape,ky):r=new qn(s.shape,ky),t.runWebGLProgram(r,[s],s.dtype)}const vF={kernelName:$o,backendName:"webgl",kernelFunc:$F};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CF=Gt+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,NF=me({opSnippet:CF}),kF={kernelName:yr,backendName:"webgl",kernelFunc:NF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IF=Gt+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,SF=me({opSnippet:IF}),TF={kernelName:xr,backendName:"webgl",kernelFunc:SF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iy="return a + b;",EF=tt({opSnippet:Iy,packedOpSnippet:Iy,supportsComplex:!0,cpuKernelImpl:MA}),RF={kernelName:_s,backendName:"webgl",kernelFunc:EF};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _F{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((a,o)=>`T${o}`);const s=[];this.variableNames.forEach(a=>{s.push(`float v${a} = get${a}AtOutCoords();`)});const r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AF{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((a,o)=>`T${o}`);const s=[];this.variableNames.forEach(a=>{s.push(`vec4 v${a} = get${a}AtOutCoords();`)});const r=this.variableNames.map(a=>`v${a}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cl(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return Ct({inputs:{x:s[0]},backend:t});if(s.length>M().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const c=Math.floor(s.length/2),l=cl({inputs:s.slice(0,c),backend:t}),u=cl({inputs:s.slice(c),backend:t});return cl({inputs:[l,u],backend:t})}const r=s.map(c=>c.dtype).reduce((c,l)=>xt(c,l)),a=s.map(c=>c.shape),i=M().getBool("WEBGL_PACK")?new AF(s[0].shape,a):new _F(s[0].shape,a);return t.runWebGLProgram(i,s,r)}const DF={kernelName:vo,backendName:"webgl",kernelFunc:cl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FF(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,keepDims:o}=s,i=r.shape.length,c=ge(a,r.shape);let l=c;const u=Me(l,i);let d=r;u!=null&&(d=dt({inputs:{x:r},backend:t,attrs:{perm:u}}),l=We(l.length,i)),Je("all",l,i);const[p,h]=Ze(d.shape,l),f=B(h),m=Z({inputs:{x:d},backend:t,attrs:{shape:[-1,f]}}),g=Ns(m,m.dtype,"all",t);let y;if(o){const x=He(p,c);y=Z({inputs:{x:g},backend:t,attrs:{shape:x}})}else y=Z({inputs:{x:g},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),u!=null&&t.disposeIntermediateTensorInfo(d),y}const OF={kernelName:Co,backendName:"webgl",kernelFunc:FF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PF(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,keepDims:o}=s,i=r.shape.length,c=ge(a,r.shape);let l=c;const u=Me(l,i);let d=r;u!=null&&(d=dt({inputs:{x:r},backend:t,attrs:{perm:u}}),l=We(l.length,i)),Je("any",l,i);const[p,h]=Ze(d.shape,l),f=B(h),m=Z({inputs:{x:d},backend:t,attrs:{shape:[-1,f]}}),g=Ns(m,m.dtype,"any",t);let y;if(o){const x=He(p,c);y=Z({inputs:{x:g},backend:t,attrs:{shape:x}})}else y=Z({inputs:{x:g},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),u!=null&&t.disposeIntermediateTensorInfo(d),y}const LF={kernelName:No,backendName:"webgl",kernelFunc:PF};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class BF{constructor(e,t,s){this.variableNames=["A"];const{windowSize:r,batchSize:a,outSize:o}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[a,o];const i=t==="max"?">":"<",c=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${c};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VF{constructor(e,t,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,C(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const a=e[e.length-1],o=Math.ceil(a/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),r||this.variableNames.push("bestIndicesA");const i=this.outputShape,c=i.length,l=Ne(c),u=ut("coords",c);let d,p;if(o===1){p=c+1;const S=Ne(p);d=`
        ${S} sourceLocR = ${S}(${u.join()}, 0);
        ++${u[c-1]};
        ${S} sourceLocG = ${S}(${u.join()}, 0);
        ++${u[c-2]};
        ${S} sourceLocA = ${S}(${u.join()}, 0);
        --${u[c-1]};
        ${S} sourceLocB = ${S}(${u.join()}, 0);
        --${u[c-2]};`}else p=c,d=`
        ${l} sourceLocR = coords;
        ++${u[c-1]};
        ${l} sourceLocG = coords;
        ++${u[c-2]};
        ${l} sourceLocA = coords;
        --${u[c-1]};
        ${l} sourceLocB = coords;
        --${u[c-2]};`;const h=["x","y","z","w","u","v"].slice(0,p),f="."+h[p-1],m=h.map(S=>"int "+S),g=ut("sourceLocR",p-1).concat("inIdx.r"),y=ut("sourceLocG",p-1).concat("inIdx.g"),x=ut("sourceLocB",p-1).concat("inIdx.b"),w=ut("sourceLocA",p-1).concat("inIdx.a"),$=s==="max"?"greaterThan":"lessThan",v=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${w.join()})));`,k=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${x.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${w.join()}) : 0.)`,I=r?"":`
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${h.join()}),
                                          vec2(${h.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${m.join()}) {
        return getChannel(getA(${h.join()}),
                               vec2(${h.slice(-2).join()}));
      }
      ${I}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${u[c-1]} < ${i[c-1]-1};
        bool hasNextRow = ${u[c-2]} < ${i[c-2]-1};
        ${d}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${k};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${v}
          vec4 candidate = ${k};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${$}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sy(n,e,t,s=null){let r=e.shape[0],a=e.shape[1];s!=null&&(r=s.shape[0],a=s.shape[1]);const o=zc(a),i={windowSize:o,inSize:a,batchSize:r,outSize:Math.ceil(a/o)},c=new BF(i,t,s==null),l=[e];s!=null&&l.push(s);const u=n.runWebGLProgram(c,l,"int32");if(u.shape[1]===1)return u;const d=Sy(n,e,t,u);return n.disposeIntermediateTensorInfo(u),d}function Ty(n,e,t,s=null){const r=s!=null?s.shape:e.shape,a=r[r.length-1],o=zc(a),i=new VF(r,o,t,s==null),c=s==null?[e]:[e,s],l=n.runWebGLProgram(i,c,"int32");if(l.shape.length===e.shape.length){const u=Ty(n,e,t,l);return n.disposeIntermediateTensorInfo(l),u}return l}function Ey(n,e,t,s){const r=[t];if(Je("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!M().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const a=[],o=n.texData.get(e.dataId),i=o!==null&&o.isPacked;let c=e;i&&(c=n.unpackTensor(e),a.push(c));const[l,u]=Ze(c.shape,r),d=B(u),p=Z({inputs:{x:c},backend:n,attrs:{shape:[-1,d]}});a.push(p);const h=Sy(n,p,s);a.push(h);const f=Z({inputs:{x:h},backend:n,attrs:{shape:l}});return a.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}return Ty(n,e,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MF(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a}=s;let o=ge(a,r.shape);const i=Me(o,r.shape.length);let c=r;const l=[];i!=null&&(c=dt({inputs:{x:r},backend:t,attrs:{perm:i}}),l.push(c),o=We(o.length,c.shape.length)),Je("argMax",[o[0]],c.shape.length);const u=Ey(t,c,o[0],"max");return l.forEach(d=>t.disposeIntermediateTensorInfo(d)),u}const WF={kernelName:ko,backendName:"webgl",kernelFunc:MF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zF(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a}=s;let o=ge(a,r.shape);const i=Me(o,r.shape.length);let c=r;const l=[];i!=null&&(c=dt({inputs:{x:r},backend:t,attrs:{perm:i}}),l.push(c),o=We(o.length,c.shape.length)),Je("argMin",[o[0]],c.shape.length);const u=Ey(t,c,o[0],"min");return l.forEach(d=>t.disposeIntermediateTensorInfo(d)),u}const UF={kernelName:Io,backendName:"webgl",kernelFunc:zF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GF=Gt+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,HF=me({opSnippet:GF}),qF={kernelName:br,backendName:"webgl",kernelFunc:HF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jF=Gt+"return log(x + sqrt(x * x + 1.0));",KF=me({opSnippet:jF}),XF={kernelName:wr,backendName:"webgl",kernelFunc:KF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YF=Gt+`
  return atan(x);
`,QF=me({opSnippet:YF}),ZF={kernelName:$r,backendName:"webgl",kernelFunc:QF};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JF=oF+`
  return atan(a, b);
`,eO=`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+iF+`
  return result;
`,tO=tt({opSnippet:JF,packedOpSnippet:eO}),nO={kernelName:Cr,backendName:"webgl",kernelFunc:tO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sO=Gt+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,rO=me({opSnippet:sO}),aO={kernelName:vr,backendName:"webgl",kernelFunc:rO};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ro{constructor(e,t,s,r=!1,a=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,i=e.strideHeight,c=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,h=e.padInfo.top,f=e.padInfo.left;this.outputShape=e.outShape;const m=t==="avg",g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,y=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let x="0.0";if(m||(x="-1.0 / 1e-20"),s){const S=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${c});
        const ivec2 pads = ivec2(${h}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${d};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${S} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?a?g:y:`wR * ${p} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const w="max";let $=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&($="avgValue / count");const v=Math.floor(o/4)*4,k=o%4,I=`
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${c});
      const ivec2 pads = ivec2(${h}, ${f});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${d};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${v}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${I}
          }

          int xC = xCCorner + ${v};
          if (${k===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${I}
          } else if (${k===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${I}
          } else if (${k===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${I}
          }
        }
        setOutput(${$});
      }
    `}}class hp{constructor(e,t,s,r=!1,a=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,i=e.strideDepth,c=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,d=e.dilationHeight,p=e.dilationWidth,h=e.effectiveFilterDepth,f=e.effectiveFilterHeight,m=e.effectiveFilterWidth,g=e.padInfo.front,y=e.padInfo.top,x=e.padInfo.left;this.outputShape=e.outShape;const w=t==="avg";let $="0.0";if(w||($="-1.0 / 1e-20"),s){const R=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${c}, ${l});
        const ivec3 pads = ivec3(${g}, ${y}, ${x});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${h};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${d}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${p}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${R} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?a?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${f} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const v="max";let k=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(k="avgValue / count");const I=Math.floor(o/4)*4,S=o%4,A=`
      if (${w}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${v}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${c}, ${l});
      const ivec3 pads = ivec3(${g}, ${y}, ${x});
      const float initializationValue = ${$};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${$});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${I}; wC += 4) {
              int xC = xCCorner + wC * ${p};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                getValue(batch, xD, xR, xC + 3 * ${p}, ch)
              );

              ${A}
            }

            int xC = xCCorner + ${I};
            if (${S===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${A}
            } else if (${S===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                initializationValue,
                initializationValue
              );

              ${A}
            } else if (${S===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${p}, ch),
                getValue(batch, xD, xR, xC + 2 * ${p}, ch),
                initializationValue
              );

              ${A}
            }
          }
          setOutput(${k});
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oO(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;to(r,"avgPool");const{filterSize:a,strides:o,pad:i,dimRoundingMode:c}=s,l=1;C(st(o,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const u=Pt(r.shape,a,o,l,i,c);if(u.filterWidth===1&&u.filterHeight===1&&$e(u.inShape,u.outShape))return Ct({inputs:{x:r},backend:t});const d=new ro(u,"avg",!1);return t.runWebGLProgram(d,[r],"float32")}const iO={kernelName:So,backendName:"webgl",kernelFunc:oO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cO(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:a,strides:o,pad:i,dimRoundingMode:c,dataFormat:l}=s,u=[1,1,1],d=hn(r.shape,a,o,u,i,c,l),p=new hp(d,"avg",!1);return t.runWebGLProgram(p,[r],"float32")}const lO={kernelName:To,backendName:"webgl",kernelFunc:cO};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uO{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,a=e.strideWidth,o=e.dilationHeight,i=e.dilationWidth,c=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=c-1-e.padInfo.top,d=l-1-e.padInfo.left,p=1/(t*s);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${d});
      const float avgMultiplier = float(${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${c};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class dO{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,a=e.strideDepth,o=e.strideHeight,i=e.strideWidth,c=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,h=e.effectiveFilterWidth,f=d-1-e.padInfo.front,m=p-1-e.padInfo.top,g=h-1-e.padInfo.left,y=1/(t*s*r);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${m}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${c}) {
          float dyD = float(dyDCorner + wD) / ${a}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${h};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pO(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:a}=e,o=a,{filterSize:i,strides:c,pad:l,dimRoundingMode:u}=s,d=[1,1,1],p=hn(o.shape,i,c,d,l,u),h=new dO(p);return t.runWebGLProgram(h,[r],o.dtype)}const hO={kernelName:Bl,backendName:"webgl",kernelFunc:pO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fO(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:a}=e,o=a;to([r,a],"avgPoolGrad");const{filterSize:i,strides:c,pad:l}=s,u=Pt(o.shape,i,c,1,l),d=new uO(u);return t.runWebGLProgram(d,[r],o.dtype)}const mO={kernelName:Ll,backendName:"webgl",kernelFunc:fO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gO(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:a}=e,{transposeA:o,transposeB:i}=s;return il({a:r,b:a,transposeA:o,transposeB:i,backend:t})}const yO={kernelName:Eo,backendName:"webgl",kernelFunc:gO};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xO{constructor(e,t,s,r,a,o){this.outputShape=[],this.variableNames=["x","mean","variance"],ye(e,t),ye(e,s);let i="0.0";r!=null&&(ye(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let c="1.0";a!=null&&(ye(e,a),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${c};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bO{constructor(e,t,s,r,a,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],ye(e,t),ye(e,s);let i="vec4(0.0)";r!=null&&(ye(e,r),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let c="vec4(1.0)";a!=null&&(ye(e,a),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${c};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wO=({inputs:n,backend:e,attrs:t})=>{const{x:s,mean:r,variance:a,offset:o,scale:i}=n;C(r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),C(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),C(i==null||r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:c}=t;c==null&&(c=.001);const l=[s,r,a];let u=null;o!=null&&(u=o.shape,l.push(o));let d=null;i!=null&&(d=i.shape,l.push(i));const p=M().getBool("WEBGL_PACK_NORMALIZATION")?new bO(s.shape,r.shape,a.shape,u,d,c):new xO(s.shape,r.shape,a.shape,u,d,c);return e.runWebGLProgram(p,l,l[0].dtype)},$O={kernelName:ti,backendName:"webgl",kernelFunc:wO};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vO{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Ne(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=CO(this.rank);let r;const a=e.map((o,i)=>`sourceLoc.${fp[i]} = start[${i}] + coords.${fp[i]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${a.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const fp=["x","y","z","w","u","v"];function CO(n){if(n===1)return"sourceLoc";if(n<=6)return fp.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NO{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Ne(this.rank),s=ut("coords",this.rank),r=ut("sourceLoc",this.rank),a=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${a})`,i=`
      result.x = ${o};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${o};
        --${r[this.rank-1]};
      }
    `,c=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${o};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${o};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((u,d)=>`start[${d}]`).join()});`:e.map((u,d)=>`${r[d]} = ${s[d]} + start[${d}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${i}
        ${c}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kO(n,e,t,s){const r=s.texData.get(n.dataId),a=s.makeTensorInfo(t,n.dtype),o=s.texData.get(a.dataId);Object.assign(o,r),o.refCount=1,o.shape=t,o.dtype=n.dtype;let i=Au(e,se(n.shape));r.slice&&(i+=r.slice.flatOffset),o.slice={flatOffset:i,origDataId:r.slice&&r.slice.origDataId||n.dataId};const c=s.dataRefCount.get(o.slice.origDataId)||1;return s.dataRefCount.set(o.slice.origDataId,c+1),a}function lr(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:a,size:o}=s,[i,c]=Du(r,a,o);if(Eu(r,i,c),B(c)===0)return t.makeTensorInfo(c,r.dtype,[]);if(t.shouldExecuteOnCPU([r])||r.dtype==="string"){const d=t.texData.get(r.dataId),p=pD(d.values,i,c,r.shape,r.dtype);return t.makeTensorInfo(c,r.dtype,p)}const{isPacked:l}=t.texData.get(r.dataId),u=_u(r.shape,i,c);if(l||!u){const d=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new NO(c):new vO(c),p=[i];return t.runWebGLProgram(d,[r],r.dtype,p)}return t.uploadToGPU(r.dataId),kO(r,i,c,t)}const IO={kernelName:Oi,backendName:"webgl",kernelFunc:lr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SO=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:a,crops:o}=s;C(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const i=a.reduce((x,w)=>x*w),c=qa(r.shape,a,i),l=ja(c.length,a.length),u=Ka(r.shape,a,i),d=Cd(o,a.length),p=Nd(u,o,a.length),h=[],f=Z({inputs:{x:r},backend:t,attrs:{shape:c}}),m=dt({inputs:{x:f},backend:t,attrs:{perm:l}}),g=Z({inputs:{x:m},backend:t,attrs:{shape:u}}),y=lr({inputs:{x:g},backend:t,attrs:{begin:d,size:p}});return h.push(f),h.push(m),h.push(g),h.forEach(x=>t.disposeIntermediateTensorInfo(x)),y},TO={kernelName:Ro,backendName:"webgl",kernelFunc:SO};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EO(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:a}=e,{size:o}=s,i=t.readSync(r.dataId),c=t.readSync(a.dataId),l=ry(i,c,a.dtype,a.shape,o);return t.makeTensorInfo([o],a.dtype,l)}const RO={kernelName:_o,backendName:"webgl",kernelFunc:EO};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _O(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,a=t.readSync(s.dataId),o=t.readSync(r.dataId),i=ye(Array.from(a),Array.from(o));return t.makeTensorInfo([i.length],"int32",Int32Array.from(i))}const AO={kernelName:Ao,backendName:"webgl",kernelFunc:_O};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DO="return float(a != b);",Ry=tt({opSnippet:DO,cpuKernelImpl:iD,dtype:"bool"}),FO={kernelName:ea,backendName:"webgl",kernelFunc:Ry};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ao(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Ct({inputs:{x:r.complexTensorInfos.real},backend:t})}const OO={kernelName:Ti,backendName:"webgl",kernelFunc:ao};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PO="return float(int(x));";function LO(n,e){const t=new qn(n.shape,PO),s=e.runWebGLProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mp(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:a}=s;if(a==="complex64"){if(r.dtype==="complex64")return Ct({inputs:{x:r},backend:t});const o=Vn(r.shape),i=mp({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),c=jn({inputs:{real:i,imag:o},backend:t});return o.dispose(),t.disposeIntermediateTensorInfo(i),c}if(r.dtype==="complex64"){const o=ao({inputs:{input:r},backend:t}),i=mp({inputs:{x:o},backend:t,attrs:{dtype:a}});return t.disposeIntermediateTensorInfo(o),i}if(!Rl(r.dtype,a)){const o=Ct({inputs:{x:r},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:a}}if(a==="int32")return LO(r,t);if(a==="bool"){const o=t.makeTensorInfo([],"bool",Ue("bool",1)),c=Ry({inputs:{a:r,b:o},backend:t});return t.disposeIntermediateTensorInfo(o),c}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${a}`)}const BO={kernelName:Nr,backendName:"webgl",kernelFunc:mp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _y="return ceil(x);",VO=me({opSnippet:_y,packedOpSnippet:_y,cpuKernelImpl:zA}),MO={kernelName:kr,backendName:"webgl",kernelFunc:VO};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WO{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zO{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UO(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{clipValueMin:a,clipValueMax:o}=s;let i;M().getBool("WEBGL_PACK_CLIP")?i=new zO(r.shape):i=new WO(r.shape);const c=[[a],[o]];return t.runWebGLProgram(i,[r],r.dtype,c)}const GO={kernelName:Ir,backendName:"webgl",kernelFunc:UO};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HO{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ay(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function qO(n){const{inputs:e,backend:t}=n,{x:s}=e,r=t.texData.get(s.dataId),a=new HO(s.shape),o=[Ay(s,r.complexTensorInfos.real),Ay(s,r.complexTensorInfos.imag)];return t.runWebGLProgram(a,o,o[0].dtype)}const jO={kernelName:Fo,backendName:"webgl",kernelFunc:qO};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KO{constructor(e){this.outputShape=[],this.outputShape=nn(e,1),this.variableNames=e.map((o,i)=>`T${i}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const s=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<t.length;o++){const i=t[o-1];s.push(`else if (yC < ${t[o]}) setOutput(getT${o}(yR, yC-${i}));`)}const r=t.length,a=t[t.length-1];s.push(`else setOutput(getT${r}(yR, yC-${a}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XO{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=nn(e,t);const s=this.outputShape,r=s.length,a=Ne(r),o=ut("coords",r),i=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((m,g)=>`T${g}`);const c=new Array(e.length-1);c[0]=e[0][t];for(let m=1;m<c.length;m++)c[m]=c[m-1]+e[m][t];const l=i[t],u=i.slice(-2),d=i.join();let p=`if (${l} < ${c[0]}) {
        return getChannel(
            getT0(${d}), vec2(${u.join()}));
        }`;for(let m=1;m<c.length;m++){const g=c[m-1];p+=`
        if (${l} < ${c[m]}  && ${l} >= ${c[m-1]}) {
          return getChannel(
            getT${m}(${ll(i,l,g)}),
            vec2(${ll(u,l,g)}));
        }`}const h=c.length,f=c[c.length-1];p+=`
        return getChannel(
          getT${h}(${ll(i,l,f)}),
          vec2(${ll(u,l,f)}));`,this.userCode=`
      float getValue(${i.map(m=>"int "+m)}) {
        ${p}
      }

      void main() {
        ${a} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[r-1]} = ${o[r-1]} + 1;
        if (${o[r-1]} < ${s[r-1]}) {
          result.g = getValue(${o});
        }

        ${o[r-2]} = ${o[r-2]} + 1;
        if (${o[r-2]} < ${s[r-2]}) {
          result.a = getValue(${o});
        }

        ${o[r-1]} = ${o[r-1]} - 1;
        if (${o[r-2]} < ${s[r-2]} &&
            ${o[r-1]} < ${s[r-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function ll(n,e,t){const s=n.indexOf(e);return n.map((a,o)=>o===s?`${a} - ${t}`:a).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ul(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Ct({inputs:{x:r.complexTensorInfos.imag},backend:t})}const YO={kernelName:ai,backendName:"webgl",kernelFunc:ul};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ur(n,e,t){const s=n[0].dtype;if(s==="complex64"){const u=n.map(m=>ao({inputs:{input:m},backend:t})),d=n.map(m=>ul({inputs:{input:m},backend:t})),p=ur(u,e,t),h=ur(d,e,t),f=jn({inputs:{real:p,imag:h},backend:t});return u.forEach(m=>t.disposeIntermediateTensorInfo(m)),d.forEach(m=>t.disposeIntermediateTensorInfo(m)),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(h),f}let r=t.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const u=n.map(y=>{const x=B(y.shape.slice(e));return Z({inputs:{x:y},backend:t,attrs:{shape:[-1,x]}})}),d=u.map(y=>({vals:t.readSync(y.dataId),shape:y.shape})),p=nn(u.map(y=>y.shape),1),h=u[0].shape[0]===1,f=UA(d,p,s,h),m=nn(n.map(y=>y.shape),e),g=t.makeTensorInfo(m,s,f);return u.forEach(y=>t.disposeIntermediateTensorInfo(y)),g}if(n.length>M().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(n.length/2),d=ur(n.slice(0,u),e,t),p=ur(n.slice(u),e,t),h=ur([d,p],e,t);return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),h}if(M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&n[0].shape.length>1){const u=new XO(n.map(d=>d.shape),e);return t.runWebGLProgram(u,n,s)}const{tensors2D:a,outShape:o}=QO(n,e,t),i=new KO(a.map(u=>u.shape)),c=t.runWebGLProgram(i,a,s);a.forEach(u=>t.disposeIntermediateTensorInfo(u));const l=Z({inputs:{x:c},attrs:{shape:o},backend:t});return t.disposeIntermediateTensorInfo(c),l}function QO(n,e,t){const s=nn(n.map(a=>a.shape),e);return{tensors2D:n.map(a=>Z({inputs:{x:a},attrs:{shape:[-1,B(a.shape.slice(e))]},backend:t})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dy(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,a=ge(r,e[0].shape)[0],o=nn(e.map(l=>l.shape),a);if(B(o)===0)return t.makeTensorInfo(o,e[0].dtype,[]);const i=e.filter(l=>B(l.shape)>0);if(i.length===1)return Ct({inputs:{x:i[0]},backend:t});const c=i.map(l=>l.shape);return wd(c,a),ur(i,a,t)}const ZO={kernelName:Oo,backendName:"webgl",kernelFunc:Dy};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fy{constructor(e,t=!1,s=null,r=!1,a=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,i=e.padInfo.left,c=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,d=e.dilationWidth,p=e.filterHeight,h=e.filterWidth,f=Math.floor(e.inChannels/4)*4,m=e.inChannels%4,g=e.dataFormat==="channelsLast",y=g?1:2,x=g?2:3,w=g?3:1;let $="",v="";s&&(r?$=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:a?$=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:$=`
          float activation(float x) {
            ${s}
          }
        `,v="result = activation(result);");const k=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${$}

      const ivec2 strides = ivec2(${c}, ${l});
      const ivec2 pads = ivec2(${o}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${w}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${x}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${p}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${h}; wC++) {
            int xC = xCCorner + wC * ${d};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${m===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${k}
        ${v}
        setOutput(result);
      }
    `}}class JO{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,s=e.padInfo.top,r=e.padInfo.left,a=e.strideDepth,o=e.strideHeight,i=e.strideWidth,c=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,d=e.filterDepth,p=e.filterHeight,h=e.filterWidth,f=Math.floor(e.inChannels/4)*4,m=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${a}, ${o}, ${i});
      const ivec3 pads = ivec3(${t}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${d}; wF++) {
          int xF = xFCorner + wF * ${c};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${m===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class e3{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=_t(this.outputShape.length);const{dataFormat:s}=t,r=lt(),a=s==="channelsLast",o=a?0:1,i=a?1:2,c=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${e[1]} && pos < ${e[0]}) {`;let l="";for(let u=0;u<=1;u++)for(let d=0;d<=1;d++)l+=`
          blockIndex = rc.y + ${d};
          pos = rc.x + ${u};

          ${c}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${a}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+d}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+d}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${r.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oy({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:i=null}){const c=n.shape,l=s.texData.get(n.dataId),u=t.inChannels,d=c[0]*c[1]*c[2],p=t.outChannels,h=t.dataFormat==="channelsLast",f=!1,m=!1;let g;const y=[];if(!((d===1||p===1)&&u>Ny)&&l.isPacked&&h&&l.texture!=null&&c[2]%2!=0&&$e(l.shape.slice(-3),c.slice(-3))){const $=c[0]*c[1]*(c[2]+1),v={dataId:n.dataId,shape:[1,$,t.inChannels],dtype:n.dtype},k=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,C(Zc(l.shape,v.shape),()=>`packed reshape ${l.shape} to ${v.shape} isn't free`);const I=Z({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});y.push(I);const S=il({a:v,b:I,backend:s,transposeA:f,transposeB:m,bias:r,activation:i,preluActivationWeights:a,leakyreluAlpha:o}),A=s.texData.get(S.dataId);C(A.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=k,A.shape=t.outShape,g=Ct({inputs:{x:S},backend:s}),g.shape=t.outShape,y.push(S)}else{const $=h?c[0]*c[1]*c[2]:c[0]*c[2]*c[3],v=Z({inputs:{x:n},backend:s,attrs:{shape:[1,$,t.inChannels]}}),k=Z({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),I=il({a:v,b:k,transposeA:f,transposeB:m,backend:s,bias:r,activation:i,preluActivationWeights:a,leakyreluAlpha:o});g=Z({inputs:{x:I},backend:s,attrs:{shape:t.outShape}}),y.push(v),y.push(k),y.push(I)}for(const $ of y)s.disposeIntermediateTensorInfo($);return g}function Py({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:i=null}){const{filterWidth:c,filterHeight:l,inChannels:u,outWidth:d,outHeight:p,dataFormat:h}=t,f=h==="channelsLast",m=c*l*u,g=p*d,y=[m,g],x=!0,w=!1,$=[],v=Z({inputs:{x:n},backend:s,attrs:{shape:n.shape.slice(1)}}),k=Z({inputs:{x:e},backend:s,attrs:{shape:[1,m,B(e.shape)/m]}});$.push(v),$.push(k);const I=new e3(y,t),S=[v.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],A=s.runWebGLProgram(I,[v],"float32",S),R=Z({inputs:{x:A},backend:s,attrs:{shape:[1,y[0],y[1]]}});$.push(A),$.push(R);const _=r!=null,D=a!=null,F=i==="leakyrelu",P=i?rl(i,!0):null,L=new by(R.shape,k.shape,[1,g,t.outChannels],x,w,_,P,D,F),O=[R,k];if(r&&O.push(r),D&&O.push(a),F){const G=s.makeTensorInfo([],"float32",dn(o,"float32"));O.push(G),$.push(G)}const z=s.runWebGLProgram(L,O,"float32"),V=f?[1,p,d,t.outChannels]:[1,t.outChannels,p,d],U=Z({inputs:{x:z},backend:s,attrs:{shape:V}});$.push(z);for(const G of $)s.disposeIntermediateTensorInfo(G);return U}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t3(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:a}=e,{strides:o,pad:i,dataFormat:c,dilations:l,dimRoundingMode:u}=s,d=fn(c),p=je(r.shape,a.shape,o,l,i,u,!1,d);let h;if(p.filterHeight===1&&p.filterWidth===1&&p.dilationHeight===1&&p.dilationWidth===1&&p.strideHeight===1&&p.strideWidth===1&&(p.padInfo.type==="SAME"||p.padInfo.type==="VALID"))h=Oy({x:r,filter:a,convInfo:p,backend:t});else if(M().getBool("WEBGL_CONV_IM2COL")&&r.shape[0]===1)h=Py({x:r,filter:a,convInfo:p,backend:t});else{const m=new Fy(p);h=t.runWebGLProgram(m,[r,a],"float32")}const f=Z({inputs:{x:h},backend:t,attrs:{shape:p.outShape}});return t.disposeIntermediateTensorInfo(h),f}const n3={kernelName:Po,backendName:"webgl",kernelFunc:t3};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class s3{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,o=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${o}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class r3{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,a=e.strideWidth,o=e.dataFormat==="channelsLast",i=t-1-e.padInfo.top,c=s-1-e.padInfo.left,l=o?1:2,u=o?2:3,d=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${d}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class a3{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,a=e.padInfo.front,o=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${a};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${o};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class o3{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,a=e.strideDepth,o=e.strideHeight,i=e.strideWidth,c=t-1-e.padInfo.front,l=s-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${l}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${a}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i3(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:a}=e,{strides:o,pad:i,dataFormat:c,dimRoundingMode:l,filterShape:u}=s,d=fn(c),p=je(r.shape,u,o,1,i,l,!1,d),h=new s3(p);return t.runWebGLProgram(h,[r,a],"float32")}const c3={kernelName:Lo,backendName:"webgl",kernelFunc:i3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l3(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:a}=e,{inputShape:o,strides:i,pad:c,dataFormat:l,dimRoundingMode:u}=s,d=fn(l),p=je(o,a.shape,i,1,c,u,!1,d),h=new r3(p);return t.runWebGLProgram(h,[r,a],"float32")}const u3={kernelName:Bo,backendName:"webgl",kernelFunc:l3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d3(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:a}=e,{strides:o,pad:i,dilations:c}=s,l=Pn(r.shape,a.shape,o,c,i),u=new JO(l);return t.runWebGLProgram(u,[r,a],"float32")}const p3={kernelName:Vo,backendName:"webgl",kernelFunc:d3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h3(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:a}=e,{strides:o,pad:i,filterShape:c}=s,l=Pn(r.shape,c,o,1,i),u=new a3(l);return t.runWebGLProgram(u,[r,a],"float32")}const f3={kernelName:Vl,backendName:"webgl",kernelFunc:h3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m3(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:a}=e,{pad:o,strides:i,inputShape:c}=s,l=Pn(c,a.shape,i,1,o),u=new o3(l);return t.runWebGLProgram(u,[r,a],"float32")}const g3={kernelName:Mo,backendName:"webgl",kernelFunc:m3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y3=xy+`
  return cos(x);
`,x3=me({opSnippet:y3}),b3={kernelName:Sr,backendName:"webgl",kernelFunc:x3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w3=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,$3=me({opSnippet:w3}),v3={kernelName:Tr,backendName:"webgl",kernelFunc:$3};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class C3{constructor(e,t,s,r,a){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,i,c,l]=e,[u]=t,[d,p]=s;this.outputShape=[u,d,p,l];const h=r==="bilinear"?1:0,[f,m]=[`${i-1}.0`,`${c-1}.0`],[g,y,x]=d>1?[`${(i-1)/(d-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[w,$,v]=p>1?[`${(c-1)/(p-1)}`,"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${w});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${$};

        float in_y = ${x};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${a}));
          return;
        }
        float in_x = ${v};
        if( in_x < 0.0 || in_x > ${m} ) {
          setOutput(float(${a}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${h} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N3=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:a,boxInd:o}=e,{cropSize:i,method:c,extrapolationValue:l}=s,u=new C3(r.shape,a.shape,i,c,l);return t.runWebGLProgram(u,[r,a,o],"float32")},k3={kernelName:zo,backendName:"webgl",kernelFunc:N3};class Ly{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.outputShape=e;const r=e.length,a=t?"0.0":`getX(${By(r,"coords")})`,o=e[e.length-1];let i="",c="";t?(i=s?`end != ${o-1}`:"end != 0",c=s?"end + 1":"end - 1"):(i=s?`end + pow2 < ${o}`:"end >= pow2",c=s?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Ne(r)} coords = getOutputCoords();
        int end = ${Vy(r,"coords")};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${i}) {
          int idx = ${c};
          ${Vy(r,"coords")} = idx;
          val += getX(${By(r,"coords")});
        }
        setOutput(val);
      }
    `}}function By(n,e){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative sum for rank ${n} is not yet supported`)}function Vy(n,e){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw Error(`Cumulative sum for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I3(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,exclusive:o,reverse:i}=s,c=r.shape.length,l=Me([a],c);let u=r;l!=null&&(u=dt({inputs:{x:r},backend:t,attrs:{perm:l}}));const d=We(1,c)[0];if(d!==c-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${r.shape.length-1} but got axis=${a}`);const p=u.shape[d];let h=Ct({inputs:{x:u},backend:t});for(let f=0;f<=Math.ceil(Math.log2(p))-1;f++){const m=new Ly(u.shape,!1,i),g=[[f]],y=h;h=t.runWebGLProgram(m,[h],h.dtype,g),t.disposeIntermediateTensorInfo(y)}if(o){const f=new Ly(u.shape,o,i),m=h;h=t.runWebGLProgram(f,[h],h.dtype),t.disposeIntermediateTensorInfo(m)}if(l!=null){const f=vc(l),m=dt({inputs:{x:h},backend:t,attrs:{perm:f}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(u),m}return h}const S3={kernelName:Wo,backendName:"webgl",kernelFunc:I3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T3(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:a}=e,{size:o,binaryOutput:i}=s;if(r.shape.length===1){const c=t.readSync(r.dataId),l=t.readSync(a.dataId),u=ry(c,l,a.dtype,a.shape,o);return t.makeTensorInfo([o],a.dtype,u)}else if(r.shape.length===2){const c=t.bufferSync(r),l=t.bufferSync(a),u=WA(c,l,o,i);return t.makeTensorInfo(u.shape,a.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const E3={kernelName:Uo,backendName:"webgl",kernelFunc:T3};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class R3{constructor(e,t,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _3(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:a,dataFormat:o}=s,i=r.shape[0],c=o==="NHWC"?r.shape[1]:r.shape[2],l=o==="NHWC"?r.shape[2]:r.shape[3],u=o==="NHWC"?r.shape[3]:r.shape[1],d=c*a,p=l*a,h=u/(a*a),f=o==="NHWC"?[i,d,p,h]:[i,h,d,p],m=new R3(f,a,o);return t.runWebGLProgram(m,[r],r.dtype)}const A3={kernelName:Go,backendName:"webgl",kernelFunc:_3};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class My{constructor(e,t=!1,s=null,r=!1,a=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=_t(this.outputShape.length);const o=e.filterHeight,i=e.filterWidth,c=e.outChannels/e.inChannels;let l="",u="";s&&(r?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:a?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:l=`
          float activation(float x) {
            ${s}
          }
        `,u="result = activation(result);");const d=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${c};
        int q = d2 - d1 * ${c};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${d}
        ${u}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wy{constructor(e,t=!1,s=null,r=!1,a=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=_t(this.outputShape.length);const o=e.outChannels/e.inChannels,i=e.padInfo.left,c=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,d=e.filterWidth,p=d;let h=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<d;y++)h+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;h+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let y=0;y<d;y++)h+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;h+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(p+1)/2;y++){const x=y*2;if(h+=`
          xC = xCCorner + ${x*l};
          `,c===1){if(x<d&&(i%2==1?(h+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }
              `,l===1&&x>0?h+=`
                xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);
                `:h+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                  } else {
                    xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                  }
                  `):h+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xC${x} = xTexelC${x};
                `,x+1<d)){const w=i%2==0?Sl(l):l;l%2==0&&i%2==1||l%2!=0&&i%2!=1?(h+=`
                  xCOffset = xC + imod(pads[1], 2) + ${w};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                    xTexelC${x+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${x+1}.zw = vec2(0.0);
                    }
                    xTexelC${x+1}Ready = 1;
                  }
                  `,l>1&&(h+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                      xTexelC${x} = getX(batch, xR, xCOffset, d1);
                      xTexelC${x}Ready = 1;
                    }
                    `),h+=`
                  xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);
                  `):w===1?h+=`
                    xC${x+1} = xTexelC${x};
                    `:h+=`
                    xCOffset = xC + ${w};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                      xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${x+1}.zw = vec2(0.0);
                      }
                      xTexelC${x+1}Ready = 1;
                    }

                    xC${x+1} = xTexelC${x+1};
                    `}}else x<d&&(i%2==1?(h+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.0);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
              `,x+1<d&&(h+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);
                `)):(h+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(
                  xTexelC${x}.xy, xTexelC${x+1}.xy);
              `,x+1<d&&(h+=`
                  xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
                `)));x<d&&(h+=`
            wTexel = getW(r, ${x}, d1, q);
            dotProd += xC${x} * vec4(wTexel.xz, wTexel.xz);
          `,x+1<d&&(h+=`
              wTexel = getW(r, ${x+1}, d1, q);
              dotProd += xC${x+1} * vec4(wTexel.xz, wTexel.xz);
            `))}h+=`
    }
  `,h+=`
      }
    `;let f="",m="";s&&(r?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:a?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:f=`vec4 activation(vec4 x) {
          ${s}
        }`,m="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),a&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${h}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${m}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D3(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:a}=e,{strides:o,pad:i,dilations:c,dimRoundingMode:l}=s;let u=c;u==null&&(u=[1,1]),C(st(o,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const d=je(r.shape,a.shape,o,u,i,l,!0);let p;M().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels==1?p=new Wy(d):p=new My(d);const h=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return t.runWebGLProgram(p,[r,a],"float32",h)}const F3={kernelName:Ho,backendName:"webgl",kernelFunc:D3};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class O3{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,a=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${a};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class P3{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,a=e.strideWidth,o=t-1-e.padInfo.top,i=s-1-e.padInfo.left,c=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${a}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${c}; dm++) {
              int d2 = d1 * ${c} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L3(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:a}=e,{strides:o,dilations:i,pad:c,dimRoundingMode:l,filterShape:u}=s,d=je(r.shape,u,o,i,c,l,!0),p=new O3(d);return t.runWebGLProgram(p,[r,a],"float32")}const B3={kernelName:qo,backendName:"webgl",kernelFunc:L3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V3(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:a}=e,{strides:o,dilations:i,pad:c,dimRoundingMode:l,inputShape:u}=s,d=je(u,a.shape,o,i,c,l,!0),p=new P3(d);return t.runWebGLProgram(p,[r,a],"float32")}const M3={kernelName:jo,backendName:"webgl",kernelFunc:V3};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class W3{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z3(n){const{inputs:e,backend:t}=n,{x:s}=e,r=[...s.shape,...s.shape],a=B(s.shape),o=Z({inputs:{x:s},backend:t,attrs:{shape:[a]}}),i=new W3(a),c=t.runWebGLProgram(i,[o],o.dtype),l=Z({inputs:{x:c},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(c),l}const U3={kernelName:Ko,backendName:"webgl",kernelFunc:z3};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class G3{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:s,padInfo:r,strideHeight:a,strideWidth:o,filterHeight:i,filterWidth:c,dilationHeight:l,dilationWidth:u}=e,{top:d,left:p}=r;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${o});
      const ivec2 pads = ivec2(${d}, ${p});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${c}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H3(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:a}=e,{strides:o,pad:i,dilations:c}=s,l=Aa(r.shape,a.shape,o,i,"NHWC",c);let u;const d=new G3(l);u=t.runWebGLProgram(d,[r,a],"float32");const p=Z({inputs:{x:u},backend:t,attrs:{shape:l.outShape}});return t.disposeIntermediateTensorInfo(u),p}const q3={kernelName:Xo,backendName:"webgl",kernelFunc:H3};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j3(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,a=e,{allDims:o,summedDims:i,idDims:c}=Od(r,a.length);Ld(o.length,c,a);const{path:l,steps:u}=Bd(i,c),d=u.length;let p=null,h=o.length;const f=[];for(let m=0;m<d;++m){for(const g of u[m]){const{permutationIndices:y,expandDims:x}=Pd(h,c[g]);let w;Vd(y)?w=a[g]:(w=dt({inputs:{x:a[g]},backend:t,attrs:{perm:y}}),f.push(w));const $=w.shape.slice();for(let v=0;v<x.length;++v)$.splice(x[v],0,1);$e(w.shape,$)||(w=Z({inputs:{x:w},backend:t,attrs:{shape:$}}),f.push(w)),p===null?p=w:(p=pp({inputs:{a:w,b:p},backend:t}),f.push(p))}m<d-1&&(l[m]>=0&&(p=ol({inputs:{x:p},backend:t,attrs:{axis:l[m]-(o.length-h),keepDims:!1}}),f.push(p)),h--)}for(const m of f)m!==p&&t.disposeIntermediateTensorInfo(m);return p}const K3={kernelName:Yo,backendName:"webgl",kernelFunc:j3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X3="return (x >= 0.0) ? x : (exp(x) - 1.0);",Y3=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Q3=me({opSnippet:X3,packedOpSnippet:Y3}),Z3={kernelName:Rr,backendName:"webgl",kernelFunc:Q3};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J3="return (b >= 1.0) ? a : a * (b + 1.0);",eP=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,tP=n=>{const{inputs:e,backend:t}=n,{dy:s,y:r}=e,a=M().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new so(eP,s.shape,r.shape):new cr(J3,s.shape,r.shape);return t.runWebGLProgram(a,[s,r],s.dtype)},nP={kernelName:zl,backendName:"webgl",kernelFunc:tP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sP=`
  return vec4(equal(a, b));
`,rP="return float(a == b);",aP=tt({opSnippet:rP,packedOpSnippet:sP,dtype:"bool",cpuKernelImpl:GA}),oP={kernelName:Ar,backendName:"webgl",kernelFunc:aP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iP=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${Sd};
  float a1 = ${Td};
  float a2 = ${Ed};
  float a3 = ${Rd};
  float a4 = ${_d};
  float a5 = ${Ad};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,cP=me({opSnippet:iP}),lP={kernelName:_r,backendName:"webgl",kernelFunc:cP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zy="return exp(x);",Uy=me({opSnippet:zy,packedOpSnippet:zy,cpuKernelImpl:HA,dtype:"float32"}),uP={kernelName:Dr,backendName:"webgl",kernelFunc:Uy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gp(n){const{inputs:e,attrs:t,backend:s}=n,{dim:r}=t,{input:a}=e,o=a.shape.length,i=a.shape.slice();let c=r;return r<0&&(C(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),c=o+r+1),i.splice(c,0,1),Z({inputs:{x:a},backend:s,attrs:{shape:i}})}const dP={kernelName:Qo,backendName:"webgl",kernelFunc:gp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gy="return exp(x) - 1.0;",pP=me({opSnippet:Gy,packedOpSnippet:Gy,cpuKernelImpl:qA}),hP={kernelName:Fr,backendName:"webgl",kernelFunc:pP};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hy{constructor(e,t,s){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const a=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=s?`${r}.0`:"1.0";let i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${a};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qy(n,e,t){const s=t.texData.get(n.dataId),r=B(n.shape),a=n.shape[n.shape.length-1],o=r/a,i=Z({inputs:{x:n},backend:t,attrs:{shape:[o,a]}}),c=i.shape,l=new Hy("real",c,e),u=new Hy("imag",c,e),d=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:c},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:c}],p=t.runWebGLProgram(l,d,"float32"),h=t.runWebGLProgram(u,d,"float32"),f=jn({inputs:{real:p,imag:h},backend:t});t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(h);const m=Z({inputs:{x:f},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(f),m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fP(n){const{inputs:e,backend:t}=n,{input:s}=e;return qy(s,!1,t)}const mP={kernelName:Zo,backendName:"webgl",kernelFunc:fP};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gP{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oo(n){const{backend:e,attrs:t}=n,{shape:s,value:r}=t;let{dtype:a}=t;if(a=a||Ts(r),a==="string"){const o=ot(a,B(s));return o.fill(r),e.makeTensorInfo(s,a,o)}else{const o=new gP(s,r),i=[[r]];return e.runWebGLProgram(o,[],a,i)}}const yP={kernelName:Jo,backendName:"webgl",kernelFunc:oo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xP{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bP={kernelName:ei,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,r=new xP(t.shape);return s.runWebGLProgram(r,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jy="return floor(x);",wP=me({opSnippet:jy,packedOpSnippet:jy,cpuKernelImpl:jA}),$P={kernelName:Or,backendName:"webgl",kernelFunc:wP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vP=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,CP=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,NP=tt({opSnippet:vP,packedOpSnippet:CP,dtype:"int32"}),kP={kernelName:Pr,backendName:"webgl",kernelFunc:NP};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IP{constructor(e){this.variableNames=["A"];const t=lt(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SP{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=lt(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TP={kernelName:nc,backendName:"webgl",kernelFunc:EP};let dr;function EP(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:r}=e;const{numChannels:a}=s,o=typeof HTMLVideoElement!="undefined"&&r instanceof HTMLVideoElement,i=typeof HTMLImageElement!="undefined"&&r instanceof HTMLImageElement,[c,l]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],u=[l,c],d=[l,c,a];(i||o)&&(dr==null&&(dr=document.createElement("canvas").getContext("2d")),dr.canvas.width=c,dr.canvas.height=l,dr.drawImage(r,0,0,c,l),r=dr.canvas);const p=t.makeTensorInfo(u,"int32");t.texData.get(p.dataId).usage=Rt.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(p.dataId),r);const h=M().getBool("WEBGL_PACK")?new SP(d):new IP(d),f=t.runWebGLProgram(h,[p],"int32");return t.disposeData(p.dataId),f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RP(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:a,bias:o,preluActivationWeights:i}=e,{strides:c,pad:l,dataFormat:u,dilations:d,dimRoundingMode:p,activation:h,leakyreluAlpha:f}=s,m=fn(u),g=je(r.shape,a.shape,c,d,l,p,!1,m);let y;const x=[];if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=Oy({x:r,filter:a,convInfo:g,backend:t,bias:o,activation:h,preluActivationWeights:i,leakyreluAlpha:f});else if(M().getBool("WEBGL_CONV_IM2COL")&&r.shape[0]===1)y=Py({x:r,filter:a,convInfo:g,backend:t,bias:o,activation:h,preluActivationWeights:i,leakyreluAlpha:f});else{const $=o!=null,v=i!=null,k=h==="leakyrelu",I=h?rl(h,!1):null,S=new Fy(g,$,I,v,k),A=[r,a];if(o&&A.push(o),i&&A.push(i),k){const R=t.makeTensorInfo([],"float32",dn(f,"float32"));A.push(R),x.push(R)}y=t.runWebGLProgram(S,A,"float32")}const w=Z({inputs:{x:y},backend:t,attrs:{shape:g.outShape}});return x.push(y),x.forEach($=>t.disposeIntermediateTensorInfo($)),w}const _P={kernelName:$a,backendName:"webgl",kernelFunc:RP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AP(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:a,bias:o,preluActivationWeights:i}=e,{strides:c,pad:l,dilations:u,dimRoundingMode:d,activation:p,leakyreluAlpha:h}=s,f=[];let m=u;m==null&&(m=[1,1]),C(st(c,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${c} and dilations '${m}'`);const g=je(r.shape,a.shape,c,m,l,d,!0),y=M().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,x=p?rl(p,y):null,w=[r,a],$=o!=null,v=i!=null,k=p==="leakyrelu";if($&&w.push(o),v&&w.push(i),k){const R=t.makeTensorInfo([],"float32",dn(h,"float32"));w.push(R),f.push(R)}let I;y?I=new Wy(g,$,x,v,k):I=new My(g,$,x,v,k);const S=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],A=t.runWebGLProgram(I,w,"float32",S);return f.forEach(R=>t.disposeIntermediateTensorInfo(R)),A}const DP={kernelName:va,backendName:"webgl",kernelFunc:AP};class FP{constructor(e,t,s){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=s;const r=Ne(t.length),a=Ne(s.length),o=this.sliceDim>1?"strides[j]":"strides";this.userCode=`
        ${r} strides = ${r}(${this.strides});
         void main() {
          ${a} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${o};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OP(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,a=r.shape,o=a[a.length-1],i=B(s.shape),[c,l,u,d]=fc(s,r),p=Z({inputs:{x:r},backend:t,attrs:{shape:[l,o]}}),h=Z({inputs:{x:s},backend:t,attrs:{shape:[B(s.shape)/u,u]}});if(t.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const y=t.readSync(r.dataId),x=t.bufferSync(s),w=KA(y,x,s.dtype,l,o,u,d,s.shape,i);return t.makeTensorInfo(c,s.dtype,w.values)}const f=new FP(o,d,[l,u]),m=t.runWebGLProgram(f,[h,p],h.dtype),g=Z({inputs:{x:m},backend:t,attrs:{shape:c}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(m),g}const PP={kernelName:si,backendName:"webgl",kernelFunc:OP};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LP{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const s=Ne(this.rank),r=BP(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${r}));
      }
    `}}function BP(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)r===2?s.push("int(getIndices(resRC.x, resRC.z))"):s.push(`${t[r]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ky(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:a}=e,{axis:o,batchDims:i}=s,c=ge(o,r.shape)[0],l=t.readSync(a.dataId),u=r.shape[c];for(let $=0;$<l.length;++$){const v=l[$];C(v<=u-1&&v>=0,()=>`GatherV2: the index value ${v} is not in [0, ${u-1}]`)}const d=Wd(r,a,c,i),p=B(a.shape),h=[],f=Z({inputs:{x:r},backend:t,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),m=Z({inputs:{x:a},backend:t,attrs:{shape:[d.batchSize,p/d.batchSize]}});h.push(f),h.push(m);const g=[d.batchSize,d.outerSize,p/d.batchSize,d.sliceSize];if(t.shouldExecuteOnCPU([r,a])||r.dtype==="string"){const $=t.bufferSync(m),v=t.bufferSync(f),k=XA(v,$,g);return h.forEach(I=>t.disposeIntermediateTensorInfo(I)),t.makeTensorInfo(d.outputShape,k.dtype,k.values)}const y=new LP(f.shape,g),x=t.runWebGLProgram(y,[f,m],f.dtype);h.push(x);const w=Z({inputs:{x},backend:t,attrs:{shape:d.outputShape}});return h.forEach($=>t.disposeIntermediateTensorInfo($)),w}const VP={kernelName:ni,backendName:"webgl",kernelFunc:Ky};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MP="return float(a > b);",WP=`
  return vec4(greaterThan(a, b));
`,zP=tt({opSnippet:MP,packedOpSnippet:WP,cpuKernelImpl:YA,dtype:"bool"}),UP={kernelName:Lr,backendName:"webgl",kernelFunc:zP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GP="return float(a >= b);",HP=`
  return vec4(greaterThanEqual(a, b));
`,qP=tt({opSnippet:GP,packedOpSnippet:HP,dtype:"bool",cpuKernelImpl:QA}),jP={kernelName:Br,backendName:"webgl",kernelFunc:qP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KP(n){const{inputs:e,backend:t}=n,{input:s}=e;return qy(s,!0,t)}const XP={kernelName:ri,backendName:"webgl",kernelFunc:KP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YP="return float(!isnan(x) && !isinf(x));",QP=me({opSnippet:YP,dtype:"bool"}),ZP={kernelName:Mr,backendName:"webgl",kernelFunc:QP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JP="return float(isinf(x));",eL=me({opSnippet:JP,dtype:"bool"}),tL={kernelName:Wr,backendName:"webgl",kernelFunc:eL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nL="return float(isnan(x));",sL=me({opSnippet:nL,dtype:"bool"}),rL={kernelName:zr,backendName:"webgl",kernelFunc:sL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aL="return float(a < b);",oL=`
  return vec4(lessThan(a, b));
`,iL=tt({opSnippet:aL,packedOpSnippet:oL,cpuKernelImpl:ZA,dtype:"bool"}),cL={kernelName:Ur,backendName:"webgl",kernelFunc:iL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lL="return float(a <= b);",uL=`
  return vec4(lessThanEqual(a, b));
`,dL=tt({opSnippet:lL,packedOpSnippet:uL,cpuKernelImpl:JA,dtype:"bool"}),pL={kernelName:Gr,backendName:"webgl",kernelFunc:dL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hL(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:a}=t,o=eD(s,r,a);return e.makeTensorInfo([o.length],"float32",o)}const fL={kernelName:ii,backendName:"webgl",kernelFunc:hL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mL=`if (x < 0.0) return NAN;
  return log(x);`,gL=`
  vec4 result = log(x);
  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));
  result.r = isNaN.r == 1.0 ? NAN : result.r;
  result.g = isNaN.g == 1.0 ? NAN : result.g;
  result.b = isNaN.b == 1.0 ? NAN : result.b;
  result.a = isNaN.a == 1.0 ? NAN : result.a;

  return result;
`,yL=me({opSnippet:mL,packedOpSnippet:gL,cpuKernelImpl:tD}),xL={kernelName:Hr,backendName:"webgl",kernelFunc:yL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bL="return log(1.0 + x);",wL=me({opSnippet:bL}),$L={kernelName:qr,backendName:"webgl",kernelFunc:wL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vL="return float(a >= 1.0 && b >= 1.0);",CL=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,NL=tt({opSnippet:vL,packedOpSnippet:CL,dtype:"bool"}),kL={kernelName:jr,backendName:"webgl",kernelFunc:NL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IL="return float(!(x >= 1.0));",SL=me({opSnippet:IL}),TL={kernelName:Kr,backendName:"webgl",kernelFunc:SL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EL="return float(a >= 1.0 || b >= 1.0);",RL=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,_L=tt({opSnippet:EL,packedOpSnippet:RL,dtype:"bool"}),AL={kernelName:Xr,backendName:"webgl",kernelFunc:_L};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DL{constructor(e,t,s,r,a){this.variableNames=["x"],this.outputShape=[];const o=t,i=e[3]-1;this.outputShape=e;let c;const l=`float(${s}) + float(${r}) * sum`;a===.5?c=`inversesqrt(${l})`:a===1?c=`1.0/(${l})`:c=`exp(log(${l}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${c};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FL{constructor(e,t,s,r,a){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,i=e[3]-1;this.outputShape=e;let c;const l=`float(${s}) + float(${r}) * sum`;a===.5?c=`inversesqrt(${l})`:a===1?c=`1.0/(${l})`:c=`exp(log(${l}) * float(-${a}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${c};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OL=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:a,bias:o,alpha:i,beta:c}=s,l=M().getBool("WEBGL_PACK_NORMALIZATION")?new FL(r.shape,a,o,i,c):new DL(r.shape,a,o,i,c);return t.runWebGLProgram(l,[r],r.dtype)},PL={kernelName:ci,backendName:"webgl",kernelFunc:OL};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class LL{constructor(e,t,s,r,a){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=s,this.alpha=r,this.beta=a,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${a})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${a});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BL=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r,y:a,dy:o}=e,{depthRadius:i,bias:c,alpha:l,beta:u}=s,d=new LL(r.shape,i,c,l,u);return t.runWebGLProgram(d,[r,a,o],r.dtype)},VL={kernelName:Ul,backendName:"webgl",kernelFunc:BL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ML(n,e,t,s){const r=B(e),o=B(n.shape)/r,i=Z({inputs:{x:n},attrs:{shape:[o,r]},backend:s}),c=Ns(i,n.dtype,"max",s),l=Z({inputs:{x:c},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(c),l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xy(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:a,keepDims:o}=s,i=r.shape.length,c=ge(a,r.shape);let l=c;const u=Me(l,i),d=u!=null,p=t.shouldExecuteOnCPU([r]);let h=r;if(d){if(p){const w=t.texData.get(h.dataId).values,$=new Array(i);for(let I=0;I<$.length;I++)$[I]=r.shape[u[I]];const v=dp(w,r.shape,r.dtype,u,$);h=t.makeTensorInfo($,r.dtype);const k=t.texData.get(h.dataId);k.values=v}else h=al(r,u,t);l=We(l.length,i)}Je("max",l,i);const[f,m]=Ze(h.shape,l);let g=f;o&&(g=He(f,c));let y;if(p){const w=t.texData.get(h.dataId).values,$=nD(w,B(m),g,r.dtype);y=t.makeTensorInfo(g,r.dtype);const v=t.texData.get(y.dataId);v.values=$}else y=ML(h,m,g,t);return d&&t.disposeIntermediateTensorInfo(h),y}const WL={kernelName:li,backendName:"webgl",kernelFunc:Xy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zL=hy+`
  return max(a, b);
`,UL=`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+sl+`
  return result;
`,GL=tt({opSnippet:zL,packedOpSnippet:UL,cpuKernelImpl:sD}),HL={kernelName:Yr,backendName:"webgl",kernelFunc:GL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qL(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;to(r,"maxPool");const{filterSize:a,strides:o,pad:i,dimRoundingMode:c}=s,l=1;C(st(o,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const u=Pt(r.shape,a,o,l,i,c);if(u.filterWidth===1&&u.filterHeight===1&&$e(u.inShape,u.outShape))return Ct({inputs:{x:r},backend:t});const d=new ro(u,"max",!1);return t.runWebGLProgram(d,[r],r.dtype)}const jL={kernelName:ui,backendName:"webgl",kernelFunc:qL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KL(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:a,strides:o,pad:i,dataFormat:c,dimRoundingMode:l}=s,u=[1,1,1],d=hn(r.shape,a,o,u,i,l,c),p=new hp(d,"max",!1);return t.runWebGLProgram(p,[r],r.dtype)}const XL={kernelName:di,backendName:"webgl",kernelFunc:KL};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YL{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,a=e.effectiveFilterHeight,o=e.effectiveFilterWidth,i=a-1-e.padInfo.top,c=o-1-e.padInfo.left,l=a*o-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${a};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class QL{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,o=e.dilationHeight,i=e.dilationWidth,c=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,d=c-1-e.padInfo.front,p=l-1-e.padInfo.top,h=u-1-e.padInfo.left,f=c*l*u-1;this.userCode=`
      const ivec3 pads = ivec3(${d}, ${p}, ${h});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
           wD += ${a}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZL(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:a}=e,o=a,{filterSize:i,strides:c,pad:l,dimRoundingMode:u}=s,d=[1,1,1],p=hn(o.shape,i,c,d,l,u),h=new hp(p,"max",!0),f=t.runWebGLProgram(h,[o],o.dtype),m=new QL(p),g=t.runWebGLProgram(m,[r,f],o.dtype);return t.disposeIntermediateTensorInfo(f),g}const JL={kernelName:Hl,backendName:"webgl",kernelFunc:ZL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eB(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:a,output:o}=e,i=a;to([a,o],"maxPoolGrad");const{filterSize:c,strides:l,pad:u,dimRoundingMode:d}=s,p=Pt(i.shape,c,l,1,u,d),h=!0,f=new ro(p,"max",h),m=t.runWebGLProgram(f,[i],i.dtype),g=new YL(p),y=t.runWebGLProgram(g,[r,m],i.dtype);return t.disposeIntermediateTensorInfo(m),y}const tB={kernelName:Gl,backendName:"webgl",kernelFunc:eB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nB(n,e,t,s){let r=new ro(t,"max",!1);const a=s.runWebGLProgram(r,[n],"float32");r=new ro(t,"max",!0,!0,e);const o=s.runWebGLProgram(r,[n],"float32");return[a,o]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sB={kernelName:pi,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:a,pad:o,includeBatchInIndex:i}=e,c=t;C(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const l=[1,1];C(st(a,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);const u=Pt(s.shape,r,a,l,o),[d,p]=nB(s,i,u,c);return[d,p]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rB(n,e,t,s){const r=B(e),o=B(n.shape)/r,i=Z({inputs:{x:n},attrs:{shape:[o,r]},backend:s}),c=Ns(i,"float32","mean",s),l=Z({inputs:{x:c},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(c),l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aB={kernelName:hi,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{keepDims:r,axis:a}=e,o=t,i=s.shape.length,c=ge(a,s.shape);let l=c;const u=Me(l,i),d=u!=null,p=o.shouldExecuteOnCPU([s]),h=[];let f=s;if(d){if(p){const $=o.texData.get(f.dataId).values,v=new Array(i);for(let S=0;S<v.length;S++)v[S]=s.shape[u[S]];const k=dp($,s.shape,s.dtype,u,v);f=o.makeTensorInfo(v,s.dtype);const I=o.texData.get(f.dataId);I.values=k}else f=al(s,u,o);h.push(f),l=We(l.length,i)}Je("sum",l,i);const[m,g]=Ze(f.shape,l);let y=m;r&&(y=He(m,c));const x=rB(f,g,y,o);for(const w of h)o.disposeIntermediateTensorInfo(w);return x}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oB(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,keepDims:o}=s,i=r.shape.length,c=ge(a,r.shape);let l=c;const u=Me(l,i);let d=r;u!=null&&(d=dt({inputs:{x:r},backend:t,attrs:{perm:u}}),l=We(l.length,r.shape.length)),Je("min",l,i);const[p,h]=Ze(d.shape,l),f=B(h),m=Z({inputs:{x:d},backend:t,attrs:{shape:[-1,f]}}),g=Ns(m,m.dtype,"min",t);let y;if(o){const x=He(p,c);y=Z({inputs:{x:g},backend:t,attrs:{shape:x}})}else y=Z({inputs:{x:g},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(g),u!=null&&t.disposeIntermediateTensorInfo(d),y}const iB={kernelName:fi,backendName:"webgl",kernelFunc:oB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cB=hy+`
  return min(a, b);
`,lB=`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+sl+`
  return result;
`,uB=tt({opSnippet:cB,packedOpSnippet:lB,cpuKernelImpl:rD}),dB={kernelName:Qr,backendName:"webgl",kernelFunc:uB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pB{constructor(e,t,s){this.variableNames=["x"],this.outputShape=t.map((u,d)=>u[0]+e[d]+u[1]);const r=e.length,a=Ne(r),o=t.map(u=>u[0]).join(","),i=t.map((u,d)=>u[0]+e[d]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),l=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${o};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${o});
      ${a} end = ${a}(${i});

      void main() {
        ${a} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${a} coords = outC - start;
        setOutput(getX(${c}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hB{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((f,m)=>f[0]+e[m]+f[1]);const r=e.length,a=Ne(r),o=t.map(f=>f[0]).join(","),i=t.map((f,m)=>f[0]+e[m]).join(","),c=ut("rc",r),l=ut("source",r),u=`${c[r-1]} < ${this.outputShape[r-1]}`,d=r===1?"source":`vec2(${l.slice(-2).join()})`,p=s==="reflect"?0:1;let h="";if(r===1){const f=`
        ${a} source = rc;
        if (source < start) {
          source = start * 2 - source - ${p};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${p};
        }
        source -= start;
      `;h=`
        ${a} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${l.join()}), ${d});
        ${c[r-1]} += 1;
        if(${u}) {
          ${f}
          result[1] = getChannel(getX(${l.join()}), ${d});
        }
      `}else{const f=`
        ${a} source = rc;
        ${a} lt = ${a}(lessThan(source, start));
        ${a} gte = ${a}(greaterThanEqual(source, end));
        ${a} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${p}) +
                gte * ((end - 1) * 2 - source + ${p});
        source -= start;
      `;h=`
        ${a} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${l.join()}), ${d});
        ${c[r-1]} += 1;
        if(${u}) {
          ${f}
          result[1] = getChannel(getX(${l.join()}), ${d});
        }
        rc = outputLoc;
        ${c[r-2]} += 1;
        if(${c[r-2]} < ${this.outputShape[r-2]}) {
          ${f}
          result[2] = getChannel(getX(${l.join()}), ${d});
          ${c[r-1]} += 1;
          if(${u}) {
            ${f}
            result[3] = getChannel(getX(${l.join()}), ${d});
          }
        }
      `}this.userCode=`
      const ${a} start = ${a}(${o});
      const ${a} end = ${a}(${i});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fB=({inputs:n,backend:e,attrs:t})=>{const{x:s}=n,{paddings:r,mode:a}=t,o=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new hB(s.shape,r,a):new pB(s.shape,r,a);return e.runWebGLProgram(o,[s],s.dtype)},mB={kernelName:mi,backendName:"webgl",kernelFunc:fB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gB=`if (b == 0.0) return NAN;
  return mod(a, b);`,yB=`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  `+sl+`
  return result;
`,xB=tt({opSnippet:gB,packedOpSnippet:yB}),bB={kernelName:Zr,backendName:"webgl",kernelFunc:xB};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wB{constructor(e,t,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $B=`
if (a == b) {
  return 1.0;
};
return a / b;`,vB=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,Yy=tt({opSnippet:$B,packedOpSnippet:vB,checkOutOfBounds:!0}),CB={kernelName:Er,backendName:"webgl",kernelFunc:Yy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qy="return a - b;",Zy=tt({opSnippet:Qy,packedOpSnippet:Qy,supportsComplex:!0,cpuKernelImpl:wD}),NB={kernelName:ma,backendName:"webgl",kernelFunc:Zy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jy(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:a}=s,o=ge([a],r.shape),i=Xy({inputs:{x:r},backend:t,attrs:{reductionIndices:o,keepDims:!1}}),c=He(i.shape,o),l=Z({inputs:{x:i},backend:t,attrs:{shape:c}}),u=Zy({inputs:{a:r,b:l},backend:t}),d=Uy({inputs:{x:u},backend:t}),p=ol({inputs:{x:d},backend:t,attrs:{axis:o,keepDims:!1}}),h=Z({inputs:{x:p},backend:t,attrs:{shape:c}}),f=Yy({inputs:{a:d,b:h},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(h),f}const kB={kernelName:Vi,backendName:"webgl",kernelFunc:Jy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IB(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:a,seed:o,normalized:i}=s,c=i?r:Jy({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),l=c.shape[0],u=c.shape[1],d=new wB(l,u,a),p=[[o]],h=t.runWebGLProgram(d,[c],"int32",p);return i||t.disposeIntermediateTensorInfo(c),h}const SB={kernelName:gi,backendName:"webgl",kernelFunc:IB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ex="return -x;";function TB(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const a=t.texData.get(s.dataId),[o,i]=oD(a.values,s.shape,s.dtype);return t.makeTensorInfo(i,s.dtype,o)}let r;return M().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new ir(s.shape,ex):r=new qn(s.shape,ex),t.runWebGLProgram(r,[s],s.dtype)}const EB={kernelName:yi,backendName:"webgl",kernelFunc:TB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RB=Ac;function _B(n){ht("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:a}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:c}=s,l=t.readSync(r.dataId),u=t.readSync(a.dataId),{selectedIndices:d}=RB(l,u,o,i,c);return t.makeTensorInfo([d.length],"int32",new Int32Array(d))}const AB={kernelName:xi,backendName:"webgl",kernelFunc:_B};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DB=Dc;function FB(n){ht("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:a}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:c,padToMaxOutputSize:l}=s,u=t.readSync(r.dataId),d=t.readSync(a.dataId),{selectedIndices:p,validOutputs:h}=DB(u,d,o,i,c,l);return[t.makeTensorInfo([p.length],"int32",new Int32Array(p)),t.makeTensorInfo([],"int32",new Int32Array([h]))]}const OB={kernelName:bi,backendName:"webgl",kernelFunc:FB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PB=Fc;function LB(n){ht("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:a}=e,{maxOutputSize:o,iouThreshold:i,scoreThreshold:c,softNmsSigma:l}=s,u=t.readSync(r.dataId),d=t.readSync(a.dataId),p=o,h=i,f=c,m=l,{selectedIndices:g,selectedScores:y}=PB(u,d,p,h,f,m);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const BB={kernelName:wi,backendName:"webgl",kernelFunc:LB};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VB{constructor(e,t,s,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MB=n=>{const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{depth:a,onValue:o,offValue:i}=s,c=B(r.shape),l=new VB(c,a,o,i),u=Z({inputs:{x:r},backend:t,attrs:{shape:[c]}}),d=t.runWebGLProgram(l,[u],r.dtype);t.disposeIntermediateTensorInfo(u);const p=[...r.shape,a],h=Z({inputs:{x:d},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(d),h},WB={kernelName:vi,backendName:"webgl",kernelFunc:MB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dl(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const r=ao({inputs:{input:s},backend:t}),a=dl({inputs:{x:r},backend:t}),o=ul({inputs:{input:s},backend:t}),i=dl({inputs:{x:o},backend:t}),c=jn({inputs:{real:a,imag:i},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),c}else return oo({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const zB={kernelName:tc,backendName:"webgl",kernelFunc:dl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tx(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=ao({inputs:{input:s},backend:t}),a=tx({inputs:{x:r},backend:t}),o=ul({inputs:{input:s},backend:t}),i=dl({inputs:{x:o},backend:t}),c=jn({inputs:{real:a,imag:i},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(i),c}else return oo({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const UB={kernelName:$i,backendName:"webgl",kernelFunc:tx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GB(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return gp({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const a=e[0].shape,o=e[0].dtype;e.forEach(u=>{Ye(a,u.shape,"All tensors passed to stack must have matching shapes"),C(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const i=[],c=e.map(u=>{const d=gp({inputs:{input:u},backend:t,attrs:{dim:r}});return i.push(d),d}),l=Dy({inputs:c,backend:t,attrs:{axis:r}});return i.forEach(u=>t.disposeIntermediateTensorInfo(u)),l}const HB={kernelName:Ci,backendName:"webgl",kernelFunc:GB};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qB{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((l,u)=>l[0]+e[u]+l[1]);const r=e.length,a=Ne(r),o=t.map(l=>l[0]).join(","),i=t.map((l,u)=>l[0]+e[u]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${o};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${a} start = ${a}(${o});
      ${a} end = ${a}(${i});

      void main() {
        ${a} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${a} coords = outC - start;
          setOutput(getX(${c}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jB{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((m,g)=>m[0]+e[g]+m[1]);const r=e.length,a=Ne(r),o=t.map(m=>m[0]).join(","),i=t.map((m,g)=>m[0]+e[g]).join(","),c=ut("rc",r),l=ut("source",r),u=`${c[r-1]} < ${this.outputShape[r-1]}`,d=r===1?"source":`vec2(${l.slice(-2).join()})`,p=[`${a} rc = outputLoc;`,`${c[r-1]} += 1;
       if(${u}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${c[r-2]} += 1;
       if(${c[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${c[r-1]} += 1;
         if(${u}) {`],h=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let m=0,g=r===1?2:4;m<g;m++)f+=`
        ${p[m]}
        if (${h}) {
          result[${m}] = float(value);
        } else {
          ${a} source = rc - start;
          result[${m}] = getChannel(getX(${l.join()}), ${d});
        }
      `;f+=r===1?"} ":"}}",this.userCode=`
      const ${a} start = ${a}(${o});
      const ${a} end = ${a}(${i});

      void main() {
        ${a} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nx=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:a,constantValue:o}=s;if(B(r.shape)===0){const l=a.map((u,d)=>u[0]+r.shape[d]+u[1]);return oo({backend:t,attrs:{shape:l,value:o,dtype:r.dtype}})}const i=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new jB(r.shape,a,o):new qB(r.shape,a,o),c=[[o]];return t.runWebGLProgram(i,[r],r.dtype,c)},KB={kernelName:Ni,backendName:"webgl",kernelFunc:nx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XB=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,YB=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  `+sl+`
  return result;
`,QB=tt({opSnippet:XB,packedOpSnippet:YB}),ZB={kernelName:ta,backendName:"webgl",kernelFunc:QB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JB(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:a,keepDims:o}=s,i=r.shape.length,c=[],l=ge(a,r.shape);let u=l;const d=Me(u,i);let p=r;d!=null&&(p=dt({inputs:{x:r},backend:t,attrs:{perm:d}}),u=We(u.length,i),c.push(p)),Je("prod",u,i);let h;if(t.shouldExecuteOnCPU([p])){const f=t.texData.get(p.dataId).values,{outVals:m,outShape:g,outDtype:y}=cD(p.shape,p.dtype,f,u);h=t.makeTensorInfo(g,y,m)}else{const[f,m]=Ze(p.shape,u),g=B(m),y=Z({inputs:{x:p},backend:t,attrs:{shape:[-1,g]}}),x=uc(r.dtype),w=Ns(y,x,"prod",t);h=Z({inputs:{x:w},backend:t,attrs:{shape:f}}),c.push(y),c.push(w)}if(o){c.push(h);const f=He(h.shape,l);h=Z({inputs:{x:h},backend:t,attrs:{shape:f}})}return c.forEach(f=>t.disposeIntermediateTensorInfo(f)),h}const eV={kernelName:Ii,backendName:"webgl",kernelFunc:JB};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sx=n=>{const{backend:e,attrs:t}=n,{start:s,stop:r,step:a,dtype:o}=t,i=lD(s,r,a,o);return e.makeTensorInfo([i.length],o,i)},tV={kernelName:Si,backendName:"webgl",kernelFunc:sx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nV="return 1.0 / x;",sV=me({opSnippet:nV}),rV={kernelName:na,backendName:"webgl",kernelFunc:sV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aV=Gt+`
  return (x < 0.0) ? 0.0 : x;
`,oV=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,iV=me({opSnippet:aV,packedOpSnippet:oV}),cV={kernelName:sa,backendName:"webgl",kernelFunc:iV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lV=Gt+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,uV=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,dV=me({opSnippet:lV,packedOpSnippet:uV}),pV={kernelName:ra,backendName:"webgl",kernelFunc:dV};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hV{constructor(e,t,s,r,a){this.variableNames=["A"],this.outputShape=[];const[o,i,c,l]=e;this.outputShape=[o,t,s,l];const u=[r&&t>1?i-1:i,r&&s>1?c-1:c],d=[r&&t>1?t-1:t,r&&s>1?s-1:s];let p;a?p="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/d[0]},
          ${u[1]/d[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fV{constructor(e,t,s,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,i,c,l]=e;this.outputShape=[o,t,s,l];const u=[r&&t>1?i-1:i,r&&s>1?c-1:c],d=[r&&t>1?t-1:t,r&&s>1?s-1:s];let p;a?p="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/d[0]},
          ${u[1]/d[1]},
          ${u[1]/d[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mV(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:a,halfPixelCenters:o,size:i}=s,[c,l]=i,u=M().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new fV(r.shape,c,l,a,o):new hV(r.shape,c,l,a,o);return t.runWebGLProgram(u,[r],"float32")}const gV={kernelName:_i,backendName:"webgl",kernelFunc:mV};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yV{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,o,i]=e,c=[s&&o>1?r-1:r,s&&i>1?a-1:a],l=[s&&o>1?o-1:o,s&&i>1?i-1:i],u=c[0]/l[0],d=c[1]/l[1],p=1/u,h=1/d,f=Math.ceil(p)*2+2,m=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${d});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${h});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${a-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xV(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:a}=e,{alignCorners:o}=s,i=new yV(a.shape,r.shape,o);return t.runWebGLProgram(i,[a],a.dtype)}const bV={kernelName:jl,backendName:"webgl",kernelFunc:xV};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wV{constructor(e,t,s,r,a){this.variableNames=["A"],this.outputShape=[];const[o,i,c,l]=e;this.outputShape=[o,t,s,l];const u=[r&&t>1?i-1:i,r&&s>1?c-1:c],d=[r&&t>1?t-1:t,r&&s>1?s-1:s],p=r?"0.5":"0.0";let h;a?h="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/d[0]},
          ${u[1]/d[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $V{constructor(e,t,s,r,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,i,c,l]=e;this.outputShape=[o,t,s,l];const u=[r&&t>1?i-1:i,r&&s>1?c-1:c],d=[r&&t>1?t-1:t,r&&s>1?s-1:s],p=r?"0.5":"0.0";let h;a?h="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/d[0]},
          ${u[1]/d[1]},
          ${u[1]/d[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${p})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vV(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:a,halfPixelCenters:o,size:i}=s,[c,l]=i,u=M().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new $V(r.shape,c,l,a,o):new wV(r.shape,c,l,a,o);return t.runWebGLProgram(u,[r],r.dtype)}const CV={kernelName:Ri,backendName:"webgl",kernelFunc:vV};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NV{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,a]=t,[,o,i]=e,c=[s&&o>1?r-1:r,s&&i>1?a-1:a],l=[s&&o>1?o-1:o,s&&i>1?i-1:i],u=c[0]/l[0],d=c[1]/l[1],p=1/u,h=1/d,f=Math.ceil(p)*2+2,m=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${d});

        const float invHeightScale = float(${p});
        const float invWidthScale = float(${h});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${c[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${c[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${a}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kV(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:a}=e,{alignCorners:o}=s,i=new NV(a.shape,r.shape,o);return t.runWebGLProgram(i,[a],a.dtype)}const IV={kernelName:ql,backendName:"webgl",kernelFunc:kV};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SV{constructor(e,t){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,a=e.map((i,c)=>r(c)).join(","),o=Ne(s);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TV{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const r=ut("rc",s),a=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,o=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,i=Ne(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${a}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${c(r.slice())};
          if(${a}){
            result.g = ${l(r.slice())};
          }
          if(${o}) {
            result.b = ${u(r.slice())};
            if(${a}) {
              result.a = ${d(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function c(f){return p(f)}function l(f){return f[s-1]="("+f[s-1]+" + 1)",p(f)}function u(f){return f[s-2]="("+f[s-2]+" + 1)",p(f)}function d(f){return f[s-1]="("+f[s-1]+" + 1)",f[s-2]="("+f[s-2]+" + 1)",p(f)}function p(f){const m=e.map((x,w)=>h(w,f)),g=m.join(","),y=m.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function h(f,m){return t.indexOf(f)!==-1&&e[f]!==1?`${e[f]} - ${m[f]} - 1`:`${m[f]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EV(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:a}=s,o=r.shape.length,i=ge(a,r.shape);if(o===0)return Ct({inputs:{x:r},backend:t});const c=M().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new TV(r.shape,i):new SV(r.shape,i);return t.runWebGLProgram(c,[r],r.dtype)}const RV={kernelName:Ai,backendName:"webgl",kernelFunc:EV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _V{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],r=e[2];this.outputShape=e;let a="";typeof t=="number"?a=`float outputValue = ${t.toFixed(2)};`:a=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${a}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AV={kernelName:sc,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:a,center:o}=e,i=t,c=new _V(s.shape,a),[l,u]=vd(o,s.shape[1],s.shape[2]),d=[[l,u,Math.sin(r),Math.cos(r)]];return i.runWebGLProgram(c,[s],s.dtype,d)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DV=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,FV=me({opSnippet:DV}),OV={kernelName:aa,backendName:"webgl",kernelFunc:FV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PV="return inversesqrt(x);",LV=me({opSnippet:PV,cpuKernelImpl:uD}),BV={kernelName:oa,backendName:"webgl",kernelFunc:LV};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rx{constructor(e,t,s,r,a,o,i=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const c=Ne(a.length),l=Ne(o.length);let u="";s===1?u="i":s===2&&(u="i, j");const d=`getIndices(${u})`;let p="";r===1?p="i":r===2&&(p="i, coords[1]");const h=`getUpdates(${p})`,f=t>1?"strides[j]":"strides";this.userCode=`
        ${c} strides = ${c}(${a});

        void main() {
          ${l} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${f};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${h};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VV(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:a}=e,{shape:o}=s,{sliceRank:i,numUpdates:c,sliceSize:l,strides:u,outputSize:d}=Vs(a,r,o),p=[d/l,l];if(d===0)return t.makeTensorInfo(o,r.dtype);const h=Z({inputs:{x:r},backend:t,attrs:{shape:[c,i]}}),f=Z({inputs:{x:a},backend:t,attrs:{shape:[c,l]}}),m=t.makeTensorInfo([],"float32",new Float32Array([0])),g=new rx(c,i,h.shape.length,f.shape.length,u,p),y=t.runWebGLProgram(g,[f,h,m],f.dtype),x=Z({inputs:{x:y},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(m),x}const MV={kernelName:Di,backendName:"webgl",kernelFunc:VV};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WV{constructor(e,t,s){this.variableNames=["c","a","b"],this.outputShape=t;let r,a;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)a="resRC",r="resRC";else{const i=["resRC.x","resRC.y","resRC.z","resRC.w"],c=[],l=[];for(let u=0;u<t.length;u++)l.push(`${i[u]}`),u<e&&c.push(`${i[u]}`);r=c.join(),a=l.join()}const o=Ne(s);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${a}));
        } else {
          setOutput(getB(${a}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zV(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:a}=e,o=new WV(s.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(o,[s,r,a],xt(r.dtype,a.dtype))}const UV={kernelName:Fi,backendName:"webgl",kernelFunc:zV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GV=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${kd};
  float scale = ${Id};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,HV=me({opSnippet:GV}),qV={kernelName:ia,backendName:"webgl",kernelFunc:HV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ax="return 1.0 / (1.0 + exp(-1.0 * x));",jV=me({opSnippet:ax,packedOpSnippet:ax,cpuKernelImpl:dD}),KV={kernelName:da,backendName:"webgl",kernelFunc:jV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XV=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,YV=me({opSnippet:XV}),QV={kernelName:ua,backendName:"webgl",kernelFunc:YV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZV=xy+`
  return sin(x);
`,JV=me({opSnippet:ZV}),e4={kernelName:ca,backendName:"webgl",kernelFunc:JV};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t4=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,n4=me({opSnippet:t4}),s4={kernelName:la,backendName:"webgl",kernelFunc:n4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r4=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,a4=me({opSnippet:r4}),o4={kernelName:pa,backendName:"webgl",kernelFunc:a4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i4=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:a,paddings:o}=s;C(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const i=a.reduce((y,x)=>y*x),c=[[0,0]];c.push(...o);for(let y=1+a.length;y<r.shape.length;++y)c.push([0,0]);const l=[],u=nx({inputs:{x:r},backend:t,attrs:{paddings:c,constantValue:0}}),d=qa(u.shape,a,i,!1),p=ja(d.length,a.length,!1),h=Ka(u.shape,a,i,!1),f=Z({inputs:{x:u},backend:t,attrs:{shape:d}}),m=dt({inputs:{x:f},backend:t,attrs:{perm:p}}),g=Z({inputs:{x:m},backend:t,attrs:{shape:h}});return l.push(u),l.push(f),l.push(m),l.forEach(y=>t.disposeIntermediateTensorInfo(y)),g},c4={kernelName:Li,backendName:"webgl",kernelFunc:i4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l4(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:a,defaultValue:o}=e;if(a.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${a.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const i=t.readSync(s.dataId),c=t.readSync(r.dataId),l=t.readSync(a.dataId),u=t.readSync(o.dataId)[0],[d,p,h,f,m]=hD(i,s.shape,s.dtype,c,r.dtype,l,u);return[t.makeTensorInfo(p,s.dtype,d),t.makeTensorInfo([p[0]],r.dtype,h),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),t.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}const u4={kernelName:Mi,backendName:"webgl",kernelFunc:l4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d4(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:a}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(a.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${a.shape}`);const o=Array.from(t.readSync(r.dataId)),i=t.readSync(s.dataId),c=Array.from(t.readSync(a.dataId)),[l,u,d]=fD(i,s.shape,s.dtype,o,c);return[t.makeTensorInfo(u,s.dtype,l),t.makeTensorInfo([d.length],a.dtype,new Int32Array(d))]}const p4={kernelName:Wi,backendName:"webgl",kernelFunc:d4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h4(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:a}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${a.shape}`);const o=t.readSync(s.dataId),i=t.readSync(r.dataId),c=t.readSync(a.dataId),[l,u]=oy(o,s.shape,s.dtype,i,c,!0);return t.makeTensorInfo(u,s.dtype,l)}const f4={kernelName:zi,backendName:"webgl",kernelFunc:h4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m4(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:a}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(a.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${a.shape}`);const o=t.readSync(s.dataId),i=t.readSync(r.dataId),c=t.readSync(a.dataId),[l,u]=oy(o,s.shape,s.dtype,i,c);return t.makeTensorInfo(u,s.dtype,l)}const g4={kernelName:Ui,backendName:"webgl",kernelFunc:m4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y4(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:a,defaultValue:o}=e,{outputShape:i}=s,{sliceRank:c,numUpdates:l,strides:u,outputSize:d}=Vs(a,r,i),p=!1,h=new rx(l,c,r.shape.length,a.shape.length,u,[d,1],p),f=t.runWebGLProgram(h,[a,r,o],a.dtype),m=Z({inputs:{x:f},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(f),m}const x4={kernelName:Gi,backendName:"webgl",kernelFunc:y4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:a,axis:o}=s,i=ge(o,r.shape)[0],c=Md(r,a,i),l=r.shape.length,u=new Array(l).fill(0),d=r.shape.slice();return c.map(p=>{const h=[...d];h[i]=p;const f=lr({inputs:{x:r},backend:t,attrs:{begin:u,size:h}});return u[i]+=p,f})}const w4={kernelName:Bi,backendName:"webgl",kernelFunc:b4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ox="return sqrt(x);",$4=me({opSnippet:ox,packedOpSnippet:ox,cpuKernelImpl:mD}),v4={kernelName:ha,backendName:"webgl",kernelFunc:$4};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C4="return x * x;",N4=me({opSnippet:C4}),k4={kernelName:Kl,backendName:"webgl",kernelFunc:N4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ix="return (a - b) * (a - b);",I4=tt({opSnippet:ix,packedOpSnippet:ix}),S4={kernelName:fa,backendName:"webgl",kernelFunc:I4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T4({inputs:n,attrs:e,backend:t}){const{x:s}=n,r=Gt+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,a=new qn(s.shape,r);return t.runWebGLProgram(a,[s],s.dtype)}const E4={kernelName:ba,backendName:"webgl",kernelFunc:T4};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class R4{constructor(e,t,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,a=Ne(s.length),o=Ne(s.length);let i="";if(r===1)i="coords * strides + begin";else{let c=0;i=s.map((l,u)=>(c++,s.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${c-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${a} begin = ${a}(${e});
      ${a} strides = ${a}(${t});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:a,end:o,strides:i,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:p}=s,{finalShapeSparse:h,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:x,end:w,strides:$}=Fu(r.shape,a,o,i,c,l,u,d,p);let v;if(m)v=Z({inputs:{x:r},backend:t,attrs:{shape:f}});else if(g||y){C(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const I=Ru(x,w,$),S=lr({inputs:{x:r},backend:t,attrs:{begin:x,size:I}});v=Z({inputs:{x:S},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(S)}else if(t.shouldExecuteOnCPU([r])){const S=t.readSync(r.dataId),A=ue(r.shape,r.dtype,S),R=gD(h,A,$,x);v=t.makeTensorInfo(f,r.dtype,R.values)}else{const S=new R4(x,$,h);v=t.runWebGLProgram(S,[r],r.dtype)}const k=Z({inputs:{x:v},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(v),k}const A4={kernelName:Hi,backendName:"webgl",kernelFunc:_4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D4(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:a,leftPad:o,rightPad:i,padWidth:c,preserveShortSequences:l}=s,{data:u,dataSplits:d}=e,p=t.readSync(u.dataId),h=t.readSync(d.dataId),[f,m]=yD(p,h,r,a,o,i,c,l);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(d.shape,"int32",m)]}const F4={kernelName:qi,backendName:"webgl",kernelFunc:D4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O4(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:a,delimiter:o}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(a.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${a.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const i=t.readSync(a.dataId),c=t.readSync(o.dataId)[0],[l,u,d]=xD(i,c,r),p=u.length;return[t.makeTensorInfo([p,2],"int32",l),t.makeTensorInfo([p],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(d))]}const P4={kernelName:ji,backendName:"webgl",kernelFunc:O4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L4(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:a}=e;if(a.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=t.readSync(a.dataId),i=bD(o,r);return t.makeTensorInfo(a.shape,"int32",i)}const B4={kernelName:Ki,backendName:"webgl",kernelFunc:L4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V4="return tan(x);",M4=me({opSnippet:V4}),W4={kernelName:ga,backendName:"webgl",kernelFunc:M4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z4=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,U4=me({opSnippet:z4}),G4={kernelName:ya,backendName:"webgl",kernelFunc:U4};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class H4{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let o=0;o<s.length;o++)s[o]=e[o]*t[o];this.outputShape=s,this.rank=s.length;const r=Ne(this.rank),a=q4(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${a}));
      }
    `}}function q4(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${t[r]}, ${n[r]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cx(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:a}=s;if(r.dtype==="string"||r.shape.length>5){const c=t.readSync(r.dataId),l=r.dtype==="string"?c.map(p=>os(p)):c,u=ue(r.shape,r.dtype,l),d=$D(u,a);return t.makeTensorInfo(d.shape,d.dtype,d.values)}const o=new H4(r.shape,a);return t.runWebGLProgram(o,[r],r.dtype)}const j4={kernelName:xa,backendName:"webgl",kernelFunc:cx};class K4{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class X4{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ks(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function lx(n){let e=1;for(;e<n;)e*=2;return e}function Y4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:a,sorted:o}=s,i=M().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=M().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=r.shape,u=l[l.length-1];if(t.shouldExecuteOnCPU([r])||u<i||a>c){const R=t.readSync(r.dataId),[_,D]=vD(R,l,r.dtype,a,o);return[t.makeTensorInfo(_.shape,_.dtype,_.values),t.makeTensorInfo(D.shape,D.dtype,D.values)]}if(a===0)return l[l.length-1]=0,[t.makeTensorInfo(l,r.dtype,[]),t.makeTensorInfo(l,"int32",[])];if(u===1)return[r,oo({attrs:{shape:l,dtype:"int32",value:0},backend:t})];const d=t.texData.get(r.dataId),p=d!==null&&d.isPacked,h=p?t.unpackTensor(r):r,m=B(l)/u,g=Z({inputs:{x:h},attrs:{shape:[m,u]},backend:t});p&&ks(t,h);const y=lx(a),x=lx(u);let w=null;const $=()=>w===null?[g,g]:[g,w],v=(R,_,D)=>{const F=$(),P=new K4(D),O=[[u],[w===null?1:0],[Number.NEGATIVE_INFINITY],[R],[_]],z=w;w=t.runWebGLProgram(P,F,"int32",O),ks(t,z)};for(let R=1;R<y;R*=2){const _=R*2;for(let D=R;D>=1;D/=2)v(_,D,[m,x])}for(let R=x;R>y;R/=2){const _=$(),D=new X4([m,R/2]),P=[[u],[w===null?1:0],[y]],L=w;w=t.runWebGLProgram(D,_,"int32",P),ks(t,L);const O=y/2,z=O*2;for(let V=O;V>=1;V/=2)v(z,V,w.shape)}let k=w;w=lr({inputs:{x:w},backend:t,attrs:{begin:0,size:[m,a]}}),ks(t,k);let I=Ky({inputs:{x:g,indices:w},backend:t,attrs:{axis:1,batchDims:1}});ks(t,g);const S=l.slice(0,-1);S.push(a),k=w,w=Z({inputs:{x:w},attrs:{shape:S},backend:t}),ks(t,k);const A=I;return I=Z({inputs:{x:I},attrs:{shape:S},backend:t}),ks(t,A),[I,w]}const Q4={kernelName:Xi,backendName:"webgl",kernelFunc:Y4};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Z4{constructor(e,t,s,r,a,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const i=s==="nearest"?1:2;let c;switch(r){case"constant":c=1;break;case"reflect":c=2;break;case"wrap":c=3;break;case"nearest":c=4;break;default:c=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${c} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${a});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${a});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J4(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,transforms:a}=e,{interpolation:o,fillMode:i,fillValue:c,outputShape:l}=s,[u,d,p,h]=r.shape,[f,m]=l!=null?l:[d,p],g=[u,f,m,h],y=new Z4(d,p,o,i,c,g);return t.runWebGLProgram(y,[r,a],"float32")}const eM={kernelName:Yi,backendName:"webgl",kernelFunc:J4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tM(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:a}=e;to(a,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=s.readSync(a.dataId),{outputValues:i,outputShape:c,indices:l}=CD(o,r,a.shape,a.dtype);return[s.makeTensorInfo(c,a.dtype,i),s.makeTensorInfo([l.length],"int32",l)]}const nM={kernelName:Zi,backendName:"webgl",kernelFunc:tM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sM(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:a}=s;a<0&&(a+=r.shape.length);const o=r,i=o.shape.length,c=r.shape[a],l=new Array(i-1);let u=0;for(let m=0;m<i;m++)m!==a&&(l[u++]=o.shape[m]);const d=[],p=new Array(i).fill(0),h=o.shape.slice();h[a]=1;const f=new Array(c);for(let m=0;m<f.length;m++){p[a]=m;const g=lr({inputs:{x:o},backend:t,attrs:{begin:p,size:h}}),y=Z({inputs:{x:g},backend:t,attrs:{shape:l}});f[m]=y,d.push(g)}return d.forEach(m=>t.disposeIntermediateTensorInfo(m)),f}const rM={kernelName:Ji,backendName:"webgl",kernelFunc:sM};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aM{constructor(e,t){this.variableNames=["x","segmentIds"];const s=e.windowSize,r=e.batchSize,a=e.inSize,o=e.numSegments,i=o*Math.ceil(a/s);this.outputShape=[r,i];const c="0.0",l="sumValue",u=Math.floor(s/4)*4,d=s%4,p=`
        sumValue += dot(values, segFilter);
    `;let h="";a%s>0&&(h=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return initializationValue;
        }
      `);let f="";a%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${a}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${c};

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${p}
        }

        int inIdx = inOffset + ${u};
        if (${d===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${p}
        } else if (${d===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${p}
        } else if (${d===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${p}
        }
        setOutput(${l});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oM(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:a}=e,{numSegments:o}=s,i=r.shape.length,c=[];let l=0;const u=Me([l],i);let d=r;u!=null&&(d=dt({inputs:{x:r},backend:t,attrs:{perm:u}}),c.push(d),l=We(1,i)[0]);const p=Pm(d.shape,l,o),h=B([d.shape[l]]),f=Z({inputs:{x:d},backend:t,attrs:{shape:[-1,h]}});c.push(f);const m=uc(r.dtype),g=($,v,k,I,S)=>{const A=$.shape[0],R=$.shape[1],_=Om(R,S),D={windowSize:_,inSize:R,batchSize:A,numSegments:S},F=new aM(D,v),P=t.compileAndRun(F,[$,k],I);if(c.push(P),P.shape[1]===S)return P;const L=sx({backend:t,attrs:{start:0,stop:S,step:1,dtype:"float32"}}),O=cx({inputs:{x:L},backend:t,attrs:{reps:[R/_]}});return c.push(L),c.push(O),g(P,v,O,I,S)},y=g(f,"unsortedSegmentSum",a,m,o),x=Z({inputs:{x:y},backend:t,attrs:{shape:p}});let w=x;if(u!=null){c.push(x);const $=vc(u);w=dt({inputs:{x:w},backend:t,attrs:{perm:$}})}return c.forEach($=>t.disposeIntermediateTensorInfo($)),w}const iM={kernelName:ec,backendName:"webgl",kernelFunc:oM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cM=[PL,VL,wF,vF,kF,TF,RF,DF,OF,LF,WF,UF,qF,XF,nO,ZF,aO,lO,iO,hO,mO,yO,$O,TO,RO,AO,BO,MO,GO,jO,tF,ZO,c3,u3,n3,f3,g3,p3,b3,v3,k3,S3,E3,A3,B3,M3,F3,U3,q3,K3,Z3,nP,oP,lP,uP,dP,hP,mP,yP,bP,$P,kP,TP,_P,DP,PP,VP,UP,jP,eF,XP,YO,ZP,tL,rL,sF,cL,pL,fL,$L,xL,kL,TL,AL,WL,XL,jL,JL,tB,sB,HL,aB,iB,dB,mB,bB,SB,cF,EB,AB,OB,BB,FO,WB,UB,HB,KB,ZB,aF,eV,tV,OO,CB,rV,pV,cV,uF,gV,bV,CV,IV,RV,AV,OV,BV,MV,UV,qV,KV,QV,e4,s4,IO,kB,o4,c4,u4,p4,f4,g4,x4,w4,v4,k4,S4,E4,A4,F4,P4,B4,NB,yF,W4,G4,j4,Q4,eM,xF,nM,rM,iM,zB];for(const n of cM)oc(n);var ux={exports:{}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var Ht;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"})(Ht||(Ht={}));var dx;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(dx||(dx={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yp={};function lM(n,e){const t={tfOpName:n,category:"custom",inputs:[],attrs:[],customExecutor:e};yp[n]=t}function px(n){return yp[n]}function uM(n){delete yp[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b(n,e,t,s,r){const a=e.inputParams[n];if(a&&a.inputIndexStart!==void 0){const i=a.inputIndexStart,c=a.inputIndexEnd===0?void 0:a.inputIndexEnd===void 0?i+1:a.inputIndexEnd;if(a.type==="tensor")return pt(e.inputNames[a.inputIndexStart],t,s,r);if(a.type==="tensors")return e.inputNames.slice(i,c).map(p=>pt(p,t,s,r));const l=pt(e.inputNames.slice(i)[0],t,s,r),u=l.dataSync();return a.type==="number"?u[0]:St(l.shape,u)}const o=e.attrParams[n];return o&&o.value}function pt(n,e,t,s){const[r,a]=Nt(n);if(s!=null){const i=s.getHashTableHandleByName(r);if(i!=null)return i}const o=t.currentContextIds.find(i=>!!e[pl(r,i)]);return o!==void 0?e[pl(r,o)][a]:void 0}function dM(n,e,t){return e[pl(n,t.currentContextId)]}function wn(n,e){const[t,s,r]=Nt(n);return[pl(t,e&&e.currentContextId),s,r]}function pl(n,e){return e?`${n}-${e}`:n}function Nt(n){const e=n.split(":");if(e.length===1)return[n,0,void 0];const t=e[0],s=e.length===3?e[1]:void 0,r=Number(e[e.length-1]);return[t,r,s]}function hl(n,e,t){let s=b("pad",n,e,t);if(s==="explicit"){s=b("explicitPaddings",n,e,t);const r=[[0,0],[0,0],[0,0],[0,0]];for(let a=0;a<4;a++)r[a][0]=s[a*2],r[a][1]=s[a*2+1];return r}return s}function $n(n){return n.kept?n:An(n)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pM=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var hM=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:pM});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fM=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var mM=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:fM});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gM=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}];var yM=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:gM});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xM=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var bM=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:xM});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wM=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var $M=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:wM});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vM=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var CM=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:vM});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NM=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var kM=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:NM});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IM=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var SM=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:IM});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TM=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}];var EM=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:TM});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RM=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}];var _M=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:RM});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AM=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var DM=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:AM});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FM=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var OM=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:FM});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PM=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}];var LM=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:PM});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BM=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var VM=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:BM});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MM=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}];var WM=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:MM});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zM=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var UM=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:zM});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GM=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var HM=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:GM});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qM=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var jM=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:qM});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KM=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var XM=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:KM});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hx{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[hM,mM,yM,bM,$M,CM,kM,SM,EM,_M,DM,OM,LM,VM,WM,UM,HM,jM,XM],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(e,t={}){const s=e.node,r=[],a=[],o=[],i=s.reduce((m,g)=>(m[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?r.push(m[g.name]):g.op==="Const"?a.push(m[g.name]):(g.input==null||g.input.length===0)&&o.push(m[g.name]),m),{});let c=[];const l=[];let u={},d={};t!=null&&(u=this.mapSignatureEntries(t.inputs),d=this.mapSignatureEntries(t.outputs));const p=Object.keys(i);p.forEach(m=>{const g=i[m];g.inputNames.forEach((y,x)=>{const[w,,$]=wn(y),v=i[w];if(v.outputs!=null){const k=v.outputs.indexOf($);if(k!==-1){const I=`${w}:${k}`;g.inputNames[x]=I}}g.inputs.push(v),v.children.push(g)})}),Object.keys(d).length===0?p.forEach(m=>{const g=i[m];g.children.length===0&&l.push(g)}):Object.keys(d).forEach(m=>{const[g]=wn(m),y=i[g];y!=null&&(y.signatureKey=d[m],l.push(y))}),Object.keys(u).length>0?Object.keys(u).forEach(m=>{const[g]=wn(m),y=i[g];y&&(y.signatureKey=u[m],c.push(y))}):c=r;let h={};e.library!=null&&e.library.function!=null&&(h=e.library.function.reduce((m,g)=>(m[g.signature.name]=this.mapFunction(g),m),{}));const f={nodes:i,inputs:c,outputs:l,weights:a,placeholders:r,signature:t,functions:h};return o.length>0&&(f.initNodes=o),f}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=px(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.substr(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((r,a)=>(r[a.name]={type:a.type,inputIndexStart:a.start,inputIndexEnd:a.end},r),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((r,a)=>{const o=a.type;let i;switch(a.type){case"string":i=xp(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=xp(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":i=Ip(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=Ip(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":i=wp(e.attr,a.tfName,a.defaultValue||0),i===void 0&&!!a.tfDeprecatedName&&(i=wp(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":i=kp(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=kp(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":i=bp(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=bp(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":i=Tp(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=Tp(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":i=Np(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=Np(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":i=Sp(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=Sp(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":i=vp(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=vp(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":i=Cp(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=Cp(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":i=mx(e.attr,a.tfName,a.defaultValue),i===void 0&&!!a.tfDeprecatedName&&(i=mx(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return r[a.name]={value:i,type:o},r},{})),s}mapFunction(e){const t=e.nodeDef,s=[],r=[];let a={};t!=null&&(a=t.reduce((d,p)=>(d[p.name]=this.mapNode(p),p.op==="Const"&&r.push(d[p.name]),d),{}));const o=[],i=[];e.signature.inputArg.forEach(d=>{const[p]=wn(d.name),h={name:p,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:$p(d.type),type:"dtype"}},children:[]};h.signatureKey=d.name,o.push(h),a[p]=h}),Object.keys(a).forEach(d=>{const p=a[d];p.inputNames.forEach((h,f)=>{const[m,,g]=wn(h),y=a[m];if(y.outputs!=null){const x=y.outputs.indexOf(g);if(x!==-1){const w=`${m}:${x}`;p.inputNames[f]=w}}p.inputs.push(y),y.children.push(p)})});const l=e.ret;e.signature.outputArg.forEach(d=>{const[p,h]=wn(l[d.name]),f=a[p];f!=null&&(f.defaultOutput=h,i.push(f))});const u=this.mapArgsToSignature(e);return{nodes:a,inputs:o,outputs:i,weights:r,placeholders:s,signature:u}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function YM(n){const e=M().global;if(typeof e.atob!="undefined")return e.atob(n);if(typeof Buffer!="undefined")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function fx(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):YM(n);return e?t:t.toLowerCase()}function xp(n,e,t,s=!1){const r=n[e];return r!=null?fx(r.s,s):t}function bp(n,e,t){const s=n[e];return s?s.b:t}function wp(n,e,t){const s=n[e]||{},r=s.i!=null?s.i:s.f!=null?s.f:t;return typeof r=="number"?r:parseInt(r,10)}function $p(n){switch(typeof n=="string"&&(n=Ht[n]),n){case Ht.DT_FLOAT:return"float32";case Ht.DT_INT32:case Ht.DT_INT64:case Ht.DT_INT8:case Ht.DT_UINT8:return"int32";case Ht.DT_BOOL:return"bool";case Ht.DT_DOUBLE:return"float32";case Ht.DT_STRING:return"string";default:return null}}function mx(n,e,t){const s=n[e];return s&&s.func?s.func.name:t}function vp(n,e,t){const s=n[e];return s&&s.type?$p(s.type):t}function Cp(n,e,t){const s=n[e];return s&&s.list&&s.list.type?s.list.type.map(r=>$p(r)):t}function gx(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function Np(n,e,t){const s=n[e];return s&&s.shape?gx(s.shape):t}function kp(n,e,t){const s=n[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):t}function Ip(n,e,t,s=!1){const r=n[e];return r&&r.list&&r.list.s?r.list.s.map(a=>fx(a,s)):t}function Sp(n,e,t){const s=n[e];return s&&s.list&&s.list.shape?s.list.shape.map(r=>gx(r)):t}function Tp(n,e,t){const s=n[e];return s&&s.list&&s.list.b?s.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QM{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,a)=>(r[a]=this.getAttr(a),r),{}))}getInput(e){return pt(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return pt(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return wp(this.node.rawAttrs,e,t);if(s.s!=null)return xp(this.node.rawAttrs,e,t);if(s.b!=null)return bp(this.node.rawAttrs,e,t);if(s.shape!=null)return Np(this.node.rawAttrs,e,t);if(s.type!=null)return vp(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return kp(this.node.rawAttrs,e,t);if(s.list.s!=null)return Ip(this.node.rawAttrs,e,t);if(s.list.shape!=null)return Sp(this.node.rawAttrs,e,t);if(s.list.b!=null)return Tp(this.node.rawAttrs,e,t);if(s.list.type!=null)return Cp(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZM=(n,e,t)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[ie(b("a",n,e,t),b("b",n,e,t))];case"AddN":return[af(b("tensors",n,e,t))];case"FloorMod":case"Mod":return[jf(b("a",n,e,t),b("b",n,e,t))];case"Mul":return[Q(b("a",n,e,t),b("b",n,e,t))];case"RealDiv":case"Div":return[Te(b("a",n,e,t),b("b",n,e,t))];case"DivNoNan":return[_f(b("a",n,e,t),b("b",n,e,t))];case"FloorDiv":return[Vu(b("a",n,e,t),b("b",n,e,t))];case"Sub":return[de(b("a",n,e,t),b("b",n,e,t))];case"Minimum":return[sd(b("a",n,e,t),b("b",n,e,t))];case"Maximum":return[nd(b("a",n,e,t),b("b",n,e,t))];case"Pow":return[qs(b("a",n,e,t),b("b",n,e,t))];case"SquaredDifference":return[hd(b("a",n,e,t),b("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JM=(n,e,t)=>{switch(n.op){case"Abs":case"ComplexAbs":return[wt(b("x",n,e,t))];case"Acos":return[sf(b("x",n,e,t))];case"Acosh":return[rf(b("x",n,e,t))];case"Asin":return[df(b("x",n,e,t))];case"Asinh":return[pf(b("x",n,e,t))];case"Atan":return[hf(b("x",n,e,t))];case"Atan2":return[ff(b("x",n,e,t),b("y",n,e,t))];case"Atanh":return[mf(b("x",n,e,t))];case"Ceil":return[xf(b("x",n,e,t))];case"Complex":return[En(b("real",n,e,t),b("imag",n,e,t))];case"Cos":return[Nf(b("x",n,e,t))];case"Cosh":return[kf(b("x",n,e,t))];case"Elu":return[qu(b("x",n,e,t))];case"Erf":return[Df(b("x",n,e,t))];case"Exp":return[Ln(b("x",n,e,t))];case"Expm1":return[Ff(b("x",n,e,t))];case"Floor":return[ju(b("x",n,e,t))];case"Log":return[Gs(b("x",n,e,t))];case"Log1p":return[Yu(b("x",n,e,t))];case"Imag":return[bc(b("x",n,e,t))];case"Neg":return[mn(b("x",n,e,t))];case"Reciprocal":return[sm(b("x",n,e,t))];case"Real":return[Ma(b("x",n,e,t))];case"Relu":return[Wa(b("x",n,e,t))];case"Round":return[dd(b("x",n,e,t))];case"Selu":return[am(b("x",n,e,t))];case"Sigmoid":return[hs(b("x",n,e,t))];case"Sin":return[cm(b("x",n,e,t))];case"Sign":return[im(b("x",n,e,t))];case"Sinh":return[lm(b("x",n,e,t))];case"Softplus":return[Qu(b("x",n,e,t))];case"Sqrt":return[en(b("x",n,e,t))];case"Square":return[Lt(b("x",n,e,t))];case"Tanh":return[gc(b("x",n,e,t))];case"Tan":return[hm(b("x",n,e,t))];case"ClipByValue":return[bf(b("x",n,e,t),b("clipValueMin",n,e,t),b("clipValueMax",n,e,t))];case"Relu6":return[ud(b("x",n,e,t))];case"Rsqrt":return[rm(pt(n.inputNames[0],e,t))];case"Prod":return[id(b("x",n,e,t),b("axes",n,e,t))];case"LeakyRelu":return[Xu(b("x",n,e,t),b("alpha",n,e,t))];case"Prelu":return[od(b("x",n,e,t),b("alpha",n,e,t))];case"IsNan":return[Pf(pt(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vt(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){C(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let s=0;s<n.length;s++){const r=n[s],a=e[s];C(r<0||a<0||r===a,()=>t+` Shapes ${n} and ${e} must match`)}}}function yx(n){return!(typeof n=="number"||n.some(e=>e<0))}function io(n,e,t){let s=Ep(n,t);const r=!yx(s);if(r&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&e.forEach(a=>{s=Ep(a.shape,s)}),!yx(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function Ep(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let s=0;s<n.length;++s){const r=n[s],a=e[s];if(r>=0&&a>=0&&r!==a)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[s]=r>=0?r:a}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eW{constructor(e,t,s,r,a,o,i){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=o,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=pe(0),Zt(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Vt(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,Zt(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,r)=>this.write(s,t[r]))}gather(e,t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return Qt([],[0].concat(this.elementShape));const s=this.readMany(e);return Vt(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),tn(s,0)}concat(e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Qt([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const s=this.readMany(t);return Vt(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),rt(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,Wn(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const r=e.map(c=>(s+=c,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const a=s===0?0:t.size/s,o=[];ce(()=>{t=W(t,[1,s,a]);for(let c=0;c<e.length;++c){const l=c===0?0:r[c-1],u=[0,l,0],d=[1,e[c],a];o[c]=W(Ce(t,u,d),this.elementShape)}return o});const i=[];for(let c=0;c<e.length;c++)i[c]=c;this.writeMany(i,o)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pr{constructor(e,t,s,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e!=null&&e.forEach(a=>{if(s!==a.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${a.dtype}`);Vt(t,a.shape,"TensorList shape mismatch: "),Zt(a)}),this.idTensor=pe(0),this.maxNumElements=r,Zt(this.idTensor)}get id(){return this.idTensor.id}copy(){return new pr([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);Vt(e,this.elementShape,"TensorList shape mismatch: ");const r=io(this.elementShape,this.tensors,e);return ce(()=>{const a=this.tensors.map(o=>W(o,r));return tn(a,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=io(this.elementShape,this.tensors,e),r=this.tensors.pop();return Vt(r.shape,e,"TensorList shape mismatch: "),W(r,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Vt(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Zt(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Vt(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=io(this.elementShape,this.tensors,t);return W(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Vt(this.elementShape,t.shape,"TensorList shape mismatch: "),Zt(t),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Vt(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=io(this.elementShape,this.tensors,s);return e.length===0?Qt([],[0].concat(r)):ce(()=>{const a=e.map(o=>W(this.tensors[o],r));return tn(a,0)})}concat(e,t){if(!!e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Vt(this.elementShape,t,"TensorList shape mismatch: ");const s=io(this.elementShape,this.tensors,t);return this.size()===0?Qt([],[0].concat(s)):ce(()=>{const r=this.tensors.map(a=>W(a,s));return rt(r,0)})}}function tW(n,e,t){const s=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const r=n.shape.slice(1);Vt(r,e,"TensorList shape mismatch: ");const a=Wn(n);return new pr(a,e,s)}function nW(n,e,t){return new pr([],n,e,t)}function sW(n,e,t,s){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const a=new pr([],t,n.dtype,s),o=Wn(n,0);return e.forEach((i,c)=>{a.setItem(i,o[c])}),a}function rW(n,e,t){let s=0;const r=e.map(u=>(s+=u,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);const a=n.shape.slice(1),o=Ep(a,t),i=s===0?0:n.size/s,c=ce(()=>{const u=[];n=W(n,[1,s,i]);for(let d=0;d<e.length;++d){const p=d===0?0:r[d-1],h=[0,p,0],f=[1,e[d],i];u[d]=W(Ce(n,h,f),o)}return n.dispose(),u}),l=new pr([],t,n.dtype,e.length);for(let u=0;u<c.length;u++)l.setItem(u,c[u]);return l}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aW=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const s=b("thenBranch",n,e,t),r=b("elseBranch",n,e,t),a=b("cond",n,e,t),o=b("args",n,e,t);return(await a.data())[0]?t.functionMap[s].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap):t.functionMap[r].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=b("body",n,e,t),r=b("cond",n,e,t),a=b("args",n,e,t),o=await t.functionMap[r].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap),i=a.map(u=>u.id);let c=await o[0].data();o.forEach(u=>{!u.kept&&i.indexOf(u.id)===-1&&u.dispose()});let l=a;for(;c[0];){const u=l;l=await t.functionMap[s].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);const d=l.map(h=>h.id);u.forEach(h=>{!h.kept&&i.indexOf(h.id)===-1&&d.indexOf(h.id)===-1&&h.dispose()});const p=await t.functionMap[r].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);c=await p[0].data(),p.forEach(h=>{!h.kept&&i.indexOf(h.id)===-1&&d.indexOf(h.id)===-1&&h.dispose()})}return l}case"LoopCond":{const s=b("pred",n,e,t);return[$n(s)]}case"Switch":{const s=b("pred",n,e,t);let r=b("data",n,e,t);return r.kept||(r=$n(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=n.inputNames.find(r=>pt(r,e,t)!==void 0);if(s){const r=pt(s,e,t);return[$n(r)]}return}case"Enter":{const s=b("frameName",n,e,t),r=b("tensor",n,e,t);return t.enterFrame(s),[$n(r)]}case"Exit":{const s=b("tensor",n,e,t);return t.exitFrame(),[$n(s)]}case"NextIteration":{const s=b("tensor",n,e,t);return t.nextIteration(),[$n(s)]}case"TensorArrayV3":{const s=b("size",n,e,t),r=b("dtype",n,e,t),a=b("elementShape",n,e,t),o=b("dynamicSize",n,e,t),i=b("clearAfterRead",n,e,t),c=b("identicalElementShapes",n,e,t),l=b("name",n,e,t),u=new eW(l,r,s,a,c,o,i);return t.addTensorArray(u),[u.idTensor,pe(1)]}case"TensorArrayWriteV3":{const s=b("tensorArrayId",n,e,t),r=b("index",n,e,t),a=b("tensor",n,e,t),o=t.getTensorArray(s.id);return o.write(r,a),[o.idTensor]}case"TensorArrayReadV3":{const s=b("tensorArrayId",n,e,t),r=b("index",n,e,t);return[t.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=b("tensorArrayId",n,e,t),r=b("indices",n,e,t),a=b("dtype",n,e,t);return[t.getTensorArray(s.id).gather(r,a)]}case"TensorArrayScatterV3":{const s=b("tensorArrayId",n,e,t),r=b("indices",n,e,t),a=b("tensor",n,e,t),o=t.getTensorArray(s.id);return o.scatter(r,a),[o.idTensor]}case"TensorArrayConcatV3":{const s=b("tensorArrayId",n,e,t),r=t.getTensorArray(s.id),a=b("dtype",n,e,t);return[r.concat(a)]}case"TensorArraySplitV3":{const s=b("tensorArrayId",n,e,t),r=b("tensor",n,e,t),a=b("lengths",n,e,t),o=t.getTensorArray(s.id);return o.split(a,r),[o.idTensor]}case"TensorArraySizeV3":{const s=b("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return[pe(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=b("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=b("tensorListId",n,e,t),r=b("index",n,e,t),a=b("tensor",n,e,t),o=t.getTensorList(s.id);return o.setItem(r,a),[o.idTensor]}case"TensorListGetItem":{const s=b("tensorListId",n,e,t),r=b("index",n,e,t),a=b("elementShape",n,e,t),o=b("elementDType",n,e,t);return[t.getTensorList(s.id).getItem(r,a,o)]}case"TensorListScatterV2":case"TensorListScatter":{const s=b("indices",n,e,t),r=b("tensor",n,e,t),a=b("elementShape",n,e,t),o=b("numElements",n,e,t),i=sW(r,s,a,o);return t.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=b("elementShape",n,e,t),r=b("elementDType",n,e,t);let a;n.op==="TensorListReserve"?a="numElements":a="maxNumElements";const o=b(a,n,e,t),i=nW(s,r,o);return t.addTensorList(i),[i.idTensor]}case"TensorListGather":{const s=b("tensorListId",n,e,t),r=b("indices",n,e,t),a=b("elementShape",n,e,t),o=b("elementDType",n,e,t);return[t.getTensorList(s.id).gather(r,o,a)]}case"TensorListStack":{const s=b("tensorListId",n,e,t),r=b("elementShape",n,e,t),a=b("elementDType",n,e,t),o=b("numElements",n,e,t);return[t.getTensorList(s.id).stack(r,a,o)]}case"TensorListFromTensor":{const s=b("tensor",n,e,t),r=b("elementShape",n,e,t),a=b("elementDType",n,e,t),o=tW(s,r,a);return t.addTensorList(o),[o.idTensor]}case"TensorListConcat":{const s=b("tensorListId",n,e,t),r=t.getTensorList(s.id),a=b("dtype",n,e,t),o=b("elementShape",n,e,t);return[r.concat(a,o)]}case"TensorListPushBack":{const s=b("tensorListId",n,e,t),r=b("tensor",n,e,t),a=t.getTensorList(s.id);return a.pushBack(r),[a.idTensor]}case"TensorListPopBack":{const s=b("tensorListId",n,e,t),r=b("elementShape",n,e,t),a=b("elementDType",n,e,t);return[t.getTensorList(s.id).popBack(r,a)]}case"TensorListSplit":{const s=b("tensor",n,e,t),r=b("elementShape",n,e,t),a=b("lengths",n,e,t),o=rW(s,a,r);return t.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xx(n,e,t){const[s,r]=b("fusedOps",n,e,t),a=s==="biasadd",o=!a,i=r==="prelu",c=s==="fusedbatchnorm",l=b("numArgs",n,e,t);if(a){if(i&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&a&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(c)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const u=b("strides",n,e,t),d=hl(n,e,t),p=b("dataFormat",n,e,t).toUpperCase(),h=b("dilations",n,e,t);let[f,m]=b("args",n,e,t);o&&(m=f,f=void 0);const g=b("leakyreluAlpha",n,e,t);return{stride:u,pad:d,dataFormat:p,dilations:h,biasArg:f,preluArg:m,activationFunc:r,leakyreluAlpha:g}}const oW=(n,e,t)=>{switch(n.op){case"Conv1D":{const s=b("stride",n,e,t),r=b("pad",n,e,t),a=b("dataFormat",n,e,t).toUpperCase(),o=b("dilation",n,e,t);return[wf(b("x",n,e,t),b("filter",n,e,t),s,r,a,o)]}case"Conv2D":{const s=b("strides",n,e,t),r=hl(n,e,t),a=b("dataFormat",n,e,t).toUpperCase(),o=b("dilations",n,e,t);return[Oa(b("x",n,e,t),b("filter",n,e,t),[s[1],s[2]],r,a,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:s,pad:r,dataFormat:a,dilations:o,biasArg:i,preluArg:c,activationFunc:l,leakyreluAlpha:u}=xx(n,e,t);return[wm({x:b("x",n,e,t),filter:b("filter",n,e,t),strides:[s[1],s[2]],pad:r,dataFormat:a,dilations:[o[1],o[2]],bias:i,activation:l,preluActivationWeights:c,leakyreluAlpha:u})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:r,dataFormat:a,dilations:o,biasArg:i,preluArg:c,activationFunc:l,leakyreluAlpha:u}=xx(n,e,t);return[$m({x:b("x",n,e,t),filter:b("filter",n,e,t),strides:[s[1],s[2]],pad:r,dataFormat:a,dilations:[o[1],o[2]],bias:i,activation:l,preluActivationWeights:c,leakyreluAlpha:u})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=b("outputShape",n,e,t),r=b("strides",n,e,t),a=hl(n,e,t);return[vf(b("x",n,e,t),b("filter",n,e,t),s,[r[1],r[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=b("strides",n,e,t),r=hl(n,e,t),a=b("dilations",n,e,t),o=b("dataFormat",n,e,t).toUpperCase();return[yc(b("input",n,e,t),b("filter",n,e,t),[s[1],s[2]],r,o,[a[1],a[2]])]}case"Conv3D":{const s=b("strides",n,e,t),r=b("pad",n,e,t),a=b("dataFormat",n,e,t).toUpperCase(),o=b("dilations",n,e,t);return[Cf(b("x",n,e,t),b("filter",n,e,t),[s[1],s[2],s[3]],r,a,[o[1],o[2],o[3]])]}case"AvgPool":{const s=b("strides",n,e,t),r=b("pad",n,e,t),a=b("kernelSize",n,e,t);return[zu(b("x",n,e,t),[a[1],a[2]],[s[1],s[2]],r)]}case"MaxPool":{const s=b("strides",n,e,t),r=b("pad",n,e,t),a=b("kernelSize",n,e,t);return[td(b("x",n,e,t),[a[1],a[2]],[s[1],s[2]],r)]}case"MaxPoolWithArgmax":{const s=b("strides",n,e,t),r=b("pad",n,e,t),a=b("kernelSize",n,e,t),o=b("includeBatchInIndex",n,e,t),{result:i,indexes:c}=Hf(b("x",n,e,t),[a[1],a[2]],[s[1],s[2]],r,o);return[i,c]}case"AvgPool3D":{const s=b("strides",n,e,t),r=b("pad",n,e,t),a=b("kernelSize",n,e,t);return[gf(b("x",n,e,t),[a[1],a[2],a[3]],[s[1],s[2],s[3]],r)]}case"MaxPool3D":{const s=b("strides",n,e,t),r=b("pad",n,e,t),a=b("kernelSize",n,e,t);return[Gf(b("x",n,e,t),[a[1],a[2],a[3]],[s[1],s[2],s[3]],r)]}case"Dilation2D":{const s=b("strides",n,e,t),r=b("pad",n,e,t),a=b("dilations",n,e,t),o=s[1],i=s[2],c=a[1],l=a[2];return[Ef(b("x",n,e,t),b("filter",n,e,t),[o,i],r,[c,l],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iW=(n,e,t)=>{switch(n.op){case"Fill":{const s=b("shape",n,e,t),r=b("dtype",n,e,t),a=b("value",n,e,t);return[Pa(s,a,r)]}case"LinSpace":{const s=b("start",n,e,t),r=b("stop",n,e,t),a=b("num",n,e,t);return[Bf(s,r,a)]}case"Multinomial":{const s=b("logits",n,e,t),r=b("numSamples",n,e,t),a=b("seed",n,e,t);return[Kf(s,r,a)]}case"OneHot":{const s=b("indices",n,e,t),r=b("depth",n,e,t),a=b("onValue",n,e,t),o=b("offValue",n,e,t);return[hc(s,r,a,o)]}case"Ones":return[Mn(b("shape",n,e,t),b("dtype",n,e,t))];case"OnesLike":return[Xf(b("x",n,e,t))];case"RandomUniform":return[ld(b("shape",n,e,t),b("minval",n,e,t),b("maxval",n,e,t),b("dtype",n,e,t))];case"Range":{const s=b("start",n,e,t),r=b("stop",n,e,t),a=b("step",n,e,t);return[js(s,r,a,b("dtype",n,e,t))]}case"TruncatedNormal":{const s=b("shape",n,e,t),r=b("mean",n,e,t),a=b("stdDev",n,e,t),o=b("seed",n,e,t);return[mm(s,r,a,b("dtype",n,e,t),o)]}case"Zeros":return[Vn(b("shape",n,e,t),b("dtype",n,e,t))];case"ZerosLike":return[$t(b("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rp(n,e,t){const s=b("boxes",n,e,t),r=b("scores",n,e,t),a=b("maxOutputSize",n,e,t),o=b("iouThreshold",n,e,t),i=b("scoreThreshold",n,e,t),c=b("softNmsSigma",n,e,t);return{boxes:s,scores:r,maxOutputSize:a,iouThreshold:o,scoreThreshold:i,softNmsSigma:c}}const cW=async(n,e,t)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:s,scores:r,maxOutputSize:a,iouThreshold:o,scoreThreshold:i,softNmsSigma:c}=Rp(n,e,t),l=await ys.nonMaxSuppressionWithScoreAsync(s,r,a,o,i,c);return[l.selectedIndices,l.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:s,scores:r,maxOutputSize:a,iouThreshold:o,scoreThreshold:i}=Rp(n,e,t),c=b("padToMaxOutputSize",n,e,t),l=await ys.nonMaxSuppressionPaddedAsync(s,r,a,o,i,c);return[l.selectedIndices,l.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:s,scores:r,maxOutputSize:a,iouThreshold:o,scoreThreshold:i}=Rp(n,e,t);return[await ys.nonMaxSuppressionAsync(s,r,a,o,i)]}case"Where":{const s=ve(b("condition",n,e,t),"bool"),r=[await md(s)];return s.dispose(),r}case"ListDiff":return om(b("x",n,e,t),b("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lW=(n,e,t)=>{switch(n.op){case"TopKV2":{const s=b("x",n,e,t),r=b("k",n,e,t),a=b("sorted",n,e,t),o=fm(s,r,a);return[o.values,o.indices]}case"Unique":{const s=b("x",n,e,t),r=fd(s);return[r.values,r.indices]}case"UniqueV2":{const s=b("x",n,e,t),r=b("axis",n,e,t),a=fd(s,r);return[a.values,a.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uW=(n,e,t)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const s=b("default",n,e,t);return[pt(n.name,e,t)||s];case"Placeholder":return[pt(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const l=b("x",n,e,t);return[$n(l)]}case"IdentityN":return b("x",n,e,t).map(l=>$n(l));case"Snapshot":const r=b("x",n,e,t);return[$n(r)];case"Shape":return[Tt(b("x",n,e,t).shape,"int32")];case"ShapeN":return b("x",n,e,t).map(l=>Tt(l.shape));case"Size":return[pe(b("x",n,e,t).size,"int32")];case"Rank":return[pe(b("x",n,e,t).rank,"int32")];case"NoOp":return[pe(1)];case"Print":const a=b("x",n,e,t),o=b("data",n,e,t),i=b("message",n,e,t),c=b("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(i);for(let l=0;l<o.length;l++)console.log(Array.prototype.slice.call(o[l].dataSync()).slice(0,c));return[a];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dW{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=pe(0),this.tensorMap=new Map,Zt(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return pe(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),ce(()=>{const r=Wn(t),a=s.length,o=r.length;C(a===o,()=>`The number of elements doesn't match, keys has ${a} elements, the values has ${o} elements.`);for(let i=0;i<a;i++){const c=s[i],l=r[i];Zt(l),this.tensorMap.set(c,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return ce(()=>{const r=[];for(let a=0;a<s.length;a++){const o=s[a],i=this.findWithDefault(o,t);r.push(i)}return tn(r)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return s!=null?s:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pW=async(n,e,t,s)=>{switch(n.op){case"HashTable":case"HashTableV2":{const r=b("keyDType",n,e,t),a=b("valueDType",n,e,t),o=new dW(r,a);return s.addHashTable(n.name,o),[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const r=b("tableHandle",n,e,t,s),a=b("keys",n,e,t),o=b("values",n,e,t);return[await s.getHashTableById(r.id).import(a,o)]}case"LookupTableFind":case"LookupTableFindV2":{const r=b("tableHandle",n,e,t,s),a=b("keys",n,e,t),o=b("defaultValue",n,e,t);return[await s.getHashTableById(r.id).find(a,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=b("tableHandle",n,e,t,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hW=(n,e,t)=>{switch(n.op){case"ResizeBilinear":{const s=b("images",n,e,t),r=b("size",n,e,t),a=b("alignCorners",n,e,t),o=b("halfPixelCenters",n,e,t);return[ys.resizeBilinear(s,[r[0],r[1]],a,o)]}case"ResizeNearestNeighbor":{const s=b("images",n,e,t),r=b("size",n,e,t),a=b("alignCorners",n,e,t),o=b("halfPixelCenters",n,e,t);return[ys.resizeNearestNeighbor(s,[r[0],r[1]],a,o)]}case"CropAndResize":{const s=b("image",n,e,t),r=b("boxes",n,e,t),a=b("boxInd",n,e,t),o=b("cropSize",n,e,t),i=b("method",n,e,t),c=b("extrapolationValue",n,e,t);return[ys.cropAndResize(s,r,a,o,i,c)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fW=(n,e,t)=>{switch(n.op){case"Equal":return[Hu(b("a",n,e,t),b("b",n,e,t))];case"NotEqual":return[rd(b("a",n,e,t),b("b",n,e,t))];case"Greater":return[La(b("a",n,e,t),b("b",n,e,t))];case"GreaterEqual":return[Ku(b("a",n,e,t),b("b",n,e,t))];case"Less":return[Lf(b("a",n,e,t),b("b",n,e,t))];case"LessEqual":return[wc(b("a",n,e,t),b("b",n,e,t))];case"LogicalAnd":return[Ba(b("a",n,e,t),b("b",n,e,t))];case"LogicalNot":return[Ju(b("a",n,e,t))];case"LogicalOr":return[ed(b("a",n,e,t),b("b",n,e,t))];case"Select":case"SelectV2":return[fs(b("condition",n,e,t),b("a",n,e,t),b("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mW=(n,e,t)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[xe(b("a",n,e,t),b("b",n,e,t),b("transposeA",n,e,t),b("transposeB",n,e,t))];case"Einsum":return[Af(b("equation",n,e,t),...b("tensors",n,e,t))];case"Transpose":return[_a(b("x",n,e,t),b("perm",n,e,t))];case"_FusedMatMul":const[s,r]=b("fusedOps",n,e,t),a=s==="biasadd",o=r==="prelu",i=b("numArgs",n,e,t),c=b("leakyreluAlpha",n,e,t);if(a){if(o&&i!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&i!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[l,u]=b("args",n,e,t);return[vm({a:b("a",n,e,t),b:b("b",n,e,t),transposeA:b("transposeA",n,e,t),transposeB:b("transposeB",n,e,t),bias:l,activation:r,preluActivationWeights:u,leakyreluAlpha:c})];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gW=(n,e,t)=>{switch(n.op){case"FusedBatchNorm":case"FusedBatchNormV2":return[Ws(b("x",n,e,t),b("mean",n,e,t),b("variance",n,e,t),b("offset",n,e,t),b("scale",n,e,t),b("epsilon",n,e,t))];case"FusedBatchNormV3":return[Ws(b("x",n,e,t),b("mean",n,e,t),b("variance",n,e,t),b("offset",n,e,t),b("scale",n,e,t),b("epsilon",n,e,t))];case"LRN":return[Vf(b("x",n,e,t),b("radius",n,e,t),b("bias",n,e,t),b("alpha",n,e,t),b("beta",n,e,t))];case"Softmax":return[um(b("x",n,e,t))];case"LogSoftmax":return[Wf(b("x",n,e,t))];case"SparseToDense":return[yd(b("sparseIndices",n,e,t),b("outputShape",n,e,t),b("sparseValues",n,e,t),b("defaultValue",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yW=(n,e,t)=>{switch(n.op){case"Max":{const o=b("axis",n,e,t),i=b("keepDims",n,e,t);return[ms(b("x",n,e,t),o,i)]}case"Mean":{const o=b("axis",n,e,t),i=b("keepDims",n,e,t);return[Va(b("x",n,e,t),o,i)]}case"Min":{const o=b("axis",n,e,t),i=b("keepDims",n,e,t);return[Cc(b("x",n,e,t),o,i)]}case"Sum":{const o=b("axis",n,e,t),i=b("keepDims",n,e,t);return[Ee(b("x",n,e,t),o,i)]}case"All":{const o=b("axis",n,e,t),i=b("keepDims",n,e,t);return[of(b("x",n,e,t),o,i)]}case"Any":{const o=b("axis",n,e,t),i=b("keepDims",n,e,t);return[cf(b("x",n,e,t),o,i)]}case"ArgMax":{const o=b("axis",n,e,t);return[lf(b("x",n,e,t),o)]}case"ArgMin":{const o=b("axis",n,e,t);return[uf(b("x",n,e,t),o)]}case"Prod":{const o=b("axis",n,e,t),i=b("keepDims",n,e,t);return[id(b("x",n,e,t),o,i)]}case"Cumsum":{const o=b("axis",n,e,t),i=b("exclusive",n,e,t),c=b("reverse",n,e,t);return[If(b("x",n,e,t),o,i,c)]}case"Bincount":const s=b("x",n,e,t),r=b("weights",n,e,t),a=b("size",n,e,t);return[Gu(s,r,a)];case"DenseBincount":{const o=b("x",n,e,t),i=b("weights",n,e,t),c=b("size",n,e,t),l=b("binaryOutput",n,e,t);return[Sf(o,i,c,l)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xW=(n,e,t)=>{switch(n.op){case"ConcatV2":case"Concat":{const s=b("n",n,e,t),r=b("axis",n,e,t);let a=b("tensors",n,e,t);return a=a.slice(0,s),[rt(a,r)]}case"Gather":{const s=b("x",n,e,t),r=b("indices",n,e,t);return[xc(s,ve(r,"int32"),0)]}case"GatherV2":{const s=b("axis",n,e,t),r=b("batchDims",n,e,t),a=b("x",n,e,t),o=b("indices",n,e,t);return[xc(a,ve(o,"int32"),s,r)]}case"Reverse":{const s=b("dims",n,e,t),r=[];for(let o=0;o<s.length;o++)s[o]&&r.push(o);const a=b("x",n,e,t);return[gn(a,r)]}case"ReverseV2":{const s=b("axis",n,e,t),r=b("x",n,e,t);return[gn(r,s)]}case"Slice":{const s=b("begin",n,e,t),r=b("size",n,e,t);return[Ce(b("x",n,e,t),s,r)]}case"StridedSlice":{const s=b("begin",n,e,t),r=b("end",n,e,t),a=b("strides",n,e,t),o=b("beginMask",n,e,t),i=b("endMask",n,e,t),c=b("ellipsisMask",n,e,t),l=b("newAxisMask",n,e,t),u=b("shrinkAxisMask",n,e,t),d=b("x",n,e,t);return[pm(d,s,r,a,o,i,c,l,u)]}case"Pack":return ce(()=>{const s=b("axis",n,e,t),r=b("tensors",n,e,t),a=r[0].shape,o=Xs(r[0]).shape,i=r.map(c=>{const l=$e(c.shape,a);if(!l&&!$e(Xs(c).shape,o))throw new Error("the input tensors shape does not match");return l?c:W(c,a)});return[tn(i,s)]});case"Unpack":{const s=b("axis",n,e,t),r=b("tensor",n,e,t);return Wn(r,s)}case"Tile":{const s=b("reps",n,e,t);return[Us(b("x",n,e,t),s)]}case"Split":case"SplitV":{const s=b("axis",n,e,t),r=b("numOrSizeSplits",n,e,t),a=b("x",n,e,t);return Ks(a,r,s)}case"ScatterNd":{const s=b("indices",n,e,t),r=b("values",n,e,t),a=b("shape",n,e,t);return[ym(s,r,a)]}case"GatherNd":{const s=b("x",n,e,t),r=b("indices",n,e,t);return[xm(s,r)]}case"SparseToDense":{const s=b("sparseIndices",n,e,t),r=b("outputShape",n,e,t),a=b("sparseValues",n,e,t),o=b("defaultValue",n,e,t);return[yd(s,a,r,a.dtype===o.dtype?o:ve(o,a.dtype))]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bW=(n,e,t)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:r,emptyRowIndicator:a,reverseIndexMap:o}=Ga.sparseFillEmptyRows(b("indices",n,e,t),b("values",n,e,t),b("denseShape",n,e,t),b("defaultValue",n,e,t));return[s,r,a,o]}case"SparseReshape":{const{outputIndices:s,outputShape:r}=Ga.sparseReshape(b("inputIndices",n,e,t),b("inputShape",n,e,t),b("newShape",n,e,t));return[s,r]}case"SparseSegmentMean":return[Ga.sparseSegmentMean(b("data",n,e,t),b("indices",n,e,t),b("segmentIds",n,e,t))];case"SparseSegmentSum":return[Ga.sparseSegmentSum(b("data",n,e,t),b("indices",n,e,t),b("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wW=(n,e,t)=>{switch(n.op){case"FFT":return[kc(b("x",n,e,t))];case"IFFT":return[za(b("x",n,e,t))];case"RFFT":return[Ic(b("x",n,e,t))];case"IRFFT":return[pd(b("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $W=(n,e,t)=>{switch(n.op){case"StringNGrams":{const{nGrams:s,nGramsSplits:r}=Oc.stringNGrams(b("data",n,e,t),b("dataSplits",n,e,t),b("separator",n,e,t),b("nGramWidths",n,e,t),b("leftPad",n,e,t),b("rightPad",n,e,t),b("padWidth",n,e,t),b("preserveShortSequences",n,e,t));return[s,r]}case"StringSplit":{const{indices:s,values:r,shape:a}=Oc.stringSplit(b("input",n,e,t),b("delimiter",n,e,t),b("skipEmpty",n,e,t));return[s,r,a]}case"StringToHashBucketFast":return[Oc.stringToHashBucketFast(b("input",n,e,t),b("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vW=(n,e,t)=>{switch(n.op){case"Cast":return[ve(b("x",n,e,t),b("dtype",n,e,t))];case"ExpandDims":{const s=b("axis",n,e,t);return[Bn(b("x",n,e,t),s)]}case"Squeeze":{const s=b("axis",n,e,t);return[Xs(b("x",n,e,t),s)]}case"Reshape":return[W(b("x",n,e,t),b("shape",n,e,t))];case"MirrorPad":return[qf(b("x",n,e,t),b("padding",n,e,t),b("mode",n,e,t))];case"PadV2":case"Pad":return[Hs(b("x",n,e,t),b("padding",n,e,t),b("constantValue",n,e,t))];case"SpaceToBatchND":{const s=b("blockShape",n,e,t),r=b("paddings",n,e,t);return[ad(b("x",n,e,t),s,r)]}case"BatchToSpaceND":{const s=b("blockShape",n,e,t),r=b("crops",n,e,t);return[Uu(b("x",n,e,t),s,r)]}case"DepthToSpace":{const s=b("blockSize",n,e,t),r=b("dataFormat",n,e,t).toUpperCase();return[Tf(b("x",n,e,t),s,r)]}case"BroadcastTo":return[Fa(b("x",n,e,t),b("shape",n,e,t))];case"BroadcastArgs":return[yf(b("s0",n,e,t),b("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bx(n,e,t,s){const r=((a,o,i)=>{switch(a.category){case"arithmetic":return ce(()=>ZM(a,o,i));case"basic_math":return ce(()=>JM(a,o,i));case"control":return aW(a,o,i);case"convolution":return ce(()=>oW(a,o,i));case"creation":return ce(()=>iW(a,o,i));case"dynamic":return cW(a,o,i);case"evaluation":return ce(()=>lW(a,o,i));case"image":return ce(()=>hW(a,o,i));case"graph":return ce(()=>uW(a,o,i));case"logical":return ce(()=>fW(a,o,i));case"matrices":return ce(()=>mW(a,o,i));case"normalization":return ce(()=>gW(a,o,i));case"reduction":return ce(()=>yW(a,o,i));case"slice_join":return ce(()=>xW(a,o,i));case"sparse":return ce(()=>bW(a,o,i));case"spectral":return ce(()=>wW(a,o,i));case"string":return ce(()=>$W(a,o,i));case"transformation":return ce(()=>vW(a,o,i));case"hash_table":return pW(a,o,i,s);case"custom":const c=px(a.op);if(c&&c.customExecutor)return c.customExecutor(new QM(a,o,i));throw TypeError(`Custom op ${a.op} is not registered.`);default:throw TypeError(`Unknown op '${a.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return Rs(r)?r.then(a=>[].concat(a)):[].concat(r)}class wx{constructor(e={},t={},s={},r={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $x(n,e,t,s){const r=new Set,a=[];let o=null,i=null;const c=new Set,l=Object.keys(n).map(p=>Nt(p)[0]);let u=[];s!=null&&(u=s.map(p=>Nt(p.name)[0]));const d=[...e];for(;d.length>0;){const p=d.pop();if((vx(p)||SW(p)||TW(p))&&o==null&&(o=p,i=o.children.map(h=>h.name).filter(h=>r.has(h))),r.add(p.name),t[p.name]==null&&l.indexOf(p.name)===-1&&u.indexOf(p.name)===-1){if(p.inputs.length===0){a.push(p.name);continue}p.inputs.forEach(h=>{c.has(h.name)||(c.add(h.name),d.push(h))})}}return{inputs:n,outputs:e,usedNodes:r,missingInputs:a,dynamicNode:o,syncInputs:i}}function CW(n,e,t){const{usedNodes:s,inputs:r}=t,a=[],o=Object.keys(r).map(u=>Nt(u)[0]).map(u=>n.nodes[u]),i=n.initNodes;o.forEach(u=>{s.has(u.name)&&a.push(u)}),n.weights.forEach(u=>{s.has(u.name)&&a.push(u)}),i!=null&&i.forEach(u=>{s.has(u.name)&&a.push(u)});const c=new Set,l=[];for(;a.length>0;){const u=a.pop();c.add(u.name),e[u.name]||l.push(u),u.children.forEach(d=>{!c.has(d.name)&&s.has(d.name)&&d.inputs.every(p=>c.has(p.name))&&a.push(d)})}return l}const NW=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],kW=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],IW=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function vx(n){return NW.indexOf(n.op)>=0}function SW(n){return kW.indexOf(n.op)>=0}function TW(n){return IW.indexOf(n.op)>=0}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fl{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new fl(e.functions[s],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(r=>r.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){const s=e.map(a=>a.name).sort(),r=t.map(a=>a.name).sort();return s.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(e,t){const s=$x(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:a,syncInputs:o}=s;if(a!=null)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(r.length>0){const i=t.map(l=>l.name),c=Object.keys(e);throw new Error(`Cannot compute the outputs [${i}] from the provided inputs [${c}]. Missing the following inputs: [${r}]`)}return CW(this.graph,this.weightMap,s)}execute(e,t){e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=s.map(d=>this.graph.nodes[Nt(d)[0]]),a=t.map(d=>Nt(d)[0]);let o=a.map(d=>this.graph.nodes[d]);o.length===0&&(o=this._outputs);const i=this.getCompilationKey(r,o);let c=this.compiledMap.get(i);c==null&&(c=this.compile(e,o),this.compiledMap.set(i,c));const l={},u={};return ce(()=>{const d=new wx(this.weightMap,l,u,this.functionExecutorMap),p=Object.assign({},this.weightMap);Object.keys(e).forEach(m=>{const[g,y]=Nt(m),x=[];x[y]=e[m],p[g]=x});const h=this.getFrozenTensorIds(p),f={};for(let m=0;m<c.length;m++){const g=c[m];if(!p[g.name]){const y=bx(g,p,d,this._resourceManager);if(Rs(y))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);p[g.name]=y,this.checkTensorForDisposal(g.name,g,p,d,h,a,f)}}return this.parent==null&&d.dispose(h),t.map(m=>pt(m,p,d))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(r=>r.id)));return new Set(t)}checkTensorForDisposal(e,t,s,r,a,o,i){t.category==="control"||o.indexOf(e)!==-1||(s[e].forEach(c=>{c!=null&&(i[c.id]=(i[c.id]||0)+t.children.length)}),t.inputs.forEach(c=>{if(c.category!=="control"){const l=dM(c.name,s,r);l!=null&&l.forEach(u=>{if(u&&!u.kept&&!a.has(u.id)){const d=i[u.id];d===1?(u.dispose(),delete i[u.id]):d!=null&&i[u.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}async _executeAsync(e,t,s=!1,r={},a={}){s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));const o=new wx(this.weightMap,r,a,this.functionExecutorMap),i=await this.executeWithControlFlow(e,o,t,s),c=t.map(p=>pt(p,i,o)),l=c.map(p=>p.id),u=Object.keys(e).map(p=>e[p].id),d=new Set([...l,...u,...this.weightIds]);return Object.keys(i).forEach(p=>{i[p].forEach(f=>{f&&!f.kept&&!f.isDisposed&&!d.has(f.id)&&f.dispose()})}),this.parent==null&&o.dispose(d),c}async executeFunctionAsync(e,t,s){const r=e.reduce((a,o,i)=>(a[this.inputs[i].name]=o,a),{});return this._executeAsync(r,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,r){const a=Object.keys(e),o=a.map(w=>this.graph.nodes[Nt(w)[0]]),i=s.map(w=>Nt(w)[0]);let c=i.map(w=>this.graph.nodes[w]);c.length===0&&(c=this._outputs);const{usedNodes:l,missingInputs:u,dynamicNode:d,syncInputs:p}=$x(e,c,this.weightMap,this._initNodes),h=[...o,...this.graph.weights,...this._initNodes||[]].map(w=>({node:w,contexts:t.currentContext})),f=Object.assign({},this.weightMap);Object.keys(e).forEach(w=>{const[$,v]=Nt(w),k=[];k[v]=e[w],f[$]=k});const m={},g=this.getFrozenTensorIds(f),y={};for(;h.length>0;){const w=this.processStack(o,h,t,f,y,g,i,m,l);await Promise.all(w)}d==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const x=c.filter(w=>!vx(w)&&!pt(w.name,f,t)).map(w=>w.name);if(x.length>0){let w="";throw d!=null&&(w=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${p}]`),new Error(`Cannot compute the outputs [${x}] from the provided inputs [${a}]. Consider providing the following inputs: [${u}]. ${w}`)}return f}processStack(e,t,s,r,a,o,i,c,l){const u=[];for(;t.length>0;){const d=t.pop();s.currentContext=d.contexts;let p="";if(d.node.op==="Enter"&&b("isConstant",d.node,r,s)&&([p]=wn(d.node.name,s)),r[d.node.name]==null){const h=bx(d.node,r,s,this._resourceManager);p||([p]=wn(d.node.name,s));const f=s.currentContext;Rs(h)?u.push(h.then(m=>(r[p]=m,s.currentContext=f,this.checkTensorForDisposal(p,d.node,r,s,o,i,c),this.processChildNodes(d.node,t,s,r,a,l),m))):(r[p]=h,this.checkTensorForDisposal(p,d.node,r,s,o,i,c),this.processChildNodes(d.node,t,s,r,a,l))}else this.processChildNodes(d.node,t,s,r,a,l)}return u}processChildNodes(e,t,s,r,a,o){e.children.forEach(i=>{const[c]=wn(i.name,s);a[c]||!o.has(i.name)||(i.op==="Merge"?i.inputNames.some(l=>!!pt(l,r,s))&&(a[c]=!0,t.push({contexts:s.currentContext,node:i})):i.inputNames.every(l=>!!pt(l,r,s))&&(a[c]=!0,t.push({contexts:s.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[r]=Nt(t),a=this.graph.nodes[r];if(a.attrParams.shape&&a.attrParams.shape.value){const o=a.attrParams.shape.value,i=o.length===s.shape.length&&s.shape.every((c,l)=>o[l]===-1||o[l]===c);C(i,()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${o}], but was [${s.shape}]`)}a.attrParams.dtype&&a.attrParams.dtype.value&&C(s.dtype===a.attrParams.dtype.value,()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){const t={};for(const s in e)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[s]!=null){const r=this._signature.inputs[s];t[r.name]=e[s]}else t[s]=e[s];return t}checkInputs(e){const t=Object.keys(e).filter(s=>{const[r]=Nt(s);return this.graph.nodes[r]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[t]!=null?this._signature.outputs[t].name:t,{})}checkOutputs(e){e.forEach(t=>{const[s]=Nt(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class EW{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RW="?tfjs-format=file",_W="model.json";class Cx{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",t==null&&(this.loadOptions={}),this.resourceManager=new EW}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=Nu(e,this.loadOptions);else{const t=Th(e,this.loadOptions);if(t.length===0)t.push(Nu(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}async load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let s;this.artifacts.userDefinedMetadata!=null&&this.artifacts.userDefinedMetadata.signature!=null?s=this.artifacts.userDefinedMetadata.signature:s=this.artifacts.signature,this.signature=s,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const r=hu(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new fl(hx.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const a=hx.Instance.transformGraph(e.modelInitializer);this.initializer=new fl(a),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if(typeof e=="string"){const s=Sh(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof Ve)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,s,r)=>(t[s]=e[r],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function AW(n,e={}){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&n.load==null&&(n.endsWith("/")||(n=n+"/"),n=`${n}${_W}${RW}`);const t=new Cx(n,e);return await t.load(),t}/** @license See the LICENSE file. */const DW="3.11.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var FW=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",GraphModel:Cx,loadGraphModel:AW,deregisterOp:uM,registerOp:lM,version_converter:DW}),OW=th(FW),PW=th(GN);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */(function(n,e){(function(t,s){s(e,OW,PW)})(ts,function(t,s,r){const a={1:{name:"/m/01g317",id:1,displayName:"person"},2:{name:"/m/0199g",id:2,displayName:"bicycle"},3:{name:"/m/0k4j",id:3,displayName:"car"},4:{name:"/m/04_sv",id:4,displayName:"motorcycle"},5:{name:"/m/05czz6l",id:5,displayName:"airplane"},6:{name:"/m/01bjv",id:6,displayName:"bus"},7:{name:"/m/07jdr",id:7,displayName:"train"},8:{name:"/m/07r04",id:8,displayName:"truck"},9:{name:"/m/019jd",id:9,displayName:"boat"},10:{name:"/m/015qff",id:10,displayName:"traffic light"},11:{name:"/m/01pns0",id:11,displayName:"fire hydrant"},13:{name:"/m/02pv19",id:13,displayName:"stop sign"},14:{name:"/m/015qbp",id:14,displayName:"parking meter"},15:{name:"/m/0cvnqh",id:15,displayName:"bench"},16:{name:"/m/015p6",id:16,displayName:"bird"},17:{name:"/m/01yrx",id:17,displayName:"cat"},18:{name:"/m/0bt9lr",id:18,displayName:"dog"},19:{name:"/m/03k3r",id:19,displayName:"horse"},20:{name:"/m/07bgp",id:20,displayName:"sheep"},21:{name:"/m/01xq0k1",id:21,displayName:"cow"},22:{name:"/m/0bwd_0j",id:22,displayName:"elephant"},23:{name:"/m/01dws",id:23,displayName:"bear"},24:{name:"/m/0898b",id:24,displayName:"zebra"},25:{name:"/m/03bk1",id:25,displayName:"giraffe"},27:{name:"/m/01940j",id:27,displayName:"backpack"},28:{name:"/m/0hnnb",id:28,displayName:"umbrella"},31:{name:"/m/080hkjn",id:31,displayName:"handbag"},32:{name:"/m/01rkbr",id:32,displayName:"tie"},33:{name:"/m/01s55n",id:33,displayName:"suitcase"},34:{name:"/m/02wmf",id:34,displayName:"frisbee"},35:{name:"/m/071p9",id:35,displayName:"skis"},36:{name:"/m/06__v",id:36,displayName:"snowboard"},37:{name:"/m/018xm",id:37,displayName:"sports ball"},38:{name:"/m/02zt3",id:38,displayName:"kite"},39:{name:"/m/03g8mr",id:39,displayName:"baseball bat"},40:{name:"/m/03grzl",id:40,displayName:"baseball glove"},41:{name:"/m/06_fw",id:41,displayName:"skateboard"},42:{name:"/m/019w40",id:42,displayName:"surfboard"},43:{name:"/m/0dv9c",id:43,displayName:"tennis racket"},44:{name:"/m/04dr76w",id:44,displayName:"bottle"},46:{name:"/m/09tvcd",id:46,displayName:"wine glass"},47:{name:"/m/08gqpm",id:47,displayName:"cup"},48:{name:"/m/0dt3t",id:48,displayName:"fork"},49:{name:"/m/04ctx",id:49,displayName:"knife"},50:{name:"/m/0cmx8",id:50,displayName:"spoon"},51:{name:"/m/04kkgm",id:51,displayName:"bowl"},52:{name:"/m/09qck",id:52,displayName:"banana"},53:{name:"/m/014j1m",id:53,displayName:"apple"},54:{name:"/m/0l515",id:54,displayName:"sandwich"},55:{name:"/m/0cyhj_",id:55,displayName:"orange"},56:{name:"/m/0hkxq",id:56,displayName:"broccoli"},57:{name:"/m/0fj52s",id:57,displayName:"carrot"},58:{name:"/m/01b9xk",id:58,displayName:"hot dog"},59:{name:"/m/0663v",id:59,displayName:"pizza"},60:{name:"/m/0jy4k",id:60,displayName:"donut"},61:{name:"/m/0fszt",id:61,displayName:"cake"},62:{name:"/m/01mzpv",id:62,displayName:"chair"},63:{name:"/m/02crq1",id:63,displayName:"couch"},64:{name:"/m/03fp41",id:64,displayName:"potted plant"},65:{name:"/m/03ssj5",id:65,displayName:"bed"},67:{name:"/m/04bcr3",id:67,displayName:"dining table"},70:{name:"/m/09g1w",id:70,displayName:"toilet"},72:{name:"/m/07c52",id:72,displayName:"tv"},73:{name:"/m/01c648",id:73,displayName:"laptop"},74:{name:"/m/020lf",id:74,displayName:"mouse"},75:{name:"/m/0qjjc",id:75,displayName:"remote"},76:{name:"/m/01m2v",id:76,displayName:"keyboard"},77:{name:"/m/050k8",id:77,displayName:"cell phone"},78:{name:"/m/0fx9l",id:78,displayName:"microwave"},79:{name:"/m/029bxz",id:79,displayName:"oven"},80:{name:"/m/01k6s3",id:80,displayName:"toaster"},81:{name:"/m/0130jx",id:81,displayName:"sink"},82:{name:"/m/040b_t",id:82,displayName:"refrigerator"},84:{name:"/m/0bt_c3",id:84,displayName:"book"},85:{name:"/m/01x3z",id:85,displayName:"clock"},86:{name:"/m/02s195",id:86,displayName:"vase"},87:{name:"/m/01lsmm",id:87,displayName:"scissors"},88:{name:"/m/0kmg4",id:88,displayName:"teddy bear"},89:{name:"/m/03wvsk",id:89,displayName:"hair drier"},90:{name:"/m/012xff",id:90,displayName:"toothbrush"}};class o{constructor(c,l){this.modelPath=l||`https://storage.googleapis.com/tfjs-models/savedmodel/${this.getPrefix(c)}/model.json`}getPrefix(c){return c==="lite_mobilenet_v2"?`ssd${c}`:`ssd_${c}`}async load(){this.model=await s.loadGraphModel(this.modelPath);const c=r.zeros([1,300,300,3],"int32"),l=await this.model.executeAsync(c);await Promise.all(l.map(u=>u.data())),l.map(u=>u.dispose()),c.dispose()}async infer(c,l,u){const d=r.tidy(()=>(c instanceof r.Tensor||(c=r.browser.fromPixels(c)),r.expandDims(c))),p=d.shape[1],h=d.shape[2],f=await this.model.executeAsync(d),m=f[0].dataSync(),g=f[1].dataSync();d.dispose(),r.dispose(f);const[y,x]=this.calculateMaxScores(m,f[0].shape[1],f[0].shape[2]),w=r.getBackend();r.getBackend()==="webgl"&&r.setBackend("cpu");const $=r.tidy(()=>{const k=r.tensor2d(g,[f[1].shape[1],f[1].shape[3]]);return r.image.nonMaxSuppression(k,y,l,u,u)}),v=$.dataSync();return $.dispose(),w!==r.getBackend()&&r.setBackend(w),this.buildDetectedObjects(h,p,g,y,v,x)}buildDetectedObjects(c,l,u,d,p,h){const f=p.length,m=[];for(let g=0;g<f;g++){const y=[];for(let k=0;k<4;k++)y[k]=u[4*p[g]+k];const x=y[0]*l,w=y[1]*c,$=y[2]*l,v=y[3]*c;y[0]=w,y[1]=x,y[2]=v-w,y[3]=$-x,m.push({bbox:y,class:a[h[p[g]]+1].displayName,score:d[p[g]]})}return m}calculateMaxScores(c,l,u){const d=[],p=[];for(let h=0;h<l;h++){let f=Number.MIN_VALUE,m=-1;for(let g=0;g<u;g++)c[h*u+g]>f&&(f=c[h*u+g],m=g);d[h]=f,p[h]=m}return[d,p]}async detect(c,l=20,u=.5){return this.infer(c,l,u)}dispose(){this.model!=null&&this.model.dispose()}}t.ObjectDetection=o,t.load=async function(i={}){if(r==null)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this model.");const c=i.base||"lite_mobilenet_v2",l=i.modelUrl;if(["mobilenet_v1","mobilenet_v2","lite_mobilenet_v2"].indexOf(c)===-1)throw new Error(`ObjectDetection constructed with invalid base model ${c}. Valid names are 'mobilenet_v1', 'mobilenet_v2' and 'lite_mobilenet_v2'.`);const u=new o(c,l);return await u.load(),u},t.version="2.2.2",Object.defineProperty(t,"__esModule",{value:!0})})})(ux,ux.exports);const ml=parseFloat;function gl(n,e=";"){let t;if(Array.isArray(n))t=n.filter(s=>s);else{t=[];for(const s in n)n[s]&&t.push(`${s}:${n[s]}`)}return t.join(e)}function LW(n,e,t,s){let r,a;const o="1em";let i,c,l,u="-.125em";const d="visible";return s&&(l="center",a="1.25em"),t&&(r=t),e&&(e=="lg"?(c="1.33333em",i=".75em",u="-.225em"):e=="xs"?c=".75em":e=="sm"?c=".875em":c=e.replace("x","em")),gl([gl({float:r,width:a,height:o,"line-height":i,"font-size":c,"text-align":l,"vertical-align":u,"transform-origin":"center",overflow:d}),n])}function BW(n,e,t,s,r,a=1,o="",i=""){let c=1,l=1;return r&&(r=="horizontal"?c=-1:r=="vertical"?l=-1:c=l=-1),gl([`translate(${ml(e)*a}${o},${ml(t)*a}${o})`,`scale(${c*ml(n)},${l*ml(n)})`,s&&`rotate(${s}${i})`]," ")}function Nx(n){let e,t,s,r,a,o,i;function c(d,p){return typeof d[7][4]=="string"?MW:VW}let l=c(n),u=l(n);return{c(){e=Yn("svg"),t=Yn("g"),s=Yn("g"),u.c(),this.h()},l(d){e=Is(d,"svg",{id:!0,class:!0,style:!0,viewBox:!0,"aria-hidden":!0,role:!0,xmlns:!0});var p=Qn(e);t=Is(p,"g",{transform:!0,"transform-origin":!0});var h=Qn(t);s=Is(h,"g",{transform:!0});var f=Qn(s);u.l(f),f.forEach(It),h.forEach(It),p.forEach(It),this.h()},h(){he(s,"transform",n[10]),he(t,"transform",r=`translate(${n[7][0]/2} ${n[7][1]/2})`),he(t,"transform-origin",a=`${n[7][0]/4} 0`),he(e,"id",n[0]),he(e,"class",o=""+(Op(n[8])+" svelte-1cj2gr0")),he(e,"style",n[9]),he(e,"viewBox",i=`0 0 ${n[7][0]} ${n[7][1]}`),he(e,"aria-hidden","true"),he(e,"role","img"),he(e,"xmlns","http://www.w3.org/2000/svg")},m(d,p){mr(d,e,p),bl(e,t),bl(t,s),u.m(s,null)},p(d,p){l===(l=c(d))&&u?u.p(d,p):(u.d(1),u=l(d),u&&(u.c(),u.m(s,null))),p&1024&&he(s,"transform",d[10]),p&128&&r!==(r=`translate(${d[7][0]/2} ${d[7][1]/2})`)&&he(t,"transform",r),p&128&&a!==(a=`${d[7][0]/4} 0`)&&he(t,"transform-origin",a),p&1&&he(e,"id",d[0]),p&256&&o!==(o=""+(Op(d[8])+" svelte-1cj2gr0"))&&he(e,"class",o),p&512&&he(e,"style",d[9]),p&128&&i!==(i=`0 0 ${d[7][0]} ${d[7][1]}`)&&he(e,"viewBox",i)},d(d){d&&It(e),u.d()}}}function VW(n){let e,t,s,r,a,o,i,c,l,u;return{c(){e=Yn("path"),o=Yn("path"),this.h()},l(d){e=Is(d,"path",{d:!0,fill:!0,"fill-opacity":!0,transform:!0}),Qn(e).forEach(It),o=Is(d,"path",{d:!0,fill:!0,"fill-opacity":!0,transform:!0}),Qn(o).forEach(It),this.h()},h(){he(e,"d",t=n[7][4][0]),he(e,"fill",s=n[3]||n[1]||"currentColor"),he(e,"fill-opacity",r=n[6]!=!1?n[4]:n[5]),he(e,"transform",a=`translate(${n[7][0]/-2} ${n[7][1]/-2})`),he(o,"d",i=n[7][4][1]),he(o,"fill",c=n[2]||n[1]||"currentColor"),he(o,"fill-opacity",l=n[6]!=!1?n[5]:n[4]),he(o,"transform",u=`translate(${n[7][0]/-2} ${n[7][1]/-2})`)},m(d,p){mr(d,e,p),mr(d,o,p)},p(d,p){p&128&&t!==(t=d[7][4][0])&&he(e,"d",t),p&10&&s!==(s=d[3]||d[1]||"currentColor")&&he(e,"fill",s),p&112&&r!==(r=d[6]!=!1?d[4]:d[5])&&he(e,"fill-opacity",r),p&128&&a!==(a=`translate(${d[7][0]/-2} ${d[7][1]/-2})`)&&he(e,"transform",a),p&128&&i!==(i=d[7][4][1])&&he(o,"d",i),p&6&&c!==(c=d[2]||d[1]||"currentColor")&&he(o,"fill",c),p&112&&l!==(l=d[6]!=!1?d[5]:d[4])&&he(o,"fill-opacity",l),p&128&&u!==(u=`translate(${d[7][0]/-2} ${d[7][1]/-2})`)&&he(o,"transform",u)},d(d){d&&It(e),d&&It(o)}}}function MW(n){let e,t,s,r;return{c(){e=Yn("path"),this.h()},l(a){e=Is(a,"path",{d:!0,fill:!0,transform:!0}),Qn(e).forEach(It),this.h()},h(){he(e,"d",t=n[7][4]),he(e,"fill",s=n[1]||n[2]||"currentColor"),he(e,"transform",r=`translate(${n[7][0]/-2} ${n[7][1]/-2})`)},m(a,o){mr(a,e,o)},p(a,o){o&128&&t!==(t=a[7][4])&&he(e,"d",t),o&6&&s!==(s=a[1]||a[2]||"currentColor")&&he(e,"fill",s),o&128&&r!==(r=`translate(${a[7][0]/-2} ${a[7][1]/-2})`)&&he(e,"transform",r)},d(a){a&&It(e)}}}function WW(n){let e,t=n[7][4]&&Nx(n);return{c(){t&&t.c(),e=Lp()},l(s){t&&t.l(s),e=Lp()},m(s,r){t&&t.m(s,r),mr(s,e,r)},p(s,[r]){s[7][4]?t?t.p(s,r):(t=Nx(s),t.c(),t.m(e.parentNode,e)):t&&(t.d(1),t=null)},i:Xn,o:Xn,d(s){t&&t.d(s),s&&It(e)}}}function zW(n,e,t){let{class:s=""}=e,{id:r=""}=e,{style:a=""}=e,{icon:o}=e,{size:i=""}=e,{color:c=""}=e,{fw:l=!1}=e,{pull:u=""}=e,{scale:d=1}=e,{translateX:p=0}=e,{translateY:h=0}=e,{rotate:f=""}=e,{flip:m=!1}=e,{spin:g=!1}=e,{pulse:y=!1}=e,{primaryColor:x=""}=e,{secondaryColor:w=""}=e,{primaryOpacity:$=1}=e,{secondaryOpacity:v=.4}=e,{swapOpacity:k=!1}=e,I,S,A,R;return n.$$set=_=>{"class"in _&&t(11,s=_.class),"id"in _&&t(0,r=_.id),"style"in _&&t(12,a=_.style),"icon"in _&&t(13,o=_.icon),"size"in _&&t(14,i=_.size),"color"in _&&t(1,c=_.color),"fw"in _&&t(15,l=_.fw),"pull"in _&&t(16,u=_.pull),"scale"in _&&t(17,d=_.scale),"translateX"in _&&t(18,p=_.translateX),"translateY"in _&&t(19,h=_.translateY),"rotate"in _&&t(20,f=_.rotate),"flip"in _&&t(21,m=_.flip),"spin"in _&&t(22,g=_.spin),"pulse"in _&&t(23,y=_.pulse),"primaryColor"in _&&t(2,x=_.primaryColor),"secondaryColor"in _&&t(3,w=_.secondaryColor),"primaryOpacity"in _&&t(4,$=_.primaryOpacity),"secondaryOpacity"in _&&t(5,v=_.secondaryOpacity),"swapOpacity"in _&&t(6,k=_.swapOpacity)},n.$$.update=()=>{n.$$.dirty&8192&&t(7,I=o&&o.icon||[0,0,"",[],""]),n.$$.dirty&12584960&&t(8,S=gl([s,"fa",g&&"spin",y&&"pulse"]," ")),n.$$.dirty&118784&&t(9,A=LW(a,i,u,l)),n.$$.dirty&4063232&&t(10,R=BW(d,p,h,f,m,512))},[r,c,x,w,$,v,k,I,S,A,R,s,a,o,i,l,u,d,p,h,f,m,g,y]}class hz extends Kx{constructor(e){super();jx(this,e,zW,WW,Dp,{class:11,id:0,style:12,icon:13,size:14,color:1,fw:15,pull:16,scale:17,translateX:18,translateY:19,rotate:20,flip:21,spin:22,pulse:23,primaryColor:2,secondaryColor:3,primaryOpacity:4,secondaryOpacity:5,swapOpacity:6})}}/*!
 * Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 */var fz={prefix:"fab",iconName:"github",icon:[496,512,[],"f09b","M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"]};/*!
 * Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 */var mz={prefix:"fas",iconName:"image",icon:[512,512,[],"f03e","M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48zM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56zM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48z"]};export{nz as A,Ex as B,pz as C,GW as D,bl as E,qW as F,jW as G,HW as H,Xn as I,Op as J,UW as K,Bp as L,hz as M,mz as N,tz as O,JW as P,Cl as Q,ez as R,Kx as S,KW as T,fr as U,fz as V,ux as W,Wp as X,Qn as a,he as b,YW as c,It as d,Pp as e,mr as f,Bx as g,ZW as h,jx as i,uz as j,XW as k,Lp as l,dz as m,QW as n,Gx as o,cz as p,lz as q,az as r,Dp as s,wl as t,iz as u,Hx as v,oz as w,Ux as x,rz as y,sz as z};
